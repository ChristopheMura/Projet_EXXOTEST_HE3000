/**
 * @file nmea2000_exxo.h
 *
 * @brief This header file was generated by cantools version 40.7.1 Thu Nov  6 14:18:35 2025.
 *
 * @copyright Copyright (c) 2018-2019 Erik Moqvist
 *
 * @par License
 * The MIT License (MIT)
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef NMEA2000_EXXO_H
#define NMEA2000_EXXO_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define NMEA2000_EXXO_TIME_DATE_FRAME_ID (0xdf809feu)
#define NMEA2000_EXXO_TIME_TO_FROM_MARK_FRAME_ID (0xdf915feu)
#define NMEA2000_EXXO_TIDE_STATION_DATA_FRAME_ID (0x19fd10feu)
#define NMEA2000_EXXO_SYSTEM_TIME_FRAME_ID (0xdf010feu)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_FRAME_ID (0xdf20efeu)
#define NMEA2000_EXXO_SPEED_WATER_REFERENCED_FRAME_ID (0x9f503feu)
#define NMEA2000_EXXO_SMALL_CRAFT_STATUS_FRAME_ID (0x9fe10feu)
#define NMEA2000_EXXO_SET_DRIFT_RAPID_UPDATE_FRAME_ID (0xdf90bfeu)
#define NMEA2000_EXXO_SALINITY_STATION_DATA_FRAME_ID (0x19fd11feu)
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_WP_NAME_POS_FRAME_ID (0x1dfc13feu)
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_WP_NAME_FRAME_ID (0x1dfc14feu)
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_LIST_FRAME_ID (0x1dfc11feu)
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_COMMENT_FRAME_ID (0x1dfc17feu)
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_RADIUS_OF_TURN_FRAME_ID (0x1dfc19feu)
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_DATABASE_LIST_FRAME_ID (0x1dfc10feu)
#define NMEA2000_EXXO_RATE_OF_TURN_FRAME_ID (0x9f113feu)
#define NMEA2000_EXXO_RADIO_FREQUENCY_MODE_POWER_FRAME_ID (0xdfb07feu)
#define NMEA2000_EXXO_PS_DELTA_HIGH_PRECISION_RAPID_UPDATE_FRAME_ID (0x9f803feu)
#define NMEA2000_EXXO_POS_RAPID_UPDATE_FRAME_ID (0x9f801feu)
#define NMEA2000_EXXO_NAVIGATION_ROUTE_WP_INFORMATION_FRAME_ID (0x19f905feu)
#define NMEA2000_EXXO_NAVIGATION_DATA_FRAME_ID (0xdf904feu)
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_FRAME_ID (0xdedfefeu)
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_FRAME_ID (0x19fd14feu)
#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_FRAME_ID (0x19fd13feu)
#define NMEA2000_EXXO_MAGNETIC_VARIATION_FRAME_ID (0x1df11afeu)
#define NMEA2000_EXXO_LORAN_CTD_DATA_FRAME_ID (0xdfc04feu)
#define NMEA2000_EXXO_LORAN_C_SIGNAL_DATA_FRAME_ID (0xdfc06feu)
#define NMEA2000_EXXO_LORAN_C_RANGE_DATA_FRAME_ID (0xdfc05feu)
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_FRAME_ID (0x9f105feu)
#define NMEA2000_EXXO_GPS_ALMANAC_DATA_FRAME_ID (0x19fa05feu)
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_FRAME_ID (0x19fa04feu)
#define NMEA2000_EXXO_GNSSRAIM_SETTINGS_FRAME_ID (0x19fa0afeu)
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_FRAME_ID (0x19f916feu)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_FRAME_ID (0xdf20dfeu)
#define NMEA2000_EXXO_BATTERY_STATUS_FRAME_ID (0x19f214feu)
#define NMEA2000_EXXO_ATTITUDE_FRAME_ID (0xdf119feu)
#define NMEA2000_EXXO_ALTTD_DLT_HGH_PRECISION_RAPID_UPDATE_FRAME_ID (0x9f804feu)
#define NMEA2000_EXXO_AISUTC_DATE_INQUIRY_FRAME_ID (0x1dfb08feu)
#define NMEA2000_EXXO_AISUTC_AND_DATE_REPORT_FRAME_ID (0x1dfb01feu)
#define NMEA2000_EXXO_AIS_SAFETY_RELATED_BROADCAST_MSG_FRAME_ID (0x1dfb0afeu)
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_FRAME_ID (0x1dfb06feu)
#define NMEA2000_EXXO_AIS_INTERROGATION_FRAME_ID (0x1dfb0bfeu)
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_FRAME_ID (0x1dfb0dfeu)
#define NMEA2000_EXXO_AISDGNSS_BROADCAST_BINARY_MSG_FRAME_ID (0x19fb00feu)
#define NMEA2000_EXXO_AIS_CLSS_A_STTC_AND_VYAGE_RELATED_DATA_FRAME_ID (0x1dfb02feu)
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_FRAME_ID (0x11f80ffeu)
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_FRAME_ID (0x11f810feu)
#define NMEA2000_EXXO_CA_FRAME_ID (0x18fed8feu)
#define NMEA2000_EXXO_ACL_FRAME_ID (0x18eefefeu)
#define NMEA2000_EXXO_TPDT_FRAME_ID (0x1cebfefeu)
#define NMEA2000_EXXO_TPCM_FRAME_ID (0x1cecfefeu)
#define NMEA2000_EXXO_RQST_FRAME_ID (0x18eafefeu)
#define NMEA2000_EXXO_WIND_DATA_FRAME_ID (0x9fd02feu)
#define NMEA2000_EXXO_WATER_DEPTH_FRAME_ID (0xdf50bfeu)
#define NMEA2000_EXXO_VESSEL_SPEED_COMPONENTS_FRAME_ID (0x9fe12feu)
#define NMEA2000_EXXO_VESSEL_HEADING_FRAME_ID (0x9f112feu)
#define NMEA2000_EXXO_USER_DATUM_SETTINGS_FRAME_ID (0x19f815feu)
#define NMEA2000_EXXO_TRIP_PARAMETERS_VESSEL_FRAME_ID (0x15f208feu)
#define NMEA2000_EXXO_TRIP_PARAMETERS_ENG_FRAME_ID (0x15f209feu)
#define NMEA2000_EXXO_TRANS_PARAMETERS_DYNAMIC_FRAME_ID (0x9f205feu)
#define NMEA2000_EXXO_TRACKED_TARGET_DATA_FRAME_ID (0x9f608feu)
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_WP_LIST_WP_NAME_POS_FRAME_ID (0x1dfc1afeu)
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_DATABASE_COMMENT_FRAME_ID (0x1dfc18feu)
#define NMEA2000_EXXO_RUDDER_FRAME_ID (0x9f10dfeu)
#define NMEA2000_EXXO_RT_AND_WP_SRVC_XTE_LMT_NVGATION_METHOD_FRAME_ID (0x1dfc15feu)
#define NMEA2000_EXXO_RT_AND_WP_SRVC_RTE_WP_LIST_ATTRIBUTES_FRAME_ID (0x1dfc12feu)
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_WP_COMMENT_FRAME_ID (0x1dfc16feu)
#define NMEA2000_EXXO_GNSSRAIM_OUTPUT_FRAME_ID (0x19fa09feu)
#define NMEA2000_EXXO_GNSS_PSEUDORANGE_NOISE_STATISTICS_FRAME_ID (0x19fa06feu)
#define NMEA2000_EXXO_GNSS_PSEUDORANGE_ERROR_STATISTICS_FRAME_ID (0x19fa0bfeu)
#define NMEA2000_EXXO_GNSS_POS_DATA_FRAME_ID (0xdf805feu)
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_FRAME_ID (0x19fa0efeu)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_FRAME_ID (0x19fa0ffeu)
#define NMEA2000_EXXO_GNSSDO_PS_FRAME_ID (0x19fa03feu)
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_FRAME_ID (0x19fa02feu)
#define NMEA2000_EXXO_GLONASS_ALMANAC_DATA_FRAME_ID (0x19fa14feu)
#define NMEA2000_EXXO_FLUID_LEVEL_FRAME_ID (0x19f211feu)
#define NMEA2000_EXXO_ENVIRONMENTAL_PARAMETERS_FRAME_ID (0x15fd06feu)
#define NMEA2000_EXXO_ENG_PARAMETERS_STATIC_FRAME_ID (0x15f20afeu)
#define NMEA2000_EXXO_ENG_PARAMETERS_RAPID_UPDATE_FRAME_ID (0x9f200feu)
#define NMEA2000_EXXO_ENG_PARAMETERS_DYNAMIC_FRAME_ID (0x9f201feu)
#define NMEA2000_EXXO_DISTANCE_LOG_FRAME_ID (0x19f513feu)
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_FRAME_ID (0x11f80efeu)
#define NMEA2000_EXXO_AIS_BINARY_BROADCAST_MSG_FRAME_ID (0x1dfb05feu)
#define NMEA2000_EXXO_AIS_ASSIGNMENT_MODE_CMD_FRAME_ID (0x1dfb0cfeu)
#define NMEA2000_EXXO_ACKM_FRAME_ID (0x18e8fefeu)
#define NMEA2000_EXXO_DIRECTION_DATA_FRAME_ID (0xdfe11feu)
#define NMEA2000_EXXO_DATUM_FRAME_ID (0x19f814feu)
#define NMEA2000_EXXO_DSC_CALL_INFORMATION_FRAME_ID (0x11fb10feu)
#define NMEA2000_EXXO_DGNSS_CORRECTIONS_FRAME_ID (0x19fa0dfeu)
#define NMEA2000_EXXO_CURRENT_STATION_DATA_FRAME_ID (0x19fd12feu)
#define NMEA2000_EXXO_CROSS_TRACK_ERROR_FRAME_ID (0xdf903feu)
#define NMEA2000_EXXO_COGSOG_RAPID_UPDATE_FRAME_ID (0x9f802feu)
#define NMEA2000_EXXO_AIS_ADDRESSED_SAFETY_RELATED_MSG_FRAME_ID (0x1dfb09feu)
#define NMEA2000_EXXO_AIS_ADDRESSED_BINARY_MSG_FRAME_ID (0x1dfb03feu)
#define NMEA2000_EXXO_AIS_ACKNOWLEDGE_FRAME_ID (0x1dfb04feu)
#define NMEA2000_EXXO_AC_INPUT_STATUS_FRAME_ID (0x19f20ffeu)
#define NMEA2000_EXXO_AC_OUTPUT_STATUS_FRAME_ID (0x19f210feu)
#define NMEA2000_EXXO_DC_DETAILED_STATUS_FRAME_ID (0x19f212feu)
#define NMEA2000_EXXO_CHARGER_STATUS_FRAME_ID (0x19f213feu)
#define NMEA2000_EXXO_INVERTER_STATUS_FRAME_ID (0x19f215feu)
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_FRAME_ID (0x19f216feu)
#define NMEA2000_EXXO_INVERTER_CONFIGURATION_STATUS_FRAME_ID (0x19f217feu)
#define NMEA2000_EXXO_AGS_CONFIGURATION_STATUS_FRAME_ID (0x19f218feu)
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_FRAME_ID (0x19f219feu)
#define NMEA2000_EXXO_AGS_STATUS_FRAME_ID (0x19f21afeu)
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_FRAME_ID (0x1dfb0efeu)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_FRAME_ID (0x1dfb0ffeu)
#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_A_FRAME_ID (0x19fb11feu)
#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_B_FRAME_ID (0x19fb12feu)
#define NMEA2000_EXXO_TEMPERATURE_FRAME_ID (0x15fd08feu)
#define NMEA2000_EXXO_HUMIDITY_FRAME_ID (0x15fd09feu)
#define NMEA2000_EXXO_ACTUAL_PRESSURE_FRAME_ID (0x15fd0afeu)
#define NMEA2000_EXXO_SET_PRESSURE_FRAME_ID (0x15fd0bfeu)
#define NMEA2000_EXXO_ENVIRONMENTAL_PARAMETERS2_FRAME_ID (0x15fd07feu)
#define NMEA2000_EXXO_PRODUCT_INFORMATION_FRAME_ID (0x19f014feu)
#define NMEA2000_EXXO_CONFIG_INFORMATION_FRAME_ID (0x19f016feu)
#define NMEA2000_EXXO_PGN_LST_TRANSMIT_PG_NS_GROUP_FUNCTION_FRAME_ID (0x19eefefeu)

/* Frame lengths in bytes. */
#define NMEA2000_EXXO_TIME_DATE_LENGTH (8u)
#define NMEA2000_EXXO_TIME_TO_FROM_MARK_LENGTH (10u)
#define NMEA2000_EXXO_TIDE_STATION_DATA_LENGTH (23u)
#define NMEA2000_EXXO_SYSTEM_TIME_LENGTH (8u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_LENGTH (8u)
#define NMEA2000_EXXO_SPEED_WATER_REFERENCED_LENGTH (8u)
#define NMEA2000_EXXO_SMALL_CRAFT_STATUS_LENGTH (8u)
#define NMEA2000_EXXO_SET_DRIFT_RAPID_UPDATE_LENGTH (8u)
#define NMEA2000_EXXO_SALINITY_STATION_DATA_LENGTH (25u)
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_WP_NAME_POS_LENGTH (14u)
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_WP_NAME_LENGTH (14u)
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_LIST_LENGTH (12u)
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_COMMENT_LENGTH (13u)
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_RADIUS_OF_TURN_LENGTH (14u)
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_DATABASE_LIST_LENGTH (10u)
#define NMEA2000_EXXO_RATE_OF_TURN_LENGTH (8u)
#define NMEA2000_EXXO_RADIO_FREQUENCY_MODE_POWER_LENGTH (14u)
#define NMEA2000_EXXO_PS_DELTA_HIGH_PRECISION_RAPID_UPDATE_LENGTH (8u)
#define NMEA2000_EXXO_POS_RAPID_UPDATE_LENGTH (8u)
#define NMEA2000_EXXO_NAVIGATION_ROUTE_WP_INFORMATION_LENGTH (16u)
#define NMEA2000_EXXO_NAVIGATION_DATA_LENGTH (34u)
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_LENGTH (15u)
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_LENGTH (36u)
#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_LENGTH (30u)
#define NMEA2000_EXXO_MAGNETIC_VARIATION_LENGTH (8u)
#define NMEA2000_EXXO_LORAN_CTD_DATA_LENGTH (32u)
#define NMEA2000_EXXO_LORAN_C_SIGNAL_DATA_LENGTH (8u)
#define NMEA2000_EXXO_LORAN_C_RANGE_DATA_LENGTH (32u)
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_LENGTH (21u)
#define NMEA2000_EXXO_GPS_ALMANAC_DATA_LENGTH (26u)
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_LENGTH (27u)
#define NMEA2000_EXXO_GNSSRAIM_SETTINGS_LENGTH (8u)
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_LENGTH (17u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_LENGTH (8u)
#define NMEA2000_EXXO_BATTERY_STATUS_LENGTH (8u)
#define NMEA2000_EXXO_ATTITUDE_LENGTH (8u)
#define NMEA2000_EXXO_ALTTD_DLT_HGH_PRECISION_RAPID_UPDATE_LENGTH (8u)
#define NMEA2000_EXXO_AISUTC_DATE_INQUIRY_LENGTH (11u)
#define NMEA2000_EXXO_AISUTC_AND_DATE_REPORT_LENGTH (26u)
#define NMEA2000_EXXO_AIS_SAFETY_RELATED_BROADCAST_MSG_LENGTH (8u)
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_LENGTH (27u)
#define NMEA2000_EXXO_AIS_INTERROGATION_LENGTH (25u)
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_LENGTH (31u)
#define NMEA2000_EXXO_AISDGNSS_BROADCAST_BINARY_MSG_LENGTH (17u)
#define NMEA2000_EXXO_AIS_CLSS_A_STTC_AND_VYAGE_RELATED_DATA_LENGTH (73u)
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_LENGTH (26u)
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_LENGTH (52u)
#define NMEA2000_EXXO_CA_LENGTH (9u)
#define NMEA2000_EXXO_ACL_LENGTH (8u)
#define NMEA2000_EXXO_TPDT_LENGTH (8u)
#define NMEA2000_EXXO_TPCM_LENGTH (8u)
#define NMEA2000_EXXO_RQST_LENGTH (3u)
#define NMEA2000_EXXO_WIND_DATA_LENGTH (8u)
#define NMEA2000_EXXO_WATER_DEPTH_LENGTH (8u)
#define NMEA2000_EXXO_VESSEL_SPEED_COMPONENTS_LENGTH (12u)
#define NMEA2000_EXXO_VESSEL_HEADING_LENGTH (8u)
#define NMEA2000_EXXO_USER_DATUM_SETTINGS_LENGTH (40u)
#define NMEA2000_EXXO_TRIP_PARAMETERS_VESSEL_LENGTH (14u)
#define NMEA2000_EXXO_TRIP_PARAMETERS_ENG_LENGTH (9u)
#define NMEA2000_EXXO_TRANS_PARAMETERS_DYNAMIC_LENGTH (8u)
#define NMEA2000_EXXO_TRACKED_TARGET_DATA_LENGTH (28u)
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_WP_LIST_WP_NAME_POS_LENGTH (14u)
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_DATABASE_COMMENT_LENGTH (11u)
#define NMEA2000_EXXO_RUDDER_LENGTH (8u)
#define NMEA2000_EXXO_RT_AND_WP_SRVC_XTE_LMT_NVGATION_METHOD_LENGTH (15u)
#define NMEA2000_EXXO_RT_AND_WP_SRVC_RTE_WP_LIST_ATTRIBUTES_LENGTH (8u)
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_WP_COMMENT_LENGTH (15u)
#define NMEA2000_EXXO_GNSSRAIM_OUTPUT_LENGTH (15u)
#define NMEA2000_EXXO_GNSS_PSEUDORANGE_NOISE_STATISTICS_LENGTH (15u)
#define NMEA2000_EXXO_GNSS_PSEUDORANGE_ERROR_STATISTICS_LENGTH (15u)
#define NMEA2000_EXXO_GNSS_POS_DATA_LENGTH (51u)
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_LENGTH (8u)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_LENGTH (21u)
#define NMEA2000_EXXO_GNSSDO_PS_LENGTH (8u)
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_LENGTH (16u)
#define NMEA2000_EXXO_GLONASS_ALMANAC_DATA_LENGTH (26u)
#define NMEA2000_EXXO_FLUID_LEVEL_LENGTH (8u)
#define NMEA2000_EXXO_ENVIRONMENTAL_PARAMETERS_LENGTH (8u)
#define NMEA2000_EXXO_ENG_PARAMETERS_STATIC_LENGTH (8u)
#define NMEA2000_EXXO_ENG_PARAMETERS_RAPID_UPDATE_LENGTH (8u)
#define NMEA2000_EXXO_ENG_PARAMETERS_DYNAMIC_LENGTH (26u)
#define NMEA2000_EXXO_DISTANCE_LOG_LENGTH (14u)
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_LENGTH (27u)
#define NMEA2000_EXXO_AIS_BINARY_BROADCAST_MSG_LENGTH (8u)
#define NMEA2000_EXXO_AIS_ASSIGNMENT_MODE_CMD_LENGTH (23u)
#define NMEA2000_EXXO_ACKM_LENGTH (8u)
#define NMEA2000_EXXO_DIRECTION_DATA_LENGTH (14u)
#define NMEA2000_EXXO_DATUM_LENGTH (20u)
#define NMEA2000_EXXO_DSC_CALL_INFORMATION_LENGTH (68u)
#define NMEA2000_EXXO_DGNSS_CORRECTIONS_LENGTH (16u)
#define NMEA2000_EXXO_CURRENT_STATION_DATA_LENGTH (29u)
#define NMEA2000_EXXO_CROSS_TRACK_ERROR_LENGTH (8u)
#define NMEA2000_EXXO_COGSOG_RAPID_UPDATE_LENGTH (8u)
#define NMEA2000_EXXO_AIS_ADDRESSED_SAFETY_RELATED_MSG_LENGTH (13u)
#define NMEA2000_EXXO_AIS_ADDRESSED_BINARY_MSG_LENGTH (13u)
#define NMEA2000_EXXO_AIS_ACKNOWLEDGE_LENGTH (12u)
#define NMEA2000_EXXO_AC_INPUT_STATUS_LENGTH (20u)
#define NMEA2000_EXXO_AC_OUTPUT_STATUS_LENGTH (20u)
#define NMEA2000_EXXO_DC_DETAILED_STATUS_LENGTH (9u)
#define NMEA2000_EXXO_CHARGER_STATUS_LENGTH (6u)
#define NMEA2000_EXXO_INVERTER_STATUS_LENGTH (4u)
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_LENGTH (8u)
#define NMEA2000_EXXO_INVERTER_CONFIGURATION_STATUS_LENGTH (8u)
#define NMEA2000_EXXO_AGS_CONFIGURATION_STATUS_LENGTH (3u)
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_LENGTH (8u)
#define NMEA2000_EXXO_AGS_STATUS_LENGTH (5u)
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_LENGTH (31u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_LENGTH (32u)
#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_A_LENGTH (26u)
#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_B_LENGTH (35u)
#define NMEA2000_EXXO_TEMPERATURE_LENGTH (8u)
#define NMEA2000_EXXO_HUMIDITY_LENGTH (8u)
#define NMEA2000_EXXO_ACTUAL_PRESSURE_LENGTH (8u)
#define NMEA2000_EXXO_SET_PRESSURE_LENGTH (8u)
#define NMEA2000_EXXO_ENVIRONMENTAL_PARAMETERS2_LENGTH (8u)
#define NMEA2000_EXXO_PRODUCT_INFORMATION_LENGTH (132u)
#define NMEA2000_EXXO_CONFIG_INFORMATION_LENGTH (24u)
#define NMEA2000_EXXO_PGN_LST_TRANSMIT_PG_NS_GROUP_FUNCTION_LENGTH (40u)

/* Extended or standard frame types. */
#define NMEA2000_EXXO_TIME_DATE_IS_EXTENDED (1)
#define NMEA2000_EXXO_TIME_TO_FROM_MARK_IS_EXTENDED (1)
#define NMEA2000_EXXO_TIDE_STATION_DATA_IS_EXTENDED (1)
#define NMEA2000_EXXO_SYSTEM_TIME_IS_EXTENDED (1)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_IS_EXTENDED (1)
#define NMEA2000_EXXO_SPEED_WATER_REFERENCED_IS_EXTENDED (1)
#define NMEA2000_EXXO_SMALL_CRAFT_STATUS_IS_EXTENDED (1)
#define NMEA2000_EXXO_SET_DRIFT_RAPID_UPDATE_IS_EXTENDED (1)
#define NMEA2000_EXXO_SALINITY_STATION_DATA_IS_EXTENDED (1)
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_WP_NAME_POS_IS_EXTENDED (1)
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_WP_NAME_IS_EXTENDED (1)
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_LIST_IS_EXTENDED (1)
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_COMMENT_IS_EXTENDED (1)
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_RADIUS_OF_TURN_IS_EXTENDED (1)
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_DATABASE_LIST_IS_EXTENDED (1)
#define NMEA2000_EXXO_RATE_OF_TURN_IS_EXTENDED (1)
#define NMEA2000_EXXO_RADIO_FREQUENCY_MODE_POWER_IS_EXTENDED (1)
#define NMEA2000_EXXO_PS_DELTA_HIGH_PRECISION_RAPID_UPDATE_IS_EXTENDED (1)
#define NMEA2000_EXXO_POS_RAPID_UPDATE_IS_EXTENDED (1)
#define NMEA2000_EXXO_NAVIGATION_ROUTE_WP_INFORMATION_IS_EXTENDED (1)
#define NMEA2000_EXXO_NAVIGATION_DATA_IS_EXTENDED (1)
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_IS_EXTENDED (1)
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_IS_EXTENDED (1)
#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_IS_EXTENDED (1)
#define NMEA2000_EXXO_MAGNETIC_VARIATION_IS_EXTENDED (1)
#define NMEA2000_EXXO_LORAN_CTD_DATA_IS_EXTENDED (1)
#define NMEA2000_EXXO_LORAN_C_SIGNAL_DATA_IS_EXTENDED (1)
#define NMEA2000_EXXO_LORAN_C_RANGE_DATA_IS_EXTENDED (1)
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_IS_EXTENDED (1)
#define NMEA2000_EXXO_GPS_ALMANAC_DATA_IS_EXTENDED (1)
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_IS_EXTENDED (1)
#define NMEA2000_EXXO_GNSSRAIM_SETTINGS_IS_EXTENDED (1)
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_IS_EXTENDED (1)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_IS_EXTENDED (1)
#define NMEA2000_EXXO_BATTERY_STATUS_IS_EXTENDED (1)
#define NMEA2000_EXXO_ATTITUDE_IS_EXTENDED (1)
#define NMEA2000_EXXO_ALTTD_DLT_HGH_PRECISION_RAPID_UPDATE_IS_EXTENDED (1)
#define NMEA2000_EXXO_AISUTC_DATE_INQUIRY_IS_EXTENDED (1)
#define NMEA2000_EXXO_AISUTC_AND_DATE_REPORT_IS_EXTENDED (1)
#define NMEA2000_EXXO_AIS_SAFETY_RELATED_BROADCAST_MSG_IS_EXTENDED (1)
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_IS_EXTENDED (1)
#define NMEA2000_EXXO_AIS_INTERROGATION_IS_EXTENDED (1)
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_IS_EXTENDED (1)
#define NMEA2000_EXXO_AISDGNSS_BROADCAST_BINARY_MSG_IS_EXTENDED (1)
#define NMEA2000_EXXO_AIS_CLSS_A_STTC_AND_VYAGE_RELATED_DATA_IS_EXTENDED (1)
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_IS_EXTENDED (1)
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_IS_EXTENDED (1)
#define NMEA2000_EXXO_CA_IS_EXTENDED (1)
#define NMEA2000_EXXO_ACL_IS_EXTENDED (1)
#define NMEA2000_EXXO_TPDT_IS_EXTENDED (1)
#define NMEA2000_EXXO_TPCM_IS_EXTENDED (1)
#define NMEA2000_EXXO_RQST_IS_EXTENDED (1)
#define NMEA2000_EXXO_WIND_DATA_IS_EXTENDED (1)
#define NMEA2000_EXXO_WATER_DEPTH_IS_EXTENDED (1)
#define NMEA2000_EXXO_VESSEL_SPEED_COMPONENTS_IS_EXTENDED (1)
#define NMEA2000_EXXO_VESSEL_HEADING_IS_EXTENDED (1)
#define NMEA2000_EXXO_USER_DATUM_SETTINGS_IS_EXTENDED (1)
#define NMEA2000_EXXO_TRIP_PARAMETERS_VESSEL_IS_EXTENDED (1)
#define NMEA2000_EXXO_TRIP_PARAMETERS_ENG_IS_EXTENDED (1)
#define NMEA2000_EXXO_TRANS_PARAMETERS_DYNAMIC_IS_EXTENDED (1)
#define NMEA2000_EXXO_TRACKED_TARGET_DATA_IS_EXTENDED (1)
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_WP_LIST_WP_NAME_POS_IS_EXTENDED (1)
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_DATABASE_COMMENT_IS_EXTENDED (1)
#define NMEA2000_EXXO_RUDDER_IS_EXTENDED (1)
#define NMEA2000_EXXO_RT_AND_WP_SRVC_XTE_LMT_NVGATION_METHOD_IS_EXTENDED (1)
#define NMEA2000_EXXO_RT_AND_WP_SRVC_RTE_WP_LIST_ATTRIBUTES_IS_EXTENDED (1)
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_WP_COMMENT_IS_EXTENDED (1)
#define NMEA2000_EXXO_GNSSRAIM_OUTPUT_IS_EXTENDED (1)
#define NMEA2000_EXXO_GNSS_PSEUDORANGE_NOISE_STATISTICS_IS_EXTENDED (1)
#define NMEA2000_EXXO_GNSS_PSEUDORANGE_ERROR_STATISTICS_IS_EXTENDED (1)
#define NMEA2000_EXXO_GNSS_POS_DATA_IS_EXTENDED (1)
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_IS_EXTENDED (1)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_IS_EXTENDED (1)
#define NMEA2000_EXXO_GNSSDO_PS_IS_EXTENDED (1)
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_IS_EXTENDED (1)
#define NMEA2000_EXXO_GLONASS_ALMANAC_DATA_IS_EXTENDED (1)
#define NMEA2000_EXXO_FLUID_LEVEL_IS_EXTENDED (1)
#define NMEA2000_EXXO_ENVIRONMENTAL_PARAMETERS_IS_EXTENDED (1)
#define NMEA2000_EXXO_ENG_PARAMETERS_STATIC_IS_EXTENDED (1)
#define NMEA2000_EXXO_ENG_PARAMETERS_RAPID_UPDATE_IS_EXTENDED (1)
#define NMEA2000_EXXO_ENG_PARAMETERS_DYNAMIC_IS_EXTENDED (1)
#define NMEA2000_EXXO_DISTANCE_LOG_IS_EXTENDED (1)
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_IS_EXTENDED (1)
#define NMEA2000_EXXO_AIS_BINARY_BROADCAST_MSG_IS_EXTENDED (1)
#define NMEA2000_EXXO_AIS_ASSIGNMENT_MODE_CMD_IS_EXTENDED (1)
#define NMEA2000_EXXO_ACKM_IS_EXTENDED (1)
#define NMEA2000_EXXO_DIRECTION_DATA_IS_EXTENDED (1)
#define NMEA2000_EXXO_DATUM_IS_EXTENDED (1)
#define NMEA2000_EXXO_DSC_CALL_INFORMATION_IS_EXTENDED (1)
#define NMEA2000_EXXO_DGNSS_CORRECTIONS_IS_EXTENDED (1)
#define NMEA2000_EXXO_CURRENT_STATION_DATA_IS_EXTENDED (1)
#define NMEA2000_EXXO_CROSS_TRACK_ERROR_IS_EXTENDED (1)
#define NMEA2000_EXXO_COGSOG_RAPID_UPDATE_IS_EXTENDED (1)
#define NMEA2000_EXXO_AIS_ADDRESSED_SAFETY_RELATED_MSG_IS_EXTENDED (1)
#define NMEA2000_EXXO_AIS_ADDRESSED_BINARY_MSG_IS_EXTENDED (1)
#define NMEA2000_EXXO_AIS_ACKNOWLEDGE_IS_EXTENDED (1)
#define NMEA2000_EXXO_AC_INPUT_STATUS_IS_EXTENDED (1)
#define NMEA2000_EXXO_AC_OUTPUT_STATUS_IS_EXTENDED (1)
#define NMEA2000_EXXO_DC_DETAILED_STATUS_IS_EXTENDED (1)
#define NMEA2000_EXXO_CHARGER_STATUS_IS_EXTENDED (1)
#define NMEA2000_EXXO_INVERTER_STATUS_IS_EXTENDED (1)
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_IS_EXTENDED (1)
#define NMEA2000_EXXO_INVERTER_CONFIGURATION_STATUS_IS_EXTENDED (1)
#define NMEA2000_EXXO_AGS_CONFIGURATION_STATUS_IS_EXTENDED (1)
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_IS_EXTENDED (1)
#define NMEA2000_EXXO_AGS_STATUS_IS_EXTENDED (1)
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_IS_EXTENDED (1)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_IS_EXTENDED (1)
#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_A_IS_EXTENDED (1)
#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_B_IS_EXTENDED (1)
#define NMEA2000_EXXO_TEMPERATURE_IS_EXTENDED (1)
#define NMEA2000_EXXO_HUMIDITY_IS_EXTENDED (1)
#define NMEA2000_EXXO_ACTUAL_PRESSURE_IS_EXTENDED (1)
#define NMEA2000_EXXO_SET_PRESSURE_IS_EXTENDED (1)
#define NMEA2000_EXXO_ENVIRONMENTAL_PARAMETERS2_IS_EXTENDED (1)
#define NMEA2000_EXXO_PRODUCT_INFORMATION_IS_EXTENDED (1)
#define NMEA2000_EXXO_CONFIG_INFORMATION_IS_EXTENDED (1)
#define NMEA2000_EXXO_PGN_LST_TRANSMIT_PG_NS_GROUP_FUNCTION_IS_EXTENDED (1)

/* Frame cycle times in milliseconds. */


/* Signal choices. */
#define NMEA2000_EXXO_TIME_DATE_TIME_MIDNIGHT__TIME_IS_IN_UTC_CHOICE (0u)

#define NMEA2000_EXXO_TIME_TO_FROM_MARK_SID_N_VLD_PS_FX_TT_IT_T_RNG0_T250_FR_VLD_PSTN_FX_CHOICE (255u)

#define NMEA2000_EXXO_TIME_TO_FROM_MARK_MARK_TYPE_COLLISION_CHOICE (0u)
#define NMEA2000_EXXO_TIME_TO_FROM_MARK_MARK_TYPE_TURNING_POINT_CHOICE (1u)
#define NMEA2000_EXXO_TIME_TO_FROM_MARK_MARK_TYPE_REFERENCE_GENERAL_CHOICE (2u)
#define NMEA2000_EXXO_TIME_TO_FROM_MARK_MARK_TYPE_WHEELOVER_CHOICE (3u)
#define NMEA2000_EXXO_TIME_TO_FROM_MARK_MARK_TYPE_WAYPOINT_CHOICE (4u)
#define NMEA2000_EXXO_TIME_TO_FROM_MARK_MARK_TYPE_RESERVED_CHOICE (5u)
#define NMEA2000_EXXO_TIME_TO_FROM_MARK_MARK_TYPE_ERROR_CHOICE (14u)
#define NMEA2000_EXXO_TIME_TO_FROM_MARK_MARK_TYPE_NULL_CHOICE (15u)

#define NMEA2000_EXXO_TIDE_STATION_DATA_MODE_AUTONOMOUS_MODE_CHOICE (0u)
#define NMEA2000_EXXO_TIDE_STATION_DATA_MODE_DIFFERENTIAL__ENHANCED_MODE_CHOICE (1u)
#define NMEA2000_EXXO_TIDE_STATION_DATA_MODE_ESTIMATED_MODE_CHOICE (2u)
#define NMEA2000_EXXO_TIDE_STATION_DATA_MODE_SIMULATOR_MODE_CHOICE (3u)
#define NMEA2000_EXXO_TIDE_STATION_DATA_MODE_MANUAL_MODE_CHOICE (4u)
#define NMEA2000_EXXO_TIDE_STATION_DATA_MODE_ERROR_CHOICE (14u)
#define NMEA2000_EXXO_TIDE_STATION_DATA_MODE_DATA_NOT_AVAILABLE_CHOICE (15u)

#define NMEA2000_EXXO_TIDE_STATION_DATA_TIDE_TENDENCY_FALLING_CHOICE (0u)
#define NMEA2000_EXXO_TIDE_STATION_DATA_TIDE_TENDENCY_RISING_CHOICE (1u)
#define NMEA2000_EXXO_TIDE_STATION_DATA_TIDE_TENDENCY_ERROR_CHOICE (10u)
#define NMEA2000_EXXO_TIDE_STATION_DATA_TIDE_TENDENCY_UNAVAILABLE__UNKNOWN_CHOICE (11u)

#define NMEA2000_EXXO_TIDE_STATION_DATA_MEASUREMENT_TIME_MIDNIGHT__TIME_IS_IN_UTC_CHOICE (0u)

#define NMEA2000_EXXO_SYSTEM_TIME_SID_N_VLD_PS_FX_TT_IT_T_RNG0_T250_FR_VLD_PSTN_FX_CHOICE (255u)

#define NMEA2000_EXXO_SYSTEM_TIME_SOURCE_GPS_CHOICE (0u)
#define NMEA2000_EXXO_SYSTEM_TIME_SOURCE_GLONASS_CHOICE (1u)
#define NMEA2000_EXXO_SYSTEM_TIME_SOURCE_WWV_EQVALENT_RADIO_STATION_TIME_SYNC_CHOICE (2u)
#define NMEA2000_EXXO_SYSTEM_TIME_SOURCE_LOCAL_3_CHOICE (3u)
#define NMEA2000_EXXO_SYSTEM_TIME_SOURCE_LOCAL_4_CHOICE (4u)
#define NMEA2000_EXXO_SYSTEM_TIME_SOURCE_LOCAL_CRYSTAL_CLOCK___CHOICE (5u)
#define NMEA2000_EXXO_SYSTEM_TIME_SOURCE_RESERVED_CHOICE (14u)
#define NMEA2000_EXXO_SYSTEM_TIME_SOURCE_NULL_CHOICE (15u)

#define NMEA2000_EXXO_SYSTEM_TIME_TIME_MIDNIGHT__TIME_IS_IN_UTC_CHOICE (0u)

#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH1_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH1_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH1_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH1_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH2_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH2_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH2_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH2_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH3_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH3_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH3_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH3_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH4_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH4_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH4_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH4_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH5_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH5_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH5_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH5_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH6_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH6_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH6_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH6_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH7_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH7_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH7_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH7_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH8_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH8_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH8_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH8_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH9_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH9_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH9_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH9_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH10_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH10_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH10_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH10_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH11_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH11_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH11_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH11_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH12_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH12_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH12_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH12_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH13_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH13_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH13_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH13_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH14_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH14_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH14_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH14_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH15_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH15_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH15_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH15_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH16_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH16_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH16_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH16_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH17_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH17_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH17_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH17_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH18_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH18_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH18_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH18_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH19_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH19_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH19_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH19_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH20_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH20_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH20_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH20_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH21_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH21_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH21_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH21_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH22_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH22_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH22_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH22_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH23_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH23_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH23_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH23_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH24_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH24_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH24_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH24_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH25_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH25_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH25_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH25_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH26_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH26_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH26_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH26_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH27_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH27_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH27_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH27_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH28_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH28_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH28_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH28_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_SPEED_WATER_REFERENCED_SEQUENCE_ID__N_VLD_PS_FX_TT_IT_T_RNG0_T250_FR_VLD_PSTN_FX_CHOICE (255u)

#define NMEA2000_EXXO_SPEED_WATER_REFERENCED_SPEED_WATER_REFERENCED_TYPE_PADDLE_WHEEL_CHOICE (0u)
#define NMEA2000_EXXO_SPEED_WATER_REFERENCED_SPEED_WATER_REFERENCED_TYPE_PITOT_TUBE_CHOICE (1u)
#define NMEA2000_EXXO_SPEED_WATER_REFERENCED_SPEED_WATER_REFERENCED_TYPE_DOPPLER_LOG_CHOICE (2u)
#define NMEA2000_EXXO_SPEED_WATER_REFERENCED_SPEED_WATER_REFERENCED_TYPE_CORRELATION_LOG_ULTRA_SOUND_CHOICE (3u)
#define NMEA2000_EXXO_SPEED_WATER_REFERENCED_SPEED_WATER_REFERENCED_TYPE_EM_LOG_ELECTRO_MAGNETIC_CHOICE (4u)
#define NMEA2000_EXXO_SPEED_WATER_REFERENCED_SPEED_WATER_REFERENCED_TYPE_NOT_SUPPORTED_CHOICE (595u)
#define NMEA2000_EXXO_SPEED_WATER_REFERENCED_SPEED_WATER_REFERENCED_TYPE_ERROR_CHOICE (596u)
#define NMEA2000_EXXO_SPEED_WATER_REFERENCED_SPEED_WATER_REFERENCED_TYPE_DO_NOT_CHANGE_NOT_AVAILABLE_CHOICE (597u)

#define NMEA2000_EXXO_SET_DRIFT_RAPID_UPDATE_SID_N_VLD_PS_FX_TT_IT_T_RNG0_T250_FR_VLD_PSTN_FX_CHOICE (255u)

#define NMEA2000_EXXO_SET_DRIFT_RAPID_UPDATE_SET_REFERENCE_TRUE_CHOICE (0u)
#define NMEA2000_EXXO_SET_DRIFT_RAPID_UPDATE_SET_REFERENCE_MAGNETIC_CHOICE (1u)
#define NMEA2000_EXXO_SET_DRIFT_RAPID_UPDATE_SET_REFERENCE_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_SET_DRIFT_RAPID_UPDATE_SET_REFERENCE_NULL_CHOICE (3u)

#define NMEA2000_EXXO_RATE_OF_TURN_SEQUENCE_ID__N_VLD_PS_FX_TT_IT_T_RNG0_T250_FR_VLD_PSTN_FX_CHOICE (255u)

#define NMEA2000_EXXO_PS_DELTA_HIGH_PRECISION_RAPID_UPDATE_SEQUENCE_ID__N_VLD_PS_FX_TT_IT_T_RNG0_T250_FR_VLD_PSTN_FX_CHOICE (255u)

#define NMEA2000_EXXO_NAVIGATION_ROUTE_WP_INFORMATION_SPPLMNTARY_ROUTE_WP_DATA_AVAILABLE___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_NAVIGATION_ROUTE_WP_INFORMATION_SPPLMNTARY_ROUTE_WP_DATA_AVAILABLE___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_NAVIGATION_ROUTE_WP_INFORMATION_SPPLMNTARY_ROUTE_WP_DATA_AVAILABLE_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_NAVIGATION_ROUTE_WP_INFORMATION_SPPLMNTARY_ROUTE_WP_DATA_AVAILABLE___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_NAVIGATION_DATA_SID_N_VLD_PS_FX_TT_IT_T_RNG0_T250_FR_VLD_PSTN_FX_CHOICE (255u)

#define NMEA2000_EXXO_NAVIGATION_DATA_COURSE_BEARING_REF_TRUE_CHOICE (0u)
#define NMEA2000_EXXO_NAVIGATION_DATA_COURSE_BEARING_REF_MAGNETIC_CHOICE (1u)
#define NMEA2000_EXXO_NAVIGATION_DATA_COURSE_BEARING_REF_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_NAVIGATION_DATA_COURSE_BEARING_REF_NULL_CHOICE (3u)

#define NMEA2000_EXXO_NAVIGATION_DATA_PERPENDICULAR_CROSSED___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_NAVIGATION_DATA_PERPENDICULAR_CROSSED___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_NAVIGATION_DATA_PERPENDICULAR_CROSSED_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_NAVIGATION_DATA_PERPENDICULAR_CROSSED___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_NAVIGATION_DATA_ARRIVAL_CIRCLE_ENTERED___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_NAVIGATION_DATA_ARRIVAL_CIRCLE_ENTERED___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_NAVIGATION_DATA_ARRIVAL_CIRCLE_ENTERED_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_NAVIGATION_DATA_ARRIVAL_CIRCLE_ENTERED___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_NAVIGATION_DATA_CALCULATION_TYPE_GREAT_CIRCLE_CALCULATIONS_CHOICE (0u)
#define NMEA2000_EXXO_NAVIGATION_DATA_CALCULATION_TYPE_RHUMB_LINE_CALCULATIONS_CHOICE (1u)
#define NMEA2000_EXXO_NAVIGATION_DATA_CALCULATION_TYPE_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_NAVIGATION_DATA_CALCULATION_TYPE_NULL_CHOICE (3u)

#define NMEA2000_EXXO_NAVIGATION_DATA_ETA_TIME_MIDNIGHT__TIME_IS_IN_UTC_CHOICE (0u)

#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_GROUP_FUNCTION_RQ_CMD_ACKNOWLEDGE_REQUEST_MESSAGE_CHOICE (0u)
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_GROUP_FUNCTION_RQ_CMD_ACKNOWLEDGE_COMMAND_MESSAGE_CHOICE (1u)
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_GROUP_FUNCTION_RQ_CMD_ACKNOWLEDGE_ACKNOWLEDGE_MESSAGE_CHOICE (2u)

#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_PGN_ERROR_CODE_NO_ERROR__ACKNOWLEDGE_CHOICE (0u)
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_PGN_ERROR_CODE_PGN_NOT_SUPPORTED_CHOICE (1u)
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_PGN_ERROR_CODE_PGN_TEMPORARILY_NOT_AVAILABLE_CHOICE (2u)
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_PGN_ERROR_CODE_ACCESS_DENIED_CHOICE (3u)
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_PGN_ERROR_CODE_REQUEST_IS_NOT_SUPPORTED_CHOICE (4u)

#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_PRIORITY_SETTING_COMMANDED_PRIORITY_VALUE_CHOICE (7u)
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_PRIORITY_SETTING_DO_NOT_CHANGE_PRIORITY_CHOICE (8u)
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_PRIORITY_SETTING_RETURN_PRIORITY_TO_DEFAULT0X_A_TO_CHOICE (9u)
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_PRIORITY_SETTING_RESERVED_CHOICE (15u)

#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_TRANS_INTERVAL_TURN_OFF_TRANSMISSION_CHOICE (0u)
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_TRANS_INTERVAL_DO_NOT_CHANGE_INTERVAL_CHOICE (65535u)

#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_TRANS_INTERVAL_PRIORITY_ERROR_CODE_NO_ERROR__ACKNOWLEDGE_CHOICE (0u)
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_TRANS_INTERVAL_PRIORITY_ERROR_CODE_TRNSMT_INTRVL_PRRITY_NOT_SUPPORTED_CHOICE (1u)
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_TRANS_INTERVAL_PRIORITY_ERROR_CODE_TRNSMT_INTRVL_IS_LSS_THN_MSRMNT_CLCLT_CHOICE (2u)
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_TRANS_INTERVAL_PRIORITY_ERROR_CODE_ACCESS_DENIED_CHOICE (3u)
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_TRANS_INTERVAL_PRIORITY_ERROR_CODE_REQUEST_IS_NOT_SUPPORTED_CHOICE (4u)

#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_FIRST_PARAMETER_ERROR_CODE_NO_ERROR__ACKNOWLEDGE_CHOICE (0u)
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_FIRST_PARAMETER_ERROR_CODE_INVALID_RQ_CMD_PARAMETER_FIELD_CHOICE (1u)
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_FIRST_PARAMETER_ERROR_CODE_TEMPORARILY_UNABLE_TO_COMPLY_CHOICE (2u)
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_FIRST_PARAMETER_ERROR_CODE_RQ_CMD_PARAMETER_OUTOFRANGE_CHOICE (3u)
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_FIRST_PARAMETER_ERROR_CODE_ACCESS_DENIED_CHOICE (4u)
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_FIRST_PARAMETER_ERROR_CODE_RQ_CMD_GROUP_FUNCTION_NOT_SUPPORTED_CHOICE (5u)

#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_VRBL_NMBR_OF_FLDS_FLD_NMBER6_REPEATED3_NO_ERROR__ACKNOWLEDGE_CHOICE (0u)
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_VRBL_NMBR_OF_FLDS_FLD_NMBER6_REPEATED3_INVALID_RQ_CMD_PARAMETER_FIELD_CHOICE (1u)
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_VRBL_NMBR_OF_FLDS_FLD_NMBER6_REPEATED3_TEMPORARILY_UNABLE_TO_COMPLY_CHOICE (2u)
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_VRBL_NMBR_OF_FLDS_FLD_NMBER6_REPEATED3_RQ_CMD_PARAMETER_OUTOFRANGE_CHOICE (3u)
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_VRBL_NMBR_OF_FLDS_FLD_NMBER6_REPEATED3_ACCESS_DENIED_CHOICE (4u)
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_VRBL_NMBR_OF_FLDS_FLD_NMBER6_REPEATED3_RQ_CMD_GROUP_FUNCTION_NOT_SUPPORTED_CHOICE (5u)

#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_TRANS_INTERVAL_OFFSET_TRANSMIT_IMMEDIATELY_CHOICE (0u)
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_TRANS_INTERVAL_OFFSET_DO_NOT_CHANGE_OFFSET_CHOICE (65535u)

#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_MODE_AUTONOMOUS_MODE_CHOICE (0u)
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_MODE_DIFFERENTIAL__ENHANCED_MODE_CHOICE (1u)
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_MODE_ESTIMATED_MODE_CHOICE (2u)
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_MODE_SIMULATOR_MODE_CHOICE (3u)
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_MODE_MANUAL_MODE_CHOICE (4u)
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_MODE_ERROR_CHOICE (14u)
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_MODE_DATA_NOT_AVAILABLE_CHOICE (15u)

#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_MEASUREMENT_TIME_MIDNIGHT__TIME_IS_IN_UTC_CHOICE (0u)

#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_WIND_REFERENCE_TRUE_REFERENCED_TO_NORTH_CHOICE (0u)
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_WIND_REFERENCE_MAGNETIC_CHOICE (1u)
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_WIND_REFERENCE_APPARENT_CHOICE (2u)
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_WIND_REFERENCE_TRUE_BOAT_REFERENCED_CHOICE (3u)
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_WIND_REFERENCE_RESERVED_CHOICE (5u)
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_WIND_REFERENCE_ERROR_CHOICE (6u)
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_WIND_REFERENCE_NULL_CHOICE (7u)

#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_MODE_AUTONOMOUS_MODE_CHOICE (0u)
#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_MODE_DIFFERENTIAL__ENHANCED_MODE_CHOICE (1u)
#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_MODE_ESTIMATED_MODE_CHOICE (2u)
#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_MODE_SIMULATOR_MODE_CHOICE (3u)
#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_MODE_MANUAL_MODE_CHOICE (4u)
#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_MODE_ERROR_CHOICE (14u)
#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_MODE_DATA_NOT_AVAILABLE_CHOICE (15u)

#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_MEASUREMENT_TIME_MIDNIGHT__TIME_IS_IN_UTC_CHOICE (0u)

#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_WIND_REFERENCE_TRUE_REFERENCED_TO_NORTH_CHOICE (0u)
#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_WIND_REFERENCE_MAGNETIC_CHOICE (1u)
#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_WIND_REFERENCE_APPARENT_CHOICE (2u)
#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_WIND_REFERENCE_TRUE_BOAT_REFERENCED_CHOICE (3u)
#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_WIND_REFERENCE_RESERVED_CHOICE (5u)
#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_WIND_REFERENCE_ERROR_CHOICE (6u)
#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_WIND_REFERENCE_NULL_CHOICE (7u)

#define NMEA2000_EXXO_MAGNETIC_VARIATION_SEQUENCE_ID__N_VLD_PS_FX_TT_IT_T_RNG0_T250_FR_VLD_PSTN_FX_CHOICE (255u)

#define NMEA2000_EXXO_MAGNETIC_VARIATION_VARIATION_SOURCE_MANUAL_CHOICE (0u)
#define NMEA2000_EXXO_MAGNETIC_VARIATION_VARIATION_SOURCE_AUTOMATIC_1_CHOICE (1u)
#define NMEA2000_EXXO_MAGNETIC_VARIATION_VARIATION_SOURCE_AUTOMATIC_3_CHOICE (3u)
#define NMEA2000_EXXO_MAGNETIC_VARIATION_VARIATION_SOURCE_WMM_5_CHOICE (5u)
#define NMEA2000_EXXO_MAGNETIC_VARIATION_VARIATION_SOURCE_WMM_7_CHOICE (7u)
#define NMEA2000_EXXO_MAGNETIC_VARIATION_VARIATION_SOURCE_RESERVE__CHOICE (9u)
#define NMEA2000_EXXO_MAGNETIC_VARIATION_VARIATION_SOURCE_RESERVE_CHOICE (62u)
#define NMEA2000_EXXO_MAGNETIC_VARIATION_VARIATION_SOURCE_DATA_NOT_AVAILABLE_CHOICE (63u)
#define NMEA2000_EXXO_MAGNETIC_VARIATION_VARIATION_SOURCE_4_CHOICE (2005u)
#define NMEA2000_EXXO_MAGNETIC_VARIATION_VARIATION_SOURCE_6_CHOICE (2015u)

#define NMEA2000_EXXO_LORAN_CTD_DATA_GROUP_REPETITION_INTERVAL_99_600_000_NS_CHOICE (9960)

#define NMEA2000_EXXO_LORAN_CTD_DATA_MODE_AUTONOMOUS_MODE_CHOICE (0u)
#define NMEA2000_EXXO_LORAN_CTD_DATA_MODE_DIFFERENTIAL__ENHANCED_MODE_CHOICE (1u)
#define NMEA2000_EXXO_LORAN_CTD_DATA_MODE_ESTIMATED_MODE_CHOICE (2u)
#define NMEA2000_EXXO_LORAN_CTD_DATA_MODE_SIMULATOR_MODE_CHOICE (3u)
#define NMEA2000_EXXO_LORAN_CTD_DATA_MODE_MANUAL_MODE_CHOICE (4u)
#define NMEA2000_EXXO_LORAN_CTD_DATA_MODE_ERROR_CHOICE (14u)
#define NMEA2000_EXXO_LORAN_CTD_DATA_MODE_DATA_NOT_AVAILABLE_CHOICE (15u)

#define NMEA2000_EXXO_LORAN_C_SIGNAL_DATA_GROUP_REPETITION_INTERVAL_99_600_000_NS_CHOICE (9960)

#define NMEA2000_EXXO_LORAN_C_RANGE_DATA_GROUP_REPETITION_INTERVAL_99_600_000_NS_CHOICE (9960)

#define NMEA2000_EXXO_LORAN_C_RANGE_DATA_MODE_AUTONOMOUS_MODE_CHOICE (0u)
#define NMEA2000_EXXO_LORAN_C_RANGE_DATA_MODE_DIFFERENTIAL__ENHANCED_MODE_CHOICE (1u)
#define NMEA2000_EXXO_LORAN_C_RANGE_DATA_MODE_ESTIMATED_MODE_CHOICE (2u)
#define NMEA2000_EXXO_LORAN_C_RANGE_DATA_MODE_SIMULATOR_MODE_CHOICE (3u)
#define NMEA2000_EXXO_LORAN_C_RANGE_DATA_MODE_MANUAL_MODE_CHOICE (4u)
#define NMEA2000_EXXO_LORAN_C_RANGE_DATA_MODE_ERROR_CHOICE (14u)
#define NMEA2000_EXXO_LORAN_C_RANGE_DATA_MODE_DATA_NOT_AVAILABLE_CHOICE (15u)

#define NMEA2000_EXXO_HEADING_TRACK_CTRL_RUDDER_LIMIT_EXCEEDED___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_RUDDER_LIMIT_EXCEEDED___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_RUDDER_LIMIT_EXCEEDED_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_RUDDER_LIMIT_EXCEEDED___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_HEADING_TRACK_CTRL_OFF_HEADING_LIMIT_EXCEEDED___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_OFF_HEADING_LIMIT_EXCEEDED___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_OFF_HEADING_LIMIT_EXCEEDED_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_OFF_HEADING_LIMIT_EXCEEDED___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_HEADING_TRACK_CTRL_OFF_TRACK_LIMIT_EXCEEDED___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_OFF_TRACK_LIMIT_EXCEEDED___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_OFF_TRACK_LIMIT_EXCEEDED_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_OFF_TRACK_LIMIT_EXCEEDED___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_HEADING_TRACK_CTRL_OVERRIDE_N_YS_MNS_A_TMPRRY_INTRRPTN_OF_SLCTD_STR_M_CHOICE (0u)
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_OVERRIDE_YES_CHOICE (1u)

#define NMEA2000_EXXO_HEADING_TRACK_CTRL_STEER_MODE_MAIN_STEERING_CHOICE (0u)
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_STEER_MODE_NON__FOLLOW_UP_DEVICE_CHOICE (1u)
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_STEER_MODE_FOLLOW_UP_DEVICE_CHOICE (2u)
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_STEER_MODE_HEADING_CONTROL_STANDALONE_CHOICE (3u)
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_STEER_MODE_HEADING_CONTROL_CHOICE (4u)
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_STEER_MODE_TRCK_CTRL_DFNTNS_MN_STR_OTSD_SYSTM_MN_S_CHOICE (5u)

#define NMEA2000_EXXO_HEADING_TRACK_CTRL_TURN_MODE_RUDDER_LIMIT_CONTROLLED_CHOICE (0u)
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_TURN_MODE_TURN_RATE_CONTROLLED_CHOICE (1u)
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_TURN_MODE_RDS_CTRLLD_DFNTNS_RDDR_AN_OPRTR_ST_RDDR_CHOICE (2u)

#define NMEA2000_EXXO_HEADING_TRACK_CTRL_HEADING_REFERENCE_TRUE_CHOICE (0u)
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_HEADING_REFERENCE_MAGNETIC_CHOICE (1u)
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_HEADING_REFERENCE_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_HEADING_REFERENCE_NULL_CHOICE (3u)

#define NMEA2000_EXXO_HEADING_TRACK_CTRL_CMDED_RUDDER_DIRECTION_NO_ORDER_CHOICE (0u)
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_CMDED_RUDDER_DIRECTION_MOVE_TO_STARBOARD_CHOICE (1u)
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_CMDED_RUDDER_DIRECTION_MOVE_TO_PORT_CHOICE (2u)

#define NMEA2000_EXXO_GPS_ALMANAC_DATA_PRN_NOT_CHOICE (0u)
#define NMEA2000_EXXO_GPS_ALMANAC_DATA_PRN_GPS___CHOICE (1u)
#define NMEA2000_EXXO_GPS_ALMANAC_DATA_PRN_0_CHOICE (33u)
#define NMEA2000_EXXO_GPS_ALMANAC_DATA_PRN_SBAS_STLLT_BSD_AGMENTATION_SYSTEM65_CHOICE (64u)
#define NMEA2000_EXXO_GPS_ALMANAC_DATA_PRN_GLONASS_FR_GLONASS_STLLTS_AR_IDNTFD_BY_CHOICE (96u)

#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_SID_N_VLD_PS_FX_TT_IT_T_RNG0_T250_FR_VLD_PSTN_FX_CHOICE (255u)

#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_RANGE_RESIDUAL_MODE_RANGE_RESIDUAL_WERE_USEDTO_CALC_DATA_CHOICE (0)
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_RANGE_RESIDUAL_MODE_RANGE_RESIDUAL_CALCULATEDD_AFTER_POS_CHOICE (1)
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_RANGE_RESIDUAL_MODE_ERROR_CHOICE (2)
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_RANGE_RESIDUAL_MODE_NULL_CHOICE (3)

#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_PRN1_NOT_CHOICE (0u)
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_PRN1_GPS___CHOICE (1u)
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_PRN1_0_CHOICE (33u)
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_PRN1_SBAS_STLLT_BSD_AGMENTATION_SYSTEM65_CHOICE (64u)
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_PRN1_GLONASS_FR_GLONASS_STLLTS_AR_IDNTFD_BY_CHOICE (96u)

#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_PRN_STATUS1_NOT_TRACKED_CHOICE (0u)
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_PRN_STATUS1_TRACKED_BUT_NOT_USED_IN_SOLUTION_CHOICE (1u)
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_PRN_STATUS1_USD_IN_SLTN_WITHOUT_DIFF_CORRECTIONS_CHOICE (2u)
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_PRN_STATUS1_DIFF_CORRECTIONS_AVAILABLE_CHOICE (3u)
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_PRN_STATUS1_TRACKED_WITH_DIFF_CORRECTIONS_CHOICE (4u)
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_PRN_STATUS1_USED_WITH_DIFF_CORRECTIONS_CHOICE (5u)
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_PRN_STATUS1_RESERVED14_ERROR15_NO_SELECTION_CHOICE (6u)

#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_PRNN_NOT_CHOICE (0u)
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_PRNN_GPS___CHOICE (1u)
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_PRNN_0_CHOICE (33u)
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_PRNN_SBAS_STLLT_BSD_AGMENTATION_SYSTEM65_CHOICE (64u)
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_PRNN_GLONASS_FR_GLONASS_STLLTS_AR_IDNTFD_BY_CHOICE (96u)

#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_PRN_STATUS_N_NOT_TRACKED_CHOICE (0u)
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_PRN_STATUS_N_TRACKED_BUT_NOT_USED_IN_SOLUTION_CHOICE (1u)
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_PRN_STATUS_N_USD_IN_SLTN_WITHOUT_DIFF_CORRECTIONS_CHOICE (2u)
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_PRN_STATUS_N_DIFF_CORRECTIONS_AVAILABLE_CHOICE (3u)
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_PRN_STATUS_N_TRACKED_WITH_DIFF_CORRECTIONS_CHOICE (4u)
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_PRN_STATUS_N_USED_WITH_DIFF_CORRECTIONS_CHOICE (5u)
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_PRN_STATUS_N_RESERVED14_ERROR15_NO_SELECTION_CHOICE (6u)

#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_SID_N_VLD_PS_FX_TT_IT_T_RNG0_T250_FR_VLD_PSTN_FX_CHOICE (255u)

#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_BEARING_REF_TRUE_CHOICE (0u)
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_BEARING_REF_MAGNETIC_CHOICE (1u)
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_BEARING_REF_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_BEARING_REF_NULL_CHOICE (3u)

#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_CALCULATION_TYPE_GREAT_CIRCLE_CALCULATIONS_CHOICE (0u)
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_CALCULATION_TYPE_RHUMB_LINE_CALCULATIONS_CHOICE (1u)
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_CALCULATION_TYPE_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_CALCULATION_TYPE_NULL_CHOICE (3u)

#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_ORIGIN_MARK_TYPE_COLLISION_CHOICE (0u)
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_ORIGIN_MARK_TYPE_TURNING_POINT_CHOICE (1u)
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_ORIGIN_MARK_TYPE_REFERENCE_GENERAL_CHOICE (2u)
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_ORIGIN_MARK_TYPE_WHEELOVER_CHOICE (3u)
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_ORIGIN_MARK_TYPE_WAYPOINT_CHOICE (4u)
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_ORIGIN_MARK_TYPE_RESERVED_CHOICE (5u)
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_ORIGIN_MARK_TYPE_ERROR_CHOICE (14u)
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_ORIGIN_MARK_TYPE_NULL_CHOICE (15u)

#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_DESTINATION_MARK_TYPE_COLLISION_CHOICE (0u)
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_DESTINATION_MARK_TYPE_TURNING_POINT_CHOICE (1u)
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_DESTINATION_MARK_TYPE_REFERENCE_GENERAL_CHOICE (2u)
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_DESTINATION_MARK_TYPE_WHEELOVER_CHOICE (3u)
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_DESTINATION_MARK_TYPE_WAYPOINT_CHOICE (4u)
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_DESTINATION_MARK_TYPE_RESERVED_CHOICE (5u)
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_DESTINATION_MARK_TYPE_ERROR_CHOICE (14u)
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_DESTINATION_MARK_TYPE_NULL_CHOICE (15u)

#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC1___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC1___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC1_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC1___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC2___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC2___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC2_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC2___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC3___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC3___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC3_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC3___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC4___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC4___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC4_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC4___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC5___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC5___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC5_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC5___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC6___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC6___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC6_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC6___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC7___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC7___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC7_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC7___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC8___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC8___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC8_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC8___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC9___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC9___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC9_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC9___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC10___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC10___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC10_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC10___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC11___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC11___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC11_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC11___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC12___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC12___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC12_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC12___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC13___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC13___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC13_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC13___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC14___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC14___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC14_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC14___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC15___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC15___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC15_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC15___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC16___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC16___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC16_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC16___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC17___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC17___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC17_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC17___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC18___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC18___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC18_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC18___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC19___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC19___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC19_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC19___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC20___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC20___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC20_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC20___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC21___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC21___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC21_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC21___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC22___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC22___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC22_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC22___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC23___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC23___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC23_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC23___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC24___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC24___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC24_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC24___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC25___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC25___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC25_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC25___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC26___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC26___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC26_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC26___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC27___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC27___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC27_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC27___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC28___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC28___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC28_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC28___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_BATTERY_STATUS_SID_N_VLD_PS_FX_TT_IT_T_RNG0_T250_FR_VLD_PSTN_FX_CHOICE (255u)

#define NMEA2000_EXXO_ATTITUDE_SID_N_VLD_PS_FX_TT_IT_T_RNG0_T250_FR_VLD_PSTN_FX_CHOICE (255u)

#define NMEA2000_EXXO_ALTTD_DLT_HGH_PRECISION_RAPID_UPDATE_SEQUENCE_ID__N_VLD_PS_FX_TT_IT_T_RNG0_T250_FR_VLD_PSTN_FX_CHOICE (255u)

#define NMEA2000_EXXO_ALTTD_DLT_HGH_PRECISION_RAPID_UPDATE_GNSS_QUALITY_NO_GPS_CHOICE (0u)
#define NMEA2000_EXXO_ALTTD_DLT_HGH_PRECISION_RAPID_UPDATE_GNSS_QUALITY_GNSS_FIX_CHOICE (1u)
#define NMEA2000_EXXO_ALTTD_DLT_HGH_PRECISION_RAPID_UPDATE_GNSS_QUALITY_DGNSS_FIX_CHOICE (2u)
#define NMEA2000_EXXO_ALTTD_DLT_HGH_PRECISION_RAPID_UPDATE_GNSS_QUALITY_PRECISE_GNSS__CHOICE (3u)
#define NMEA2000_EXXO_ALTTD_DLT_HGH_PRECISION_RAPID_UPDATE_GNSS_QUALITY_RTK_FIXED_INTEGER_CHOICE (4u)
#define NMEA2000_EXXO_ALTTD_DLT_HGH_PRECISION_RAPID_UPDATE_GNSS_QUALITY_RTK_FLOAT_CHOICE (5u)
#define NMEA2000_EXXO_ALTTD_DLT_HGH_PRECISION_RAPID_UPDATE_GNSS_QUALITY_ESTIMATED_DR_MODE_CHOICE (6u)
#define NMEA2000_EXXO_ALTTD_DLT_HGH_PRECISION_RAPID_UPDATE_GNSS_QUALITY_MANUAL_INPUT_CHOICE (7u)
#define NMEA2000_EXXO_ALTTD_DLT_HGH_PRECISION_RAPID_UPDATE_GNSS_QUALITY_SIMULATE_MODE_CHOICE (8u)
#define NMEA2000_EXXO_ALTTD_DLT_HGH_PRECISION_RAPID_UPDATE_GNSS_QUALITY_RESERVED_CHOICE (9u)
#define NMEA2000_EXXO_ALTTD_DLT_HGH_PRECISION_RAPID_UPDATE_GNSS_QUALITY_ERROR_CHOICE (14u)
#define NMEA2000_EXXO_ALTTD_DLT_HGH_PRECISION_RAPID_UPDATE_GNSS_QUALITY_NLL_PRCS_GNSS_MNS_N_DLBRT_DGRDTN_AND_HGH_CHOICE (15u)

#define NMEA2000_EXXO_ALTTD_DLT_HGH_PRECISION_RAPID_UPDATE_DIRECTION_TRUE_CHOICE (0u)
#define NMEA2000_EXXO_ALTTD_DLT_HGH_PRECISION_RAPID_UPDATE_DIRECTION_MAGNETIC_CHOICE (1u)
#define NMEA2000_EXXO_ALTTD_DLT_HGH_PRECISION_RAPID_UPDATE_DIRECTION_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_ALTTD_DLT_HGH_PRECISION_RAPID_UPDATE_DIRECTION_NULL_CHOICE (3u)

#define NMEA2000_EXXO_AISUTC_DATE_INQUIRY_REPEAT_INDICATOR_DEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AISUTC_DATE_INQUIRY_REPEAT_INDICATOR_FIRST_RETRANSMISSION_CHOICE (1u)
#define NMEA2000_EXXO_AISUTC_DATE_INQUIRY_REPEAT_INDICATOR_SECOND_RETRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AISUTC_DATE_INQUIRY_REPEAT_INDICATOR_FNL_R_TRNS_SITURM13711_FR_MR_INFRMTON_CHOICE (3u)

#define NMEA2000_EXXO_AISUTC_DATE_INQUIRY_AIS_TRANSCEIVER_INFORMATION_CHANNEL_A_VDL_RECEPTION_CHOICE (0u)
#define NMEA2000_EXXO_AISUTC_DATE_INQUIRY_AIS_TRANSCEIVER_INFORMATION_CHANNEL_B_VDL_RECEPTION_CHOICE (1u)
#define NMEA2000_EXXO_AISUTC_DATE_INQUIRY_AIS_TRANSCEIVER_INFORMATION_CHANNEL_A_VDL_TRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AISUTC_DATE_INQUIRY_AIS_TRANSCEIVER_INFORMATION_CHANNEL_B_VDL_TRANSMISSION_CHOICE (3u)
#define NMEA2000_EXXO_AISUTC_DATE_INQUIRY_AIS_TRANSCEIVER_INFORMATION_OWN_INFORMATION_NOT_BROADCAST_CHOICE (4u)
#define NMEA2000_EXXO_AISUTC_DATE_INQUIRY_AIS_TRANSCEIVER_INFORMATION_RESERVED_CHOICE (5u)

#define NMEA2000_EXXO_AISUTC_AND_DATE_REPORT_REPEAT_INDICATOR_DEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AISUTC_AND_DATE_REPORT_REPEAT_INDICATOR_FIRST_RETRANSMISSION_CHOICE (1u)
#define NMEA2000_EXXO_AISUTC_AND_DATE_REPORT_REPEAT_INDICATOR_SECOND_RETRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AISUTC_AND_DATE_REPORT_REPEAT_INDICATOR_FNL_R_TRNS_SITURM13711_FR_MR_INFRMTON_CHOICE (3u)

#define NMEA2000_EXXO_AISUTC_AND_DATE_REPORT_RAI_MFLAG_RAIM_NOT_IN_USE_DEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AISUTC_AND_DATE_REPORT_RAI_MFLAG_RAIM_IN_US_SITURM13711_FR_MR_INFRMTON_CHOICE (1u)

#define NMEA2000_EXXO_AISUTC_AND_DATE_REPORT_POS_TIME_MIDNIGHT__TIME_IS_IN_UTC_CHOICE (0u)

#define NMEA2000_EXXO_AISUTC_AND_DATE_REPORT_AIS_TRANSCEIVER_INFORMATION_CHANNEL_A_VDL_RECEPTION_CHOICE (0u)
#define NMEA2000_EXXO_AISUTC_AND_DATE_REPORT_AIS_TRANSCEIVER_INFORMATION_CHANNEL_B_VDL_RECEPTION_CHOICE (1u)
#define NMEA2000_EXXO_AISUTC_AND_DATE_REPORT_AIS_TRANSCEIVER_INFORMATION_CHANNEL_A_VDL_TRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AISUTC_AND_DATE_REPORT_AIS_TRANSCEIVER_INFORMATION_CHANNEL_B_VDL_TRANSMISSION_CHOICE (3u)
#define NMEA2000_EXXO_AISUTC_AND_DATE_REPORT_AIS_TRANSCEIVER_INFORMATION_OWN_INFORMATION_NOT_BROADCAST_CHOICE (4u)
#define NMEA2000_EXXO_AISUTC_AND_DATE_REPORT_AIS_TRANSCEIVER_INFORMATION_RESERVED_CHOICE (5u)

#define NMEA2000_EXXO_AISUTC_AND_DATE_REPORT_TYPE_OF_ELECTRONIC_POSING_DEVICE_RSRV_FR_FTR_US_SITURM13711_FR_MR_INFRMT_CHOICE (8u)

#define NMEA2000_EXXO_AIS_SAFETY_RELATED_BROADCAST_MSG_REPEAT_INDICATOR_DEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AIS_SAFETY_RELATED_BROADCAST_MSG_REPEAT_INDICATOR_FIRST_RETRANSMISSION_CHOICE (1u)
#define NMEA2000_EXXO_AIS_SAFETY_RELATED_BROADCAST_MSG_REPEAT_INDICATOR_SECOND_RETRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AIS_SAFETY_RELATED_BROADCAST_MSG_REPEAT_INDICATOR_FNL_R_TRNS_SITURM13711_FR_MR_INFRMTON_CHOICE (3u)

#define NMEA2000_EXXO_AIS_SAFETY_RELATED_BROADCAST_MSG_AIS_TRANSCEIVER_INFORMATION_CHANNEL_A_VDL_RECEPTION_CHOICE (0u)
#define NMEA2000_EXXO_AIS_SAFETY_RELATED_BROADCAST_MSG_AIS_TRANSCEIVER_INFORMATION_CHANNEL_B_VDL_RECEPTION_CHOICE (1u)
#define NMEA2000_EXXO_AIS_SAFETY_RELATED_BROADCAST_MSG_AIS_TRANSCEIVER_INFORMATION_CHANNEL_A_VDL_TRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AIS_SAFETY_RELATED_BROADCAST_MSG_AIS_TRANSCEIVER_INFORMATION_CHANNEL_B_VDL_TRANSMISSION_CHOICE (3u)
#define NMEA2000_EXXO_AIS_SAFETY_RELATED_BROADCAST_MSG_AIS_TRANSCEIVER_INFORMATION_OWN_INFORMATION_NOT_BROADCAST_CHOICE (4u)
#define NMEA2000_EXXO_AIS_SAFETY_RELATED_BROADCAST_MSG_AIS_TRANSCEIVER_INFORMATION_RESERVED_CHOICE (5u)

#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_REPEAT_INDICATOR_DEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_REPEAT_INDICATOR_FIRST_RETRANSMISSION_CHOICE (1u)
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_REPEAT_INDICATOR_SECOND_RETRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_REPEAT_INDICATOR_FNL_R_TRNS_SITURM13711_FR_MR_INFRMTON_CHOICE (3u)

#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_RAIM_FLAG_RAIM_NOT_IN_USE_DEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_RAIM_FLAG_RAIM_IN_US_SITURM13711_FR_MR_INFRMTON_CHOICE (1u)

#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_TIME_STAMP_UTC_SECOND_WHEN_REPORT_WAS_GENERATED_CHOICE (0u)
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_TIME_STAMP_TIME_STAMP_NOT_AVAILABLE_CHOICE (60u)
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_TIME_STAMP_POSING_SYSTEM_IS_IN_MANUAL_INPUT_MODE_CHOICE (61u)
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_TIME_STAMP_ELCTRNC_PS_FXNG_SYSTM_OPRTS_IN_EST_MDE_CHOICE (62u)
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_TIME_STAMP_PSNG_SYSTM_IS_INPRTV_SITURM13711_FR_MR_CHOICE (63u)

#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_AIS_TRANSCEIVER_INFORMATION_CHANNEL_A_VDL_RECEPTION_CHOICE (0u)
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_AIS_TRANSCEIVER_INFORMATION_CHANNEL_B_VDL_RECEPTION_CHOICE (1u)
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_AIS_TRANSCEIVER_INFORMATION_CHANNEL_A_VDL_TRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_AIS_TRANSCEIVER_INFORMATION_CHANNEL_B_VDL_TRANSMISSION_CHOICE (3u)
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_AIS_TRANSCEIVER_INFORMATION_OWN_INFORMATION_NOT_BROADCAST_CHOICE (4u)
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_AIS_TRANSCEIVER_INFORMATION_RESERVED_CHOICE (5u)

#define NMEA2000_EXXO_AIS_INTERROGATION_REPEAT_INDICATOR_DEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AIS_INTERROGATION_REPEAT_INDICATOR_FIRST_RETRANSMISSION_CHOICE (1u)
#define NMEA2000_EXXO_AIS_INTERROGATION_REPEAT_INDICATOR_SECOND_RETRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AIS_INTERROGATION_REPEAT_INDICATOR_FNL_R_TRNS_SITURM13711_FR_MR_INFRMTON_CHOICE (3u)

#define NMEA2000_EXXO_AIS_INTERROGATION_AIS_TRANSCEIVER_INFORMATION_CHANNEL_A_VDL_RECEPTION_CHOICE (0u)
#define NMEA2000_EXXO_AIS_INTERROGATION_AIS_TRANSCEIVER_INFORMATION_CHANNEL_B_VDL_RECEPTION_CHOICE (1u)
#define NMEA2000_EXXO_AIS_INTERROGATION_AIS_TRANSCEIVER_INFORMATION_CHANNEL_A_VDL_TRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AIS_INTERROGATION_AIS_TRANSCEIVER_INFORMATION_CHANNEL_B_VDL_TRANSMISSION_CHOICE (3u)
#define NMEA2000_EXXO_AIS_INTERROGATION_AIS_TRANSCEIVER_INFORMATION_OWN_INFORMATION_NOT_BROADCAST_CHOICE (4u)
#define NMEA2000_EXXO_AIS_INTERROGATION_AIS_TRANSCEIVER_INFORMATION_RESERVED_CHOICE (5u)

#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_REPEAT_INDICATOR_DEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_REPEAT_INDICATOR_FIRST_RETRANSMISSION_CHOICE (1u)
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_REPEAT_INDICATOR_SECOND_RETRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_REPEAT_INDICATOR_FNL_R_TRNS_SITURM13711_FR_MR_INFRMTON_CHOICE (3u)

#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_AIS_TRANSCEIVER_INFORMATION_CHANNEL_A_VDL_RECEPTION_CHOICE (0u)
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_AIS_TRANSCEIVER_INFORMATION_CHANNEL_B_VDL_RECEPTION_CHOICE (1u)
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_AIS_TRANSCEIVER_INFORMATION_CHANNEL_A_VDL_TRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_AIS_TRANSCEIVER_INFORMATION_CHANNEL_B_VDL_TRANSMISSION_CHOICE (3u)
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_AIS_TRANSCEIVER_INFORMATION_OWN_INFORMATION_NOT_BROADCAST_CHOICE (4u)
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_AIS_TRANSCEIVER_INFORMATION_RESERVED_CHOICE (5u)

#define NMEA2000_EXXO_AISDGNSS_BROADCAST_BINARY_MSG_REPEAT_INDICATOR_DEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AISDGNSS_BROADCAST_BINARY_MSG_REPEAT_INDICATOR_FIRST_RETRANSMISSION_CHOICE (1u)
#define NMEA2000_EXXO_AISDGNSS_BROADCAST_BINARY_MSG_REPEAT_INDICATOR_SECOND_RETRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AISDGNSS_BROADCAST_BINARY_MSG_REPEAT_INDICATOR_FNL_R_TRNS_SITURM13711_FR_MR_INFRMTON_CHOICE (3u)

#define NMEA2000_EXXO_AISDGNSS_BROADCAST_BINARY_MSG_AIS_TRANSCEIVER_INFORMATION_CHANNEL_A_VDL_RECEPTION_CHOICE (0u)
#define NMEA2000_EXXO_AISDGNSS_BROADCAST_BINARY_MSG_AIS_TRANSCEIVER_INFORMATION_CHANNEL_B_VDL_RECEPTION_CHOICE (1u)
#define NMEA2000_EXXO_AISDGNSS_BROADCAST_BINARY_MSG_AIS_TRANSCEIVER_INFORMATION_CHANNEL_A_VDL_TRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AISDGNSS_BROADCAST_BINARY_MSG_AIS_TRANSCEIVER_INFORMATION_CHANNEL_B_VDL_TRANSMISSION_CHOICE (3u)
#define NMEA2000_EXXO_AISDGNSS_BROADCAST_BINARY_MSG_AIS_TRANSCEIVER_INFORMATION_OWN_INFORMATION_NOT_BROADCAST_CHOICE (4u)
#define NMEA2000_EXXO_AISDGNSS_BROADCAST_BINARY_MSG_AIS_TRANSCEIVER_INFORMATION_RESERVED_CHOICE (5u)

#define NMEA2000_EXXO_AIS_CLSS_A_STTC_AND_VYAGE_RELATED_DATA_REPEAT_INDICATOR_DEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AIS_CLSS_A_STTC_AND_VYAGE_RELATED_DATA_REPEAT_INDICATOR_FIRST_RETRANSMISSION_CHOICE (1u)
#define NMEA2000_EXXO_AIS_CLSS_A_STTC_AND_VYAGE_RELATED_DATA_REPEAT_INDICATOR_SECOND_RETRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AIS_CLSS_A_STTC_AND_VYAGE_RELATED_DATA_REPEAT_INDICATOR_FNL_R_TRNS_SITURM13711_FR_MR_INFRMTON_CHOICE (3u)

#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_REPEAT_INDICATOR_DEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_REPEAT_INDICATOR_FIRST_RETRANSMISSION_CHOICE (1u)
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_REPEAT_INDICATOR_SECOND_RETRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_REPEAT_INDICATOR_FNL_R_TRNS_SITURM13711_FR_MR_INFRMTON_CHOICE (3u)

#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_RAI_MFLAG_RAIM_NOT_IN_USE_DEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_RAI_MFLAG_RAIM_IN_US_SITURM13711_FR_MR_INFRMTON_CHOICE (1u)

#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_TIME_STAMP_UTC_SECOND_WHEN_REPORT_WAS_GENERATED_CHOICE (0u)
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_TIME_STAMP_TIME_STAMP_NOT_AVAILABLE_CHOICE (60u)
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_TIME_STAMP_POSING_SYSTEM_IS_IN_MANUAL_INPUT_MODE_CHOICE (61u)
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_TIME_STAMP_ELCTRNC_PS_FXNG_SYSTM_OPRTS_IN_EST_MDE_CHOICE (62u)
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_TIME_STAMP_PSNG_SYSTM_IS_INPRTV_SITURM13711_FR_MR_CHOICE (63u)

#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_AIS_TRANSCEIVER_INFORMATION_CHANNEL_A_VDL_RECEPTION_CHOICE (0u)
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_AIS_TRANSCEIVER_INFORMATION_CHANNEL_B_VDL_RECEPTION_CHOICE (1u)
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_AIS_TRANSCEIVER_INFORMATION_CHANNEL_A_VDL_TRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_AIS_TRANSCEIVER_INFORMATION_CHANNEL_B_VDL_TRANSMISSION_CHOICE (3u)
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_AIS_TRANSCEIVER_INFORMATION_OWN_INFORMATION_NOT_BROADCAST_CHOICE (4u)
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_AIS_TRANSCEIVER_INFORMATION_RESERVED_CHOICE (5u)

#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_REPEAT_INDICATOR_DEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_REPEAT_INDICATOR_FIRST_RETRANSMISSION_CHOICE (1u)
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_REPEAT_INDICATOR_SECOND_RETRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_REPEAT_INDICATOR_FNL_R_TRNS_SITURM13711_FR_MR_INFRMTON_CHOICE (3u)

#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_RAI_MFLAG_RAIM_NOT_IN_USE_DEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_RAI_MFLAG_RAIM_IN_US_SITURM13711_FR_MR_INFRMTON_CHOICE (1u)

#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_TIME_STAMP_UTC_SECOND_WHEN_REPORT_WAS_GENERATED_CHOICE (0u)
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_TIME_STAMP_TIME_STAMP_NOT_AVAILABLE_CHOICE (60u)
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_TIME_STAMP_POSING_SYSTEM_IS_IN_MANUAL_INPUT_MODE_CHOICE (61u)
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_TIME_STAMP_ELCTRNC_PS_FXNG_SYSTM_OPRTS_IN_EST_MDE_CHOICE (62u)
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_TIME_STAMP_PSNG_SYSTM_IS_INPRTV_SITURM13711_FR_MR_CHOICE (63u)

#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_SHIP_CARGO_TYPE_100_CHOICE (1u)
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_SHIP_CARGO_TYPE_RESERVED_FOR_REGIONAL200_CHOICE (199u)
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_SHIP_CARGO_TYPE_RESERVED_FOR_FUTURE_CHOICE (255u)

#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_TYPE_OF_ELECTRONIC_POSING_DEVICE_RSRV_FR_FTR_US_SITURM13711_FR_MR_INFRMT_CHOICE (8u)

#define NMEA2000_EXXO_CA_FUNCTION_ENGINE_CHOICE (0u)
#define NMEA2000_EXXO_CA_FUNCTION_AUXILIARY_POWER_UNIT_APU_CHOICE (1u)
#define NMEA2000_EXXO_CA_FUNCTION_ELECTRIC_PROPULSION_CONTROL_CHOICE (2u)
#define NMEA2000_EXXO_CA_FUNCTION_TRANSMISSION_CHOICE (3u)
#define NMEA2000_EXXO_CA_FUNCTION_BATTERY_PACK_MONITOR_CHOICE (4u)
#define NMEA2000_EXXO_CA_FUNCTION_SHIFT_CONTROL__CONSOLE_CHOICE (5u)
#define NMEA2000_EXXO_CA_FUNCTION_POWER_TAKE_OFF___MAIN_OR_REAR_CHOICE (6u)
#define NMEA2000_EXXO_CA_FUNCTION_AXLE___STEERING_CHOICE (7u)
#define NMEA2000_EXXO_CA_FUNCTION_AXLE___DRIVE_CHOICE (8u)
#define NMEA2000_EXXO_CA_FUNCTION_BRAKES___SYSTEM_CONTROLLER_CHOICE (9u)
#define NMEA2000_EXXO_CA_FUNCTION_BRAKES___STEER_AXLE_CHOICE (10u)
#define NMEA2000_EXXO_CA_FUNCTION_BRAKES___DRIVE_AXLE_CHOICE (11u)
#define NMEA2000_EXXO_CA_FUNCTION_RETARDER___ENGINE_CHOICE (12u)
#define NMEA2000_EXXO_CA_FUNCTION_RETARDER___DRIVELINE_CHOICE (13u)
#define NMEA2000_EXXO_CA_FUNCTION_CRUISE_CONTROL_CHOICE (14u)
#define NMEA2000_EXXO_CA_FUNCTION_FUEL_SYSTEM_CHOICE (15u)
#define NMEA2000_EXXO_CA_FUNCTION_STEERING_CONTROLLER_CHOICE (16u)
#define NMEA2000_EXXO_CA_FUNCTION_SUSPENSION___STEER_AXLE_CHOICE (17u)
#define NMEA2000_EXXO_CA_FUNCTION_SUSPENSION___DRIVE_AXLE_CHOICE (18u)
#define NMEA2000_EXXO_CA_FUNCTION_INSTRUMENT_CLUSTER_CHOICE (19u)
#define NMEA2000_EXXO_CA_FUNCTION_TRIP_RECORDER_CHOICE (20u)
#define NMEA2000_EXXO_CA_FUNCTION_CAB_CLIMATE_CONTROL_CHOICE (21u)
#define NMEA2000_EXXO_CA_FUNCTION_AERODYNAMIC_CONTROL_CHOICE (22u)
#define NMEA2000_EXXO_CA_FUNCTION_VEHICLE_NAVIGATION_CHOICE (23u)
#define NMEA2000_EXXO_CA_FUNCTION_VEHICLE_SECURITY_CHOICE (24u)
#define NMEA2000_EXXO_CA_FUNCTION_NETWORK_INTERCONNECT_ECU_CHOICE (25u)
#define NMEA2000_EXXO_CA_FUNCTION_BODY_CONTROLLER_CHOICE (26u)
#define NMEA2000_EXXO_CA_FUNCTION_POWER_TAKE_OFF_SECONDARY_OR_FRONT_CHOICE (27u)
#define NMEA2000_EXXO_CA_FUNCTION_OFF_VEHICLE_GATEWAY_CHOICE (28u)
#define NMEA2000_EXXO_CA_FUNCTION_VIRTUAL_TERMINAL_IN_CAB_CHOICE (29u)
#define NMEA2000_EXXO_CA_FUNCTION_MANAGEMENT_COMPUTER_CHOICE (30u)
#define NMEA2000_EXXO_CA_FUNCTION_PROPULSION_BATTERY_CHARGER_CHOICE (31u)
#define NMEA2000_EXXO_CA_FUNCTION_HEADWAY_CONTROLLER_CHOICE (32u)
#define NMEA2000_EXXO_CA_FUNCTION_SYSTEM_MONITOR_CHOICE (33u)
#define NMEA2000_EXXO_CA_FUNCTION_HYDRAULIC_PUMP_CONTROLLER_CHOICE (34u)
#define NMEA2000_EXXO_CA_FUNCTION_SUSPENSION___SYSTEM_CONTROLLER_CHOICE (35u)
#define NMEA2000_EXXO_CA_FUNCTION_PNEUMATIC___SYSTEM_CONTROLLER_CHOICE (36u)
#define NMEA2000_EXXO_CA_FUNCTION_CAB_CONTROLLER_CHOICE (37u)
#define NMEA2000_EXXO_CA_FUNCTION_TIRE_PRESSURE_CONTROL_CHOICE (38u)
#define NMEA2000_EXXO_CA_FUNCTION_IGNITION_CONTROL_MODULE_CHOICE (39u)
#define NMEA2000_EXXO_CA_FUNCTION_SEAT_CONTROL_CHOICE (40u)
#define NMEA2000_EXXO_CA_FUNCTION_LIGHTING___OPERATOR_CONTROLS_CHOICE (41u)
#define NMEA2000_EXXO_CA_FUNCTION_WATER_PUMP_CONTROL_CHOICE (42u)
#define NMEA2000_EXXO_CA_FUNCTION_TRANSMISSION_DISPLAY_CHOICE (43u)
#define NMEA2000_EXXO_CA_FUNCTION_EXHAUST_EMISSION_CONTROL_CHOICE (44u)
#define NMEA2000_EXXO_CA_FUNCTION_VEHICLE_DYNAMIC_STABILITY_CONTROL_CHOICE (45u)
#define NMEA2000_EXXO_CA_FUNCTION_OIL_SENSOR_UNIT_CHOICE (46u)
#define NMEA2000_EXXO_CA_FUNCTION_INFORMATION_SYSTEM_CONTROLLER_CHOICE (47u)
#define NMEA2000_EXXO_CA_FUNCTION_RAMP_CONTROL_CHOICE (48u)
#define NMEA2000_EXXO_CA_FUNCTION_CLUTCH__CONVERTER_CONTROL_CHOICE (49u)
#define NMEA2000_EXXO_CA_FUNCTION_AUXILIARY_HEATER_CHOICE (50u)
#define NMEA2000_EXXO_CA_FUNCTION_FORWARD__LOOKING_COLLISION_WARNING_SYSTEM_CHOICE (51u)
#define NMEA2000_EXXO_CA_FUNCTION_CHASSIS_CONTROLLER_CHOICE (52u)
#define NMEA2000_EXXO_CA_FUNCTION_ALTERNATOR__CHARGING_SYSTEM_CHOICE (53u)
#define NMEA2000_EXXO_CA_FUNCTION_COMMUNICATIONS_UNIT__CELLULAR_CHOICE (54u)
#define NMEA2000_EXXO_CA_FUNCTION_COMMUNICATIONS_UNIT__SATELLITE_CHOICE (55u)
#define NMEA2000_EXXO_CA_FUNCTION_COMMUNICATIONS_UNIT__RADIO_CHOICE (56u)
#define NMEA2000_EXXO_CA_FUNCTION_STEERING_COLUMN_UNIT_CHOICE (57u)
#define NMEA2000_EXXO_CA_FUNCTION_FAN_DRIVE_CONTROL_CHOICE (58u)
#define NMEA2000_EXXO_CA_FUNCTION_STARTER_CHOICE (59u)
#define NMEA2000_EXXO_CA_FUNCTION_CAB_DISPLAY_CHOICE (60u)
#define NMEA2000_EXXO_CA_FUNCTION_FILE_SERVER__PRINTER_CHOICE (61u)
#define NMEA2000_EXXO_CA_FUNCTION_ON__BOARD_DIAGNOSTIC_UNIT_CHOICE (62u)
#define NMEA2000_EXXO_CA_FUNCTION_ENGINE_VALVE_CONTROLLER_CHOICE (63u)
#define NMEA2000_EXXO_CA_FUNCTION_ENDURANCE_BRAKING_CHOICE (64u)
#define NMEA2000_EXXO_CA_FUNCTION_GAS_FLOW_MEASUREMENT_CHOICE (65u)
#define NMEA2000_EXXO_CA_FUNCTION_I_O_CONTROLLER_CHOICE (66u)
#define NMEA2000_EXXO_CA_FUNCTION_ELECTRICAL_SYSTEM_CONTROLLER_CHOICE (67u)
#define NMEA2000_EXXO_CA_FUNCTION_AFTERTREATMENT_SYSTEM_GAS_MEASUREMENT_CHOICE (68u)
#define NMEA2000_EXXO_CA_FUNCTION_ENGINE_EMISSION_AFTERTREATEMENT_SYSTEM_CHOICE (69u)
#define NMEA2000_EXXO_CA_FUNCTION_AUXILIARY_REGENERATION_DEVICE_CHOICE (70u)
#define NMEA2000_EXXO_CA_FUNCTION_TRANSFER_CASE_CONTROL_CHOICE (71u)
#define NMEA2000_EXXO_CA_FUNCTION_COOLANT_VALVE_CONTROLLER_CHOICE (72u)
#define NMEA2000_EXXO_CA_FUNCTION_ROLLOVER_DETECTION_CONTROL_CHOICE (73u)
#define NMEA2000_EXXO_CA_FUNCTION_LUBRICATION_SYSTEM_CHOICE (74u)
#define NMEA2000_EXXO_CA_FUNCTION_SUPPLEMENTAL_FAN_CHOICE (75u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_76_CHOICE (76u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_77_CHOICE (77u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_78_CHOICE (78u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_79_CHOICE (79u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_80_CHOICE (80u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_81_CHOICE (81u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_82_CHOICE (82u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_83_CHOICE (83u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_84_CHOICE (84u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_85_CHOICE (85u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_86_CHOICE (86u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_87_CHOICE (87u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_88_CHOICE (88u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_89_CHOICE (89u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_90_CHOICE (90u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_91_CHOICE (91u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_92_CHOICE (92u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_93_CHOICE (93u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_94_CHOICE (94u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_95_CHOICE (95u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_96_CHOICE (96u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_97_CHOICE (97u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_98_CHOICE (98u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_99_CHOICE (99u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_100_CHOICE (100u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_101_CHOICE (101u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_102_CHOICE (102u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_103_CHOICE (103u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_104_CHOICE (104u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_105_CHOICE (105u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_106_CHOICE (106u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_107_CHOICE (107u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_108_CHOICE (108u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_109_CHOICE (109u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_110_CHOICE (110u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_111_CHOICE (111u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_112_CHOICE (112u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_113_CHOICE (113u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_114_CHOICE (114u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_115_CHOICE (115u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_116_CHOICE (116u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_117_CHOICE (117u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_118_CHOICE (118u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_119_CHOICE (119u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_120_CHOICE (120u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_121_CHOICE (121u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_122_CHOICE (122u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_123_CHOICE (123u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_124_CHOICE (124u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_125_CHOICE (125u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_126_CHOICE (126u)
#define NMEA2000_EXXO_CA_FUNCTION_RESERVED_127_CHOICE (127u)

#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM_NON_SPECIFIC_SYSTEM_CHOICE (0u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM_NOT_AVAILABLE_CHOICE (127u)

#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM5_IND__PROCESS_CONTROL_STATIONARY_CHOICE (0u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM5_NOT_AVAILABLE_CHOICE (127u)

#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM4_NON_SPECIFIC_SYSTEM_CHOICE (0u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM4_SYSTEM_TOOLS_CHOICE (10u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM4_SAFETY_SYSTEMS_CHOICE (20u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM4_INTER__INTRANETWORK_DEVICE_CHOICE (25u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM4_ELECTRICAL_DISTRIBUTION_CHOICE (30u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM4_ELECTRICAL_GENERATION_CHOICE (35u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM4_STEERING_AND_CONTROL_SURFACES_CHOICE (40u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM4_PROPULSION_CHOICE (50u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM4_NAVIGATION_CHOICE (60u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM4_COMMUNICATIONS_CHOICE (70u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM4_SENSOR_COMMUNICATION_INTERFACE_CHOICE (75u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM4_INSTRUMENTATION__GENERAL_SYSTEMS_DEPRECATE_CHOICE (80u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM4_EXTERNAL_ENVIRONMENT_CHOICE (85u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM4_INTERNAL_ENVIRONMENT_CHOICE (90u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM4_DECK__CARGO_AND_FISHING_EQUIPMENT_CHOICE (100u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM4_DISPLAY_CHOICE (120u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM4_ENTERTAINMENT_CHOICE (125u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM4_NOT_AVAILABLE_CHOICE (127u)

#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM3_NON_SPECIFIC_SYSTEM_CHOICE (0u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM3_SKID_STEER_LOADER_CHOICE (1u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM3_ARTICULATED_DUMP_TRUCK_CHOICE (2u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM3_BACKHOE_CHOICE (3u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM3_CRAWLER_CHOICE (4u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM3_EXCAVATOR_CHOICE (5u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM3_FORKLIFT_CHOICE (6u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM3_FOUR_WHEEL_DRIVE_LOADER_CHOICE (7u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM3_GRADER_CHOICE (8u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM3_NOT_AVAILABLE_CHOICE (127u)

#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM2_NON_SPECIFIC_SYSTEM_CHOICE (0u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM2_TRACTOR_CHOICE (1u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM2_TILLAGE_CHOICE (2u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM2_SECONDARY_TILLAGE_CHOICE (3u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM2_PLANTERS__SEEDERS_CHOICE (4u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM2_FERTILIZERS_CHOICE (5u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM2_SPRAYERS_CHOICE (6u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM2_HARVESTERS_CHOICE (7u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM2_ROOT_HARVESTERS_CHOICE (8u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM2_FORAGE_CHOICE (9u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM2_IRRIGATION_CHOICE (10u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM2_TRANSPORT__TRAILER_CHOICE (11u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM2_FARM_YARD_OPERATIONS_CHOICE (12u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM2_POWERED_AUXILIARY_DEVICE_CHOICE (13u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM2_SPECIAL_CROPS_CHOICE (14u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM2_EARTH_WORK_CHOICE (15u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM2_SKIDDER_CHOICE (16u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM2_NOT_AVAILABLE_CHOICE (127u)

#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM1_NON_SPECIFIC_SYSTEM_CHOICE (0u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM1_TRACTOR_CHOICE (1u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM1_TRAILER_CHOICE (2u)
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM1_NOT_AVAILABLE_CHOICE (127u)

#define NMEA2000_EXXO_CA_INDUSTRY_GROUP_GLOBAL_CHOICE (0u)
#define NMEA2000_EXXO_CA_INDUSTRY_GROUP_ON__HIGHWAY_CHOICE (1u)
#define NMEA2000_EXXO_CA_INDUSTRY_GROUP_AGRICULTURAL_AND_FORESTRY_CHOICE (2u)
#define NMEA2000_EXXO_CA_INDUSTRY_GROUP_CONSTRUCTION_CHOICE (3u)
#define NMEA2000_EXXO_CA_INDUSTRY_GROUP_MARINE_CHOICE (4u)
#define NMEA2000_EXXO_CA_INDUSTRY_GROUP_INDUSTRIAL_PROCESS_CTRL_STATIONARY_CHOICE (5u)
#define NMEA2000_EXXO_CA_INDUSTRY_GROUP_RESERVED_FOR_SAE_6_CHOICE (6u)
#define NMEA2000_EXXO_CA_INDUSTRY_GROUP_RESERVED_FOR_SAE_7_CHOICE (7u)

#define NMEA2000_EXXO_ACL_FUNCTION_ENGINE_CHOICE (0u)
#define NMEA2000_EXXO_ACL_FUNCTION_AUXILIARY_POWER_UNIT_APU_CHOICE (1u)
#define NMEA2000_EXXO_ACL_FUNCTION_ELECTRIC_PROPULSION_CONTROL_CHOICE (2u)
#define NMEA2000_EXXO_ACL_FUNCTION_TRANSMISSION_CHOICE (3u)
#define NMEA2000_EXXO_ACL_FUNCTION_BATTERY_PACK_MONITOR_CHOICE (4u)
#define NMEA2000_EXXO_ACL_FUNCTION_SHIFT_CONTROL__CONSOLE_CHOICE (5u)
#define NMEA2000_EXXO_ACL_FUNCTION_POWER_TAKE_OFF___MAIN_OR_REAR_CHOICE (6u)
#define NMEA2000_EXXO_ACL_FUNCTION_AXLE___STEERING_CHOICE (7u)
#define NMEA2000_EXXO_ACL_FUNCTION_AXLE___DRIVE_CHOICE (8u)
#define NMEA2000_EXXO_ACL_FUNCTION_BRAKES___SYSTEM_CONTROLLER_CHOICE (9u)
#define NMEA2000_EXXO_ACL_FUNCTION_BRAKES___STEER_AXLE_CHOICE (10u)
#define NMEA2000_EXXO_ACL_FUNCTION_BRAKES___DRIVE_AXLE_CHOICE (11u)
#define NMEA2000_EXXO_ACL_FUNCTION_RETARDER___ENGINE_CHOICE (12u)
#define NMEA2000_EXXO_ACL_FUNCTION_RETARDER___DRIVELINE_CHOICE (13u)
#define NMEA2000_EXXO_ACL_FUNCTION_CRUISE_CONTROL_CHOICE (14u)
#define NMEA2000_EXXO_ACL_FUNCTION_FUEL_SYSTEM_CHOICE (15u)
#define NMEA2000_EXXO_ACL_FUNCTION_STEERING_CONTROLLER_CHOICE (16u)
#define NMEA2000_EXXO_ACL_FUNCTION_SUSPENSION___STEER_AXLE_CHOICE (17u)
#define NMEA2000_EXXO_ACL_FUNCTION_SUSPENSION___DRIVE_AXLE_CHOICE (18u)
#define NMEA2000_EXXO_ACL_FUNCTION_INSTRUMENT_CLUSTER_CHOICE (19u)
#define NMEA2000_EXXO_ACL_FUNCTION_TRIP_RECORDER_CHOICE (20u)
#define NMEA2000_EXXO_ACL_FUNCTION_CAB_CLIMATE_CONTROL_CHOICE (21u)
#define NMEA2000_EXXO_ACL_FUNCTION_AERODYNAMIC_CONTROL_CHOICE (22u)
#define NMEA2000_EXXO_ACL_FUNCTION_VEHICLE_NAVIGATION_CHOICE (23u)
#define NMEA2000_EXXO_ACL_FUNCTION_VEHICLE_SECURITY_CHOICE (24u)
#define NMEA2000_EXXO_ACL_FUNCTION_NETWORK_INTERCONNECT_ECU_CHOICE (25u)
#define NMEA2000_EXXO_ACL_FUNCTION_BODY_CONTROLLER_CHOICE (26u)
#define NMEA2000_EXXO_ACL_FUNCTION_POWER_TAKE_OFF_SECONDARY_OR_FRONT_CHOICE (27u)
#define NMEA2000_EXXO_ACL_FUNCTION_OFF_VEHICLE_GATEWAY_CHOICE (28u)
#define NMEA2000_EXXO_ACL_FUNCTION_VIRTUAL_TERMINAL_IN_CAB_CHOICE (29u)
#define NMEA2000_EXXO_ACL_FUNCTION_MANAGEMENT_COMPUTER_CHOICE (30u)
#define NMEA2000_EXXO_ACL_FUNCTION_PROPULSION_BATTERY_CHARGER_CHOICE (31u)
#define NMEA2000_EXXO_ACL_FUNCTION_HEADWAY_CONTROLLER_CHOICE (32u)
#define NMEA2000_EXXO_ACL_FUNCTION_SYSTEM_MONITOR_CHOICE (33u)
#define NMEA2000_EXXO_ACL_FUNCTION_HYDRAULIC_PUMP_CONTROLLER_CHOICE (34u)
#define NMEA2000_EXXO_ACL_FUNCTION_SUSPENSION___SYSTEM_CONTROLLER_CHOICE (35u)
#define NMEA2000_EXXO_ACL_FUNCTION_PNEUMATIC___SYSTEM_CONTROLLER_CHOICE (36u)
#define NMEA2000_EXXO_ACL_FUNCTION_CAB_CONTROLLER_CHOICE (37u)
#define NMEA2000_EXXO_ACL_FUNCTION_TIRE_PRESSURE_CONTROL_CHOICE (38u)
#define NMEA2000_EXXO_ACL_FUNCTION_IGNITION_CONTROL_MODULE_CHOICE (39u)
#define NMEA2000_EXXO_ACL_FUNCTION_SEAT_CONTROL_CHOICE (40u)
#define NMEA2000_EXXO_ACL_FUNCTION_LIGHTING___OPERATOR_CONTROLS_CHOICE (41u)
#define NMEA2000_EXXO_ACL_FUNCTION_WATER_PUMP_CONTROL_CHOICE (42u)
#define NMEA2000_EXXO_ACL_FUNCTION_TRANSMISSION_DISPLAY_CHOICE (43u)
#define NMEA2000_EXXO_ACL_FUNCTION_EXHAUST_EMISSION_CONTROL_CHOICE (44u)
#define NMEA2000_EXXO_ACL_FUNCTION_VEHICLE_DYNAMIC_STABILITY_CONTROL_CHOICE (45u)
#define NMEA2000_EXXO_ACL_FUNCTION_OIL_SENSOR_UNIT_CHOICE (46u)
#define NMEA2000_EXXO_ACL_FUNCTION_INFORMATION_SYSTEM_CONTROLLER_CHOICE (47u)
#define NMEA2000_EXXO_ACL_FUNCTION_RAMP_CONTROL_CHOICE (48u)
#define NMEA2000_EXXO_ACL_FUNCTION_CLUTCH__CONVERTER_CONTROL_CHOICE (49u)
#define NMEA2000_EXXO_ACL_FUNCTION_AUXILIARY_HEATER_CHOICE (50u)
#define NMEA2000_EXXO_ACL_FUNCTION_FORWARD__LOOKING_COLLISION_WARNING_SYSTEM_CHOICE (51u)
#define NMEA2000_EXXO_ACL_FUNCTION_CHASSIS_CONTROLLER_CHOICE (52u)
#define NMEA2000_EXXO_ACL_FUNCTION_ALTERNATOR__CHARGING_SYSTEM_CHOICE (53u)
#define NMEA2000_EXXO_ACL_FUNCTION_COMMUNICATIONS_UNIT__CELLULAR_CHOICE (54u)
#define NMEA2000_EXXO_ACL_FUNCTION_COMMUNICATIONS_UNIT__SATELLITE_CHOICE (55u)
#define NMEA2000_EXXO_ACL_FUNCTION_COMMUNICATIONS_UNIT__RADIO_CHOICE (56u)
#define NMEA2000_EXXO_ACL_FUNCTION_STEERING_COLUMN_UNIT_CHOICE (57u)
#define NMEA2000_EXXO_ACL_FUNCTION_FAN_DRIVE_CONTROL_CHOICE (58u)
#define NMEA2000_EXXO_ACL_FUNCTION_STARTER_CHOICE (59u)
#define NMEA2000_EXXO_ACL_FUNCTION_CAB_DISPLAY_CHOICE (60u)
#define NMEA2000_EXXO_ACL_FUNCTION_FILE_SERVER__PRINTER_CHOICE (61u)
#define NMEA2000_EXXO_ACL_FUNCTION_ON__BOARD_DIAGNOSTIC_UNIT_CHOICE (62u)
#define NMEA2000_EXXO_ACL_FUNCTION_ENGINE_VALVE_CONTROLLER_CHOICE (63u)
#define NMEA2000_EXXO_ACL_FUNCTION_ENDURANCE_BRAKING_CHOICE (64u)
#define NMEA2000_EXXO_ACL_FUNCTION_GAS_FLOW_MEASUREMENT_CHOICE (65u)
#define NMEA2000_EXXO_ACL_FUNCTION_I_O_CONTROLLER_CHOICE (66u)
#define NMEA2000_EXXO_ACL_FUNCTION_ELECTRICAL_SYSTEM_CONTROLLER_CHOICE (67u)
#define NMEA2000_EXXO_ACL_FUNCTION_AFTERTREATMENT_SYSTEM_GAS_MEASUREMENT_CHOICE (68u)
#define NMEA2000_EXXO_ACL_FUNCTION_ENGINE_EMISSION_AFTERTREATEMENT_SYSTEM_CHOICE (69u)
#define NMEA2000_EXXO_ACL_FUNCTION_AUXILIARY_REGENERATION_DEVICE_CHOICE (70u)
#define NMEA2000_EXXO_ACL_FUNCTION_TRANSFER_CASE_CONTROL_CHOICE (71u)
#define NMEA2000_EXXO_ACL_FUNCTION_COOLANT_VALVE_CONTROLLER_CHOICE (72u)
#define NMEA2000_EXXO_ACL_FUNCTION_ROLLOVER_DETECTION_CONTROL_CHOICE (73u)
#define NMEA2000_EXXO_ACL_FUNCTION_LUBRICATION_SYSTEM_CHOICE (74u)
#define NMEA2000_EXXO_ACL_FUNCTION_SUPPLEMENTAL_FAN_CHOICE (75u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_76_CHOICE (76u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_77_CHOICE (77u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_78_CHOICE (78u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_79_CHOICE (79u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_80_CHOICE (80u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_81_CHOICE (81u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_82_CHOICE (82u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_83_CHOICE (83u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_84_CHOICE (84u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_85_CHOICE (85u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_86_CHOICE (86u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_87_CHOICE (87u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_88_CHOICE (88u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_89_CHOICE (89u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_90_CHOICE (90u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_91_CHOICE (91u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_92_CHOICE (92u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_93_CHOICE (93u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_94_CHOICE (94u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_95_CHOICE (95u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_96_CHOICE (96u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_97_CHOICE (97u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_98_CHOICE (98u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_99_CHOICE (99u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_100_CHOICE (100u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_101_CHOICE (101u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_102_CHOICE (102u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_103_CHOICE (103u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_104_CHOICE (104u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_105_CHOICE (105u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_106_CHOICE (106u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_107_CHOICE (107u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_108_CHOICE (108u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_109_CHOICE (109u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_110_CHOICE (110u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_111_CHOICE (111u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_112_CHOICE (112u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_113_CHOICE (113u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_114_CHOICE (114u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_115_CHOICE (115u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_116_CHOICE (116u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_117_CHOICE (117u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_118_CHOICE (118u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_119_CHOICE (119u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_120_CHOICE (120u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_121_CHOICE (121u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_122_CHOICE (122u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_123_CHOICE (123u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_124_CHOICE (124u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_125_CHOICE (125u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_126_CHOICE (126u)
#define NMEA2000_EXXO_ACL_FUNCTION_RESERVED_127_CHOICE (127u)

#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM_NON_SPECIFIC_SYSTEM_CHOICE (0u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM_NOT_AVAILABLE_CHOICE (127u)

#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM5_IND__PROCESS_CONTROL_STATIONARY_CHOICE (0u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM5_NOT_AVAILABLE_CHOICE (127u)

#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM4_NON_SPECIFIC_SYSTEM_CHOICE (0u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM4_SYSTEM_TOOLS_CHOICE (10u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM4_SAFETY_SYSTEMS_CHOICE (20u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM4_INTER__INTRANETWORK_DEVICE_CHOICE (25u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM4_ELECTRICAL_DISTRIBUTION_CHOICE (30u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM4_ELECTRICAL_GENERATION_CHOICE (35u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM4_STEERING_AND_CONTROL_SURFACES_CHOICE (40u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM4_PROPULSION_CHOICE (50u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM4_NAVIGATION_CHOICE (60u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM4_COMMUNICATIONS_CHOICE (70u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM4_SENSOR_COMMUNICATION_INTERFACE_CHOICE (75u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM4_INSTRUMENTATION__GENERAL_SYSTEMS_DEPRECATE_CHOICE (80u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM4_EXTERNAL_ENVIRONMENT_CHOICE (85u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM4_INTERNAL_ENVIRONMENT_CHOICE (90u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM4_DECK__CARGO_AND_FISHING_EQUIPMENT_CHOICE (100u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM4_DISPLAY_CHOICE (120u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM4_ENTERTAINMENT_CHOICE (125u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM4_NOT_AVAILABLE_CHOICE (127u)

#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM3_NON_SPECIFIC_SYSTEM_CHOICE (0u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM3_SKID_STEER_LOADER_CHOICE (1u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM3_ARTICULATED_DUMP_TRUCK_CHOICE (2u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM3_BACKHOE_CHOICE (3u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM3_CRAWLER_CHOICE (4u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM3_EXCAVATOR_CHOICE (5u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM3_FORKLIFT_CHOICE (6u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM3_FOUR_WHEEL_DRIVE_LOADER_CHOICE (7u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM3_GRADER_CHOICE (8u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM3_NOT_AVAILABLE_CHOICE (127u)

#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM2_NON_SPECIFIC_SYSTEM_CHOICE (0u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM2_TRACTOR_CHOICE (1u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM2_TILLAGE_CHOICE (2u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM2_SECONDARY_TILLAGE_CHOICE (3u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM2_PLANTERS__SEEDERS_CHOICE (4u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM2_FERTILIZERS_CHOICE (5u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM2_SPRAYERS_CHOICE (6u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM2_HARVESTERS_CHOICE (7u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM2_ROOT_HARVESTERS_CHOICE (8u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM2_FORAGE_CHOICE (9u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM2_IRRIGATION_CHOICE (10u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM2_TRANSPORT__TRAILER_CHOICE (11u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM2_FARM_YARD_OPERATIONS_CHOICE (12u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM2_POWERED_AUXILIARY_DEVICE_CHOICE (13u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM2_SPECIAL_CROPS_CHOICE (14u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM2_EARTH_WORK_CHOICE (15u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM2_SKIDDER_CHOICE (16u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM2_NOT_AVAILABLE_CHOICE (127u)

#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM1_NON_SPECIFIC_SYSTEM_CHOICE (0u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM1_TRACTOR_CHOICE (1u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM1_TRAILER_CHOICE (2u)
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM1_NOT_AVAILABLE_CHOICE (127u)

#define NMEA2000_EXXO_ACL_INDUSTRY_GROUP_GLOBAL_CHOICE (0u)
#define NMEA2000_EXXO_ACL_INDUSTRY_GROUP_ON__HIGHWAY_CHOICE (1u)
#define NMEA2000_EXXO_ACL_INDUSTRY_GROUP_AGRICULTURAL_AND_FORESTRY_CHOICE (2u)
#define NMEA2000_EXXO_ACL_INDUSTRY_GROUP_CONSTRUCTION_CHOICE (3u)
#define NMEA2000_EXXO_ACL_INDUSTRY_GROUP_MARINE_CHOICE (4u)
#define NMEA2000_EXXO_ACL_INDUSTRY_GROUP_INDUSTRIAL_PROCESS_CTRL_STATIONARY_CHOICE (5u)
#define NMEA2000_EXXO_ACL_INDUSTRY_GROUP_RESERVED_FOR_SAE_6_CHOICE (6u)
#define NMEA2000_EXXO_ACL_INDUSTRY_GROUP_RESERVED_FOR_SAE_7_CHOICE (7u)

#define NMEA2000_EXXO_TPCM_CONTROL_BYTE_RTS_CHOICE (16u)
#define NMEA2000_EXXO_TPCM_CONTROL_BYTE_CTS_CHOICE (17u)
#define NMEA2000_EXXO_TPCM_CONTROL_BYTE_EO_MA_CHOICE (19u)
#define NMEA2000_EXXO_TPCM_CONTROL_BYTE_ERTS_CHOICE (20u)
#define NMEA2000_EXXO_TPCM_CONTROL_BYTE_ECTS_CHOICE (21u)
#define NMEA2000_EXXO_TPCM_CONTROL_BYTE_EDPO_CHOICE (22u)
#define NMEA2000_EXXO_TPCM_CONTROL_BYTE_E_EO_MACK_CHOICE (23u)
#define NMEA2000_EXXO_TPCM_CONTROL_BYTE_E_ABORT_CHOICE (24u)
#define NMEA2000_EXXO_TPCM_CONTROL_BYTE_BAM_CHOICE (32u)
#define NMEA2000_EXXO_TPCM_CONTROL_BYTE_ABORT_CHOICE (255u)

#define NMEA2000_EXXO_TPCM_PG_NUMBER_NOT_AVAILABLE_CHOICE (255u)

#define NMEA2000_EXXO_WIND_DATA_SEQUENCE_ID__N_VLD_PS_FX_TT_IT_T_RNG0_T250_FR_VLD_PSTN_FX_CHOICE (255u)

#define NMEA2000_EXXO_WIND_DATA_WIND_REFERENCE_TRUE_REFERENCED_TO_NORTH_CHOICE (0u)
#define NMEA2000_EXXO_WIND_DATA_WIND_REFERENCE_MAGNETIC_CHOICE (1u)
#define NMEA2000_EXXO_WIND_DATA_WIND_REFERENCE_APPARENT_CHOICE (2u)
#define NMEA2000_EXXO_WIND_DATA_WIND_REFERENCE_TRUE_BOAT_REFERENCED_CHOICE (3u)
#define NMEA2000_EXXO_WIND_DATA_WIND_REFERENCE_RESERVED_CHOICE (5u)
#define NMEA2000_EXXO_WIND_DATA_WIND_REFERENCE_ERROR_CHOICE (6u)
#define NMEA2000_EXXO_WIND_DATA_WIND_REFERENCE_NULL_CHOICE (7u)

#define NMEA2000_EXXO_WATER_DEPTH_SID_N_VLD_PS_FX_TT_IT_T_RNG0_T250_FR_VLD_PSTN_FX_CHOICE (255u)

#define NMEA2000_EXXO_VESSEL_HEADING_SID_N_VLD_PS_FX_TT_IT_T_RNG0_T250_FR_VLD_PSTN_FX_CHOICE (255u)

#define NMEA2000_EXXO_VESSEL_HEADING_HEADING_SENSOR_REFERENCE_TRUE_CHOICE (0u)
#define NMEA2000_EXXO_VESSEL_HEADING_HEADING_SENSOR_REFERENCE_MAGNETIC_CHOICE (1u)
#define NMEA2000_EXXO_VESSEL_HEADING_HEADING_SENSOR_REFERENCE_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_VESSEL_HEADING_HEADING_SENSOR_REFERENCE_NULL_CHOICE (3u)

#define NMEA2000_EXXO_TRIP_PARAMETERS_ENG_ENG_INSTANCE_SINGLE_ENG_DUAL_ENGINE_PORT_CHOICE (0u)
#define NMEA2000_EXXO_TRIP_PARAMETERS_ENG_ENG_INSTANCE_DL_ENG_STR_BRD_T_STRN_STRBRD_N_INSTNC_N_WH_CHOICE (1u)
#define NMEA2000_EXXO_TRIP_PARAMETERS_ENG_ENG_INSTANCE_RESERVE_CHOICE (253u)
#define NMEA2000_EXXO_TRIP_PARAMETERS_ENG_ENG_INSTANCE_ERROR_CHOICE (254u)
#define NMEA2000_EXXO_TRIP_PARAMETERS_ENG_ENG_INSTANCE_NOT_AVAILABLE_CHOICE (255u)

#define NMEA2000_EXXO_TRANS_PARAMETERS_DYNAMIC_TRANS_INSTANCE_SINGLE_ENG_DUAL_ENGINE_PORT_CHOICE (0u)
#define NMEA2000_EXXO_TRANS_PARAMETERS_DYNAMIC_TRANS_INSTANCE_DL_ENG_STR_BRD_T_STRN_STRBRD_N_INSTNC_N_WH_CHOICE (1u)
#define NMEA2000_EXXO_TRANS_PARAMETERS_DYNAMIC_TRANS_INSTANCE_RESERVE_CHOICE (253u)
#define NMEA2000_EXXO_TRANS_PARAMETERS_DYNAMIC_TRANS_INSTANCE_ERROR_CHOICE (254u)
#define NMEA2000_EXXO_TRANS_PARAMETERS_DYNAMIC_TRANS_INSTANCE_NOT_AVAILABLE_CHOICE (255u)

#define NMEA2000_EXXO_TRANS_PARAMETERS_DYNAMIC_TRANS_GEAR_FORWARD_CHOICE (0u)
#define NMEA2000_EXXO_TRANS_PARAMETERS_DYNAMIC_TRANS_GEAR_NEUTRAL_CHOICE (1u)
#define NMEA2000_EXXO_TRANS_PARAMETERS_DYNAMIC_TRANS_GEAR_REVERSE_CHOICE (2u)
#define NMEA2000_EXXO_TRANS_PARAMETERS_DYNAMIC_TRANS_GEAR___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_TRACKED_TARGET_DATA_SEQUENCE_ID__N_VLD_PS_FX_TT_IT_T_RNG0_T250_FR_VLD_PSTN_FX_CHOICE (255u)

#define NMEA2000_EXXO_TRACKED_TARGET_DATA_BEARING_REFERENCE_TRUE_CHOICE (0u)
#define NMEA2000_EXXO_TRACKED_TARGET_DATA_BEARING_REFERENCE_MAGNETIC_CHOICE (1u)
#define NMEA2000_EXXO_TRACKED_TARGET_DATA_BEARING_REFERENCE_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_TRACKED_TARGET_DATA_BEARING_REFERENCE_RELEATIVE_CHOICE (3u)

#define NMEA2000_EXXO_TRACKED_TARGET_DATA_UTC_OF_FIX_MIDNIGHT__TIME_IS_IN_UTC_CHOICE (0u)

#define NMEA2000_EXXO_RUDDER_RUDDER_INSTANCE_SINGLE_ENG_DUAL_ENGINE_PORT_CHOICE (0u)
#define NMEA2000_EXXO_RUDDER_RUDDER_INSTANCE_DL_ENG_STR_BRD_T_STRN_STRBRD_N_INSTNC_N_WH_CHOICE (1u)
#define NMEA2000_EXXO_RUDDER_RUDDER_INSTANCE_RESERVE_CHOICE (253u)
#define NMEA2000_EXXO_RUDDER_RUDDER_INSTANCE_ERROR_CHOICE (254u)
#define NMEA2000_EXXO_RUDDER_RUDDER_INSTANCE_NOT_AVAILABLE_CHOICE (255u)

#define NMEA2000_EXXO_RUDDER_DIRECTIONDER_NO_ORDER_CHOICE (0u)
#define NMEA2000_EXXO_RUDDER_DIRECTIONDER_MOVE_TO_STARBOARD_CHOICE (1u)
#define NMEA2000_EXXO_RUDDER_DIRECTIONDER_MOVE_TO_PORT_CHOICE (2u)

#define NMEA2000_EXXO_RT_AND_WP_SRVC_XTE_LMT_NVGATION_METHOD_NAV_METHOD_IN_LEG_AFTER_WP_GREAT_CIRCLE_CALCULATIONS_CHOICE (0u)
#define NMEA2000_EXXO_RT_AND_WP_SRVC_XTE_LMT_NVGATION_METHOD_NAV_METHOD_IN_LEG_AFTER_WP_RHUMB_LINE_CALCULATIONS_CHOICE (1u)
#define NMEA2000_EXXO_RT_AND_WP_SRVC_XTE_LMT_NVGATION_METHOD_NAV_METHOD_IN_LEG_AFTER_WP_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_RT_AND_WP_SRVC_XTE_LMT_NVGATION_METHOD_NAV_METHOD_IN_LEG_AFTER_WP_NULL_CHOICE (3u)

#define NMEA2000_EXXO_GNSSRAIM_OUTPUT_SEQUENCE_ID__N_VLD_PS_FX_TT_IT_T_RNG0_T250_FR_VLD_PSTN_FX_CHOICE (255u)

#define NMEA2000_EXXO_GNSSRAIM_OUTPUT_INTEGRITY_FLAG_NO_INTEGRITY_CHECKING___CHOICE (0u)
#define NMEA2000_EXXO_GNSSRAIM_OUTPUT_INTEGRITY_FLAG_SAFE_CHOICE (1u)
#define NMEA2000_EXXO_GNSSRAIM_OUTPUT_INTEGRITY_FLAG_CAUTION_CHOICE (2u)
#define NMEA2000_EXXO_GNSSRAIM_OUTPUT_INTEGRITY_FLAG_UNSF_MNS_RCVR_DS_NT_HV_THIS_CAPABILITY_CHOICE (3u)

#define NMEA2000_EXXO_GNSSRAIM_OUTPUT_SVID_OF_MOST_LIKELY_FAILED_SAT_NOT_CHOICE (0u)
#define NMEA2000_EXXO_GNSSRAIM_OUTPUT_SVID_OF_MOST_LIKELY_FAILED_SAT_GPS___CHOICE (1u)
#define NMEA2000_EXXO_GNSSRAIM_OUTPUT_SVID_OF_MOST_LIKELY_FAILED_SAT_0_CHOICE (33u)
#define NMEA2000_EXXO_GNSSRAIM_OUTPUT_SVID_OF_MOST_LIKELY_FAILED_SAT_SBAS_STLLT_BSD_AGMENTATION_SYSTEM65_CHOICE (64u)
#define NMEA2000_EXXO_GNSSRAIM_OUTPUT_SVID_OF_MOST_LIKELY_FAILED_SAT_GLONASS_FR_GLONASS_STLLTS_AR_IDNTFD_BY_CHOICE (96u)

#define NMEA2000_EXXO_GNSS_PSEUDORANGE_NOISE_STATISTICS_SID_N_VLD_PS_FX_TT_IT_T_RNG0_T250_FR_VLD_PSTN_FX_CHOICE (255u)

#define NMEA2000_EXXO_GNSS_PSEUDORANGE_ERROR_STATISTICS_SEQUENCE_ID__N_VLD_PS_FX_TT_IT_T_RNG0_T250_FR_VLD_PSTN_FX_CHOICE (255u)

#define NMEA2000_EXXO_GNSS_POS_DATA_SID_N_VLD_PS_FX_TT_IT_T_RNG0_T250_FR_VLD_PSTN_FX_CHOICE (255u)

#define NMEA2000_EXXO_GNSS_POS_DATA_POS_TIME_MIDNIGHT__TIME_IS_IN_UTC_CHOICE (0u)

#define NMEA2000_EXXO_GNSS_POS_DATA_TYPE_OF_SYSTEM__GPS_CHOICE (0u)
#define NMEA2000_EXXO_GNSS_POS_DATA_TYPE_OF_SYSTEM__GLONASS_CHOICE (1u)
#define NMEA2000_EXXO_GNSS_POS_DATA_TYPE_OF_SYSTEM__GPS_GLONASS_CHOICE (2u)
#define NMEA2000_EXXO_GNSS_POS_DATA_TYPE_OF_SYSTEM__GPS_SBASWAAS_CHOICE (3u)
#define NMEA2000_EXXO_GNSS_POS_DATA_TYPE_OF_SYSTEM__GPS_SBAS_GLONASS_CHOICE (4u)
#define NMEA2000_EXXO_GNSS_POS_DATA_TYPE_OF_SYSTEM__RESERVED_FOR_FUTURE_COMBINATIONS_CHOICE (21u)

#define NMEA2000_EXXO_GNSS_POS_DATA_METHOD_GNSS_NO_GPS_CHOICE (0u)
#define NMEA2000_EXXO_GNSS_POS_DATA_METHOD_GNSS_GNSS_FIX_CHOICE (1u)
#define NMEA2000_EXXO_GNSS_POS_DATA_METHOD_GNSS_DGNSS_FIX_CHOICE (2u)
#define NMEA2000_EXXO_GNSS_POS_DATA_METHOD_GNSS_PRECISE_GNSS__CHOICE (3u)
#define NMEA2000_EXXO_GNSS_POS_DATA_METHOD_GNSS_RTK_FIXED_INTEGER_CHOICE (4u)
#define NMEA2000_EXXO_GNSS_POS_DATA_METHOD_GNSS_RTK_FLOAT_CHOICE (5u)
#define NMEA2000_EXXO_GNSS_POS_DATA_METHOD_GNSS_ESTIMATED_DR_MODE_CHOICE (6u)
#define NMEA2000_EXXO_GNSS_POS_DATA_METHOD_GNSS_MANUAL_INPUT_CHOICE (7u)
#define NMEA2000_EXXO_GNSS_POS_DATA_METHOD_GNSS_SIMULATE_MODE_CHOICE (8u)
#define NMEA2000_EXXO_GNSS_POS_DATA_METHOD_GNSS_RESERVED_CHOICE (9u)
#define NMEA2000_EXXO_GNSS_POS_DATA_METHOD_GNSS_ERROR_CHOICE (14u)
#define NMEA2000_EXXO_GNSS_POS_DATA_METHOD_GNSS_NLL_PRCS_GNSS_MNS_N_DLBRT_DGRDTN_AND_HGH_CHOICE (15u)

#define NMEA2000_EXXO_GNSS_POS_DATA_INTEGRITY_NO_INTEGRITY_CHECKING___CHOICE (0u)
#define NMEA2000_EXXO_GNSS_POS_DATA_INTEGRITY_SAFE_CHOICE (1u)
#define NMEA2000_EXXO_GNSS_POS_DATA_INTEGRITY_CAUTION_CHOICE (2u)
#define NMEA2000_EXXO_GNSS_POS_DATA_INTEGRITY_UNSF_MNS_RCVR_DS_NT_HV_THIS_CAPABILITY_CHOICE (3u)

#define NMEA2000_EXXO_GNSS_POS_DATA_REFERENCE_STATION_TYPE1_GLONASS__CHOICE (1u)
#define NMEA2000_EXXO_GNSS_POS_DATA_REFERENCE_STATION_TYPE1_RESERVED_CHOICE (13u)
#define NMEA2000_EXXO_GNSS_POS_DATA_REFERENCE_STATION_TYPE1_ERROR_CHOICE (14u)
#define NMEA2000_EXXO_GNSS_POS_DATA_REFERENCE_STATION_TYPE1_NULL_CHOICE (15u)

#define NMEA2000_EXXO_GNSS_POS_DATA_REFERENCE_STATION_TYPE_N_GLONASS__CHOICE (1u)
#define NMEA2000_EXXO_GNSS_POS_DATA_REFERENCE_STATION_TYPE_N_RESERVED_CHOICE (13u)
#define NMEA2000_EXXO_GNSS_POS_DATA_REFERENCE_STATION_TYPE_N_ERROR_CHOICE (14u)
#define NMEA2000_EXXO_GNSS_POS_DATA_REFERENCE_STATION_TYPE_N_NULL_CHOICE (15u)

#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_SERIAL_INTERFACE_BIT_RATE_0_CHOICE (0u)
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_SERIAL_INTERFACE_BIT_RATE_57600BPS__CHOICE (12u)
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_SERIAL_INTERFACE_BIT_RATE_11_CHOICE (13u)
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_SERIAL_INTERFACE_BIT_RATE_RESERVED_CHOICE (29u)
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_SERIAL_INTERFACE_BIT_RATE_ERROR_CHOICE (30u)
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_SERIAL_INTERFACE_BIT_RATE_NULL_CHOICE (31u)

#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_SERIAL_INTERFACE_DETECTION_MODE_AUTO_BIT_RATE_SET_CHOICE (0u)
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_SERIAL_INTERFACE_DETECTION_MODE_MANUAL_BIT_RATE_SET_CHOICE (1u)
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_SERIAL_INTERFACE_DETECTION_MODE_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_SERIAL_INTERFACE_DETECTION_MODE_ERROR_CHOICE (6u)
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_SERIAL_INTERFACE_DETECTION_MODE_NULL_CHOICE (7u)

#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_DIFF_SOURCE_AUTO_SELECT_CHOICE (0u)
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_DIFF_SOURCE_LORAN_COMMUNICATIONS_CHOICE (1u)
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_DIFF_SOURCE_MSK_BEACON_CHOICE (2u)
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_DIFF_SOURCE_FM_SUBCARRIER_CHOICE (3u)
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_DIFF_SOURCE_AIS_CHOICE (4u)
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_DIFF_SOURCE_OTHER_GROUND_BASED_RADIO_CHOICE (5u)
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_DIFF_SOURCE_SBAS_CHOICE (6u)
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_DIFF_SOURCE_OTHER_SATELLITE_CHOICE (7u)
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_DIFF_SOURCE_RESERVED_CHOICE (8u)
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_DIFF_SOURCE_ERROR_CHOICE (14u)
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_DIFF_SOURCE_NO_SELECTION_CHOICE (15u)

#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_DIFF_OPERATION_MODE_MANUAL_CHOICE (0u)
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_DIFF_OPERATION_MODE_AUTO_POWER_CHOICE (1u)
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_DIFF_OPERATION_MODE_AUTO_RANGE_CHOICE (2u)
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_DIFF_OPERATION_MODE_RESERVED_CHOICE (3u)
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_DIFF_OPERATION_MODE_ERROR_CHOICE (14u)
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_DIFF_OPERATION_MODE_NO_SELECTION_CHOICE (15u)

#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_SID_N_VLD_PS_FX_TT_IT_T_RNG0_T250_FR_VLD_PSTN_FX_CHOICE (255u)

#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_STATION_TYPE_GLONASS__CHOICE (1u)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_STATION_TYPE_RESERVED_CHOICE (13u)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_STATION_TYPE_ERROR_CHOICE (14u)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_STATION_TYPE_NULL_CHOICE (15u)

#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_DIFF_SIGNAL_BIT_RATE_4_CHOICE (0u)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_DIFF_SIGNAL_BIT_RATE_50BPS_CHOICE (1u)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_DIFF_SIGNAL_BIT_RATE_100BPS_CHOICE (2u)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_DIFF_SIGNAL_BIT_RATE_200BPS_CHOICE (3u)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_DIFF_SIGNAL_BIT_RATE_57600BPS__CHOICE (12u)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_DIFF_SIGNAL_BIT_RATE_11_CHOICE (13u)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_DIFF_SIGNAL_BIT_RATE_RESERVED_CHOICE (29u)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_DIFF_SIGNAL_BIT_RATE_ERROR_CHOICE (30u)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_DIFF_SIGNAL_BIT_RATE_NULL_CHOICE (31u)

#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_DIFF_SIGNAL_DETECTION_MODE_AUTO_BIT_RATE_SET_CHOICE (0u)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_DIFF_SIGNAL_DETECTION_MODE_MANUAL_BIT_RATE_SET_CHOICE (1u)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_DIFF_SIGNAL_DETECTION_MODE_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_DIFF_SIGNAL_DETECTION_MODE_ERROR_CHOICE (6u)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_DIFF_SIGNAL_DETECTION_MODE_NULL_CHOICE (7u)

#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_USED_AS_CORRECTION_SOURCE___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_USED_AS_CORRECTION_SOURCE___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_USED_AS_CORRECTION_SOURCE_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_USED_AS_CORRECTION_SOURCE___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_DIFF_SOURCE_AUTO_SELECT_CHOICE (0u)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_DIFF_SOURCE_LORAN_COMMUNICATIONS_CHOICE (1u)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_DIFF_SOURCE_MSK_BEACON_CHOICE (2u)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_DIFF_SOURCE_FM_SUBCARRIER_CHOICE (3u)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_DIFF_SOURCE_AIS_CHOICE (4u)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_DIFF_SOURCE_OTHER_GROUND_BASED_RADIO_CHOICE (5u)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_DIFF_SOURCE_SBAS_CHOICE (6u)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_DIFF_SOURCE_OTHER_SATELLITE_CHOICE (7u)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_DIFF_SOURCE_RESERVED_CHOICE (8u)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_DIFF_SOURCE_ERROR_CHOICE (14u)
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_DIFF_SOURCE_NO_SELECTION_CHOICE (15u)

#define NMEA2000_EXXO_GNSSDO_PS_SID_N_VLD_PS_FX_TT_IT_T_RNG0_T250_FR_VLD_PSTN_FX_CHOICE (255u)

#define NMEA2000_EXXO_GNSSDO_PS_SET_MODE_1_D_CHOICE (0u)
#define NMEA2000_EXXO_GNSSDO_PS_SET_MODE_2_D_CHOICE (1u)
#define NMEA2000_EXXO_GNSSDO_PS_SET_MODE_3_D_CHOICE (2u)
#define NMEA2000_EXXO_GNSSDO_PS_SET_MODE_AUTO_CHOICE (3u)
#define NMEA2000_EXXO_GNSSDO_PS_SET_MODE_RESERVED_CHOICE (4u)
#define NMEA2000_EXXO_GNSSDO_PS_SET_MODE_ERROR_CHOICE (6u)
#define NMEA2000_EXXO_GNSSDO_PS_SET_MODE_NULL_CHOICE (7u)

#define NMEA2000_EXXO_GNSSDO_PS_OP_MODE_1_D_CHOICE (0u)
#define NMEA2000_EXXO_GNSSDO_PS_OP_MODE_2_D_CHOICE (1u)
#define NMEA2000_EXXO_GNSSDO_PS_OP_MODE_3_D_CHOICE (2u)
#define NMEA2000_EXXO_GNSSDO_PS_OP_MODE_AUTO_CHOICE (3u)
#define NMEA2000_EXXO_GNSSDO_PS_OP_MODE_RESERVED_CHOICE (4u)
#define NMEA2000_EXXO_GNSSDO_PS_OP_MODE_ERROR_CHOICE (6u)
#define NMEA2000_EXXO_GNSSDO_PS_OP_MODE_NULL_CHOICE (7u)

#define NMEA2000_EXXO_GNSS_CTRL_STATUS_GNSS_MODE_1_D_CHOICE (0u)
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_GNSS_MODE_2_D_CHOICE (1u)
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_GNSS_MODE_3_D_CHOICE (2u)
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_GNSS_MODE_AUTO_CHOICE (3u)
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_GNSS_MODE_RESERVED_CHOICE (4u)
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_GNSS_MODE_ERROR_CHOICE (6u)
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_GNSS_MODE_NULL_CHOICE (7u)

#define NMEA2000_EXXO_GNSS_CTRL_STATUS_DGNSS_MODE_OFF_CHOICE (0u)
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_DGNSS_MODE_AUTO_CHOICE (1u)
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_DGNSS_MODE_RTCMSC104_PSEUDORANGE_CORRECTIONS_CHOICE (2u)
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_DGNSS_MODE_RTCA_SC159_NETWORK_CORRECTIONS_CHOICE (3u)
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_DGNSS_MODE_RTK_DIFFERENTIAL_CORRECTIONS_CHOICE (4u)
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_DGNSS_MODE_RESERVED_CHOICE (5u)
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_DGNSS_MODE_ERROR_CHOICE (6u)
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_DGNSS_MODE_NULL_CHOICE (7u)

#define NMEA2000_EXXO_GNSS_CTRL_STATUS_POS_VELOCITY_FILTER___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_POS_VELOCITY_FILTER___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_POS_VELOCITY_FILTER_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_POS_VELOCITY_FILTER___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_GNSS_CTRL_STATUS_USE_ANTENNA_ALTITUDE_FOR2_D_MODE___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_USE_ANTENNA_ALTITUDE_FOR2_D_MODE___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_USE_ANTENNA_ALTITUDE_FOR2_D_MODE_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_USE_ANTENNA_ALTITUDE_FOR2_D_MODE___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_GLONASS_ALMANAC_DATA_PRN_NOT_CHOICE (0u)
#define NMEA2000_EXXO_GLONASS_ALMANAC_DATA_PRN_GPS___CHOICE (1u)
#define NMEA2000_EXXO_GLONASS_ALMANAC_DATA_PRN_0_CHOICE (33u)
#define NMEA2000_EXXO_GLONASS_ALMANAC_DATA_PRN_SBAS_STLLT_BSD_AGMENTATION_SYSTEM65_CHOICE (64u)
#define NMEA2000_EXXO_GLONASS_ALMANAC_DATA_PRN_GLONASS_FR_GLONASS_STLLTS_AR_IDNTFD_BY_CHOICE (96u)

#define NMEA2000_EXXO_FLUID_LEVEL_FLUID_INSTANCE_INSTANCE_NUMBER_0_TO_15_CHOICE (15u)

#define NMEA2000_EXXO_FLUID_LEVEL_FLUID_TYPE_FUEL_CHOICE (0u)
#define NMEA2000_EXXO_FLUID_LEVEL_FLUID_TYPE_WASTE_CHOICE (2u)
#define NMEA2000_EXXO_FLUID_LEVEL_FLUID_TYPE_RESERVED__CHOICE (6u)
#define NMEA2000_EXXO_FLUID_LEVEL_FLUID_TYPE_RESERVED_CHOICE (13u)
#define NMEA2000_EXXO_FLUID_LEVEL_FLUID_TYPE_ERROR_CHOICE (14u)
#define NMEA2000_EXXO_FLUID_LEVEL_FLUID_TYPE_DATA_NOT_AVAILABLE_CHOICE (15u)

#define NMEA2000_EXXO_ENVIRONMENTAL_PARAMETERS_SEQUENCE_ID__N_VLD_PS_FX_TT_IT_T_RNG0_T250_FR_VLD_PSTN_FX_CHOICE (255u)

#define NMEA2000_EXXO_ENG_PARAMETERS_STATIC_ENG_INSTANCE_SINGLE_ENG_DUAL_ENGINE_PORT_CHOICE (0u)
#define NMEA2000_EXXO_ENG_PARAMETERS_STATIC_ENG_INSTANCE_DL_ENG_STR_BRD_T_STRN_STRBRD_N_INSTNC_N_WH_CHOICE (1u)
#define NMEA2000_EXXO_ENG_PARAMETERS_STATIC_ENG_INSTANCE_RESERVE_CHOICE (253u)
#define NMEA2000_EXXO_ENG_PARAMETERS_STATIC_ENG_INSTANCE_ERROR_CHOICE (254u)
#define NMEA2000_EXXO_ENG_PARAMETERS_STATIC_ENG_INSTANCE_NOT_AVAILABLE_CHOICE (255u)

#define NMEA2000_EXXO_ENG_PARAMETERS_RAPID_UPDATE_ENG_INSTANCE_SINGLE_ENG_DUAL_ENGINE_PORT_CHOICE (0u)
#define NMEA2000_EXXO_ENG_PARAMETERS_RAPID_UPDATE_ENG_INSTANCE_DL_ENG_STR_BRD_T_STRN_STRBRD_N_INSTNC_N_WH_CHOICE (1u)
#define NMEA2000_EXXO_ENG_PARAMETERS_RAPID_UPDATE_ENG_INSTANCE_RESERVE_CHOICE (253u)
#define NMEA2000_EXXO_ENG_PARAMETERS_RAPID_UPDATE_ENG_INSTANCE_ERROR_CHOICE (254u)
#define NMEA2000_EXXO_ENG_PARAMETERS_RAPID_UPDATE_ENG_INSTANCE_NOT_AVAILABLE_CHOICE (255u)

#define NMEA2000_EXXO_ENG_PARAMETERS_DYNAMIC_ENG_INSTANCE_SINGLE_ENG_DUAL_ENGINE_PORT_CHOICE (0u)
#define NMEA2000_EXXO_ENG_PARAMETERS_DYNAMIC_ENG_INSTANCE_DL_ENG_STR_BRD_T_STRN_STRBRD_N_INSTNC_N_WH_CHOICE (1u)
#define NMEA2000_EXXO_ENG_PARAMETERS_DYNAMIC_ENG_INSTANCE_RESERVE_CHOICE (253u)
#define NMEA2000_EXXO_ENG_PARAMETERS_DYNAMIC_ENG_INSTANCE_ERROR_CHOICE (254u)
#define NMEA2000_EXXO_ENG_PARAMETERS_DYNAMIC_ENG_INSTANCE_NOT_AVAILABLE_CHOICE (255u)

#define NMEA2000_EXXO_DISTANCE_LOG_MEASUREMENT_TIME_MIDNIGHT__TIME_IS_IN_UTC_CHOICE (0u)

#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_REPEAT_INDICATOR_DEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_REPEAT_INDICATOR_FIRST_RETRANSMISSION_CHOICE (1u)
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_REPEAT_INDICATOR_SECOND_RETRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_REPEAT_INDICATOR_FNL_R_TRNS_SITURM13711_FR_MR_INFRMTON_CHOICE (3u)

#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_RAI_MFLAG_RAIM_NOT_IN_USE_DEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_RAI_MFLAG_RAIM_IN_US_SITURM13711_FR_MR_INFRMTON_CHOICE (1u)

#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_TIME_STAMP_UTC_SECOND_WHEN_REPORT_WAS_GENERATED_CHOICE (0u)
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_TIME_STAMP_TIME_STAMP_NOT_AVAILABLE_CHOICE (60u)
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_TIME_STAMP_POSING_SYSTEM_IS_IN_MANUAL_INPUT_MODE_CHOICE (61u)
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_TIME_STAMP_ELCTRNC_PS_FXNG_SYSTM_OPRTS_IN_EST_MDE_CHOICE (62u)
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_TIME_STAMP_PSNG_SYSTM_IS_INPRTV_SITURM13711_FR_MR_CHOICE (63u)

#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_AIS_TRANSCEIVER_INFORMATION_CHANNEL_A_VDL_RECEPTION_CHOICE (0u)
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_AIS_TRANSCEIVER_INFORMATION_CHANNEL_B_VDL_RECEPTION_CHOICE (1u)
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_AIS_TRANSCEIVER_INFORMATION_CHANNEL_A_VDL_TRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_AIS_TRANSCEIVER_INFORMATION_CHANNEL_B_VDL_TRANSMISSION_CHOICE (3u)
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_AIS_TRANSCEIVER_INFORMATION_OWN_INFORMATION_NOT_BROADCAST_CHOICE (4u)
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_AIS_TRANSCEIVER_INFORMATION_RESERVED_CHOICE (5u)

#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_NAVIGATIONAL_STATUS_UNDER_WAY_USING_ENGINE_CHOICE (0u)
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_NAVIGATIONAL_STATUS_AT_ANCHOR_CHOICE (1u)
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_NAVIGATIONAL_STATUS_NOT_UNDER_COMMAND_CHOICE (2u)
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_NAVIGATIONAL_STATUS_RESTRICTED_MANOEUVRABILITY_CHOICE (3u)
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_NAVIGATIONAL_STATUS_CONSTRAINED_BY_HER_DRAUGHT_CHOICE (4u)
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_NAVIGATIONAL_STATUS_MOORED_CHOICE (5u)
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_NAVIGATIONAL_STATUS_AGROUND_CHOICE (6u)
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_NAVIGATIONAL_STATUS_ENGAGED_IN_FISHING_CHOICE (7u)
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_NAVIGATIONAL_STATUS_UNDER_WAY_SAILING_CHOICE (8u)
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_NAVIGATIONAL_STATUS_RSRVD_FR_FTR_AMNDMNT_OF_NVGTNL_STTS_FR_S_CHOICE (10u)
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_NAVIGATIONAL_STATUS_RESERVED_FOR_FUTURE_USE_CHOICE (14u)
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_NAVIGATIONAL_STATUS_NT_DFND_SITURM13711_FR_MR_INFRMATION_CHOICE (15u)

#define NMEA2000_EXXO_AIS_BINARY_BROADCAST_MSG_REPEAT_INDICATOR_DEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AIS_BINARY_BROADCAST_MSG_REPEAT_INDICATOR_FIRST_RETRANSMISSION_CHOICE (1u)
#define NMEA2000_EXXO_AIS_BINARY_BROADCAST_MSG_REPEAT_INDICATOR_SECOND_RETRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AIS_BINARY_BROADCAST_MSG_REPEAT_INDICATOR_FNL_R_TRNS_SITURM13711_FR_MR_INFRMTON_CHOICE (3u)

#define NMEA2000_EXXO_AIS_BINARY_BROADCAST_MSG_AIS_TRANSCEIVER_INFORMATION_CHANNEL_A_VDL_RECEPTION_CHOICE (0u)
#define NMEA2000_EXXO_AIS_BINARY_BROADCAST_MSG_AIS_TRANSCEIVER_INFORMATION_CHANNEL_B_VDL_RECEPTION_CHOICE (1u)
#define NMEA2000_EXXO_AIS_BINARY_BROADCAST_MSG_AIS_TRANSCEIVER_INFORMATION_CHANNEL_A_VDL_TRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AIS_BINARY_BROADCAST_MSG_AIS_TRANSCEIVER_INFORMATION_CHANNEL_B_VDL_TRANSMISSION_CHOICE (3u)
#define NMEA2000_EXXO_AIS_BINARY_BROADCAST_MSG_AIS_TRANSCEIVER_INFORMATION_OWN_INFORMATION_NOT_BROADCAST_CHOICE (4u)
#define NMEA2000_EXXO_AIS_BINARY_BROADCAST_MSG_AIS_TRANSCEIVER_INFORMATION_RESERVED_CHOICE (5u)

#define NMEA2000_EXXO_AIS_ASSIGNMENT_MODE_CMD_REPEAT_INDICATOR_DEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AIS_ASSIGNMENT_MODE_CMD_REPEAT_INDICATOR_FIRST_RETRANSMISSION_CHOICE (1u)
#define NMEA2000_EXXO_AIS_ASSIGNMENT_MODE_CMD_REPEAT_INDICATOR_SECOND_RETRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AIS_ASSIGNMENT_MODE_CMD_REPEAT_INDICATOR_FNL_R_TRNS_SITURM13711_FR_MR_INFRMTON_CHOICE (3u)

#define NMEA2000_EXXO_AIS_ASSIGNMENT_MODE_CMD_AIS_TRANSCEIVER_INFORMATION_CHANNEL_A_VDL_RECEPTION_CHOICE (0u)
#define NMEA2000_EXXO_AIS_ASSIGNMENT_MODE_CMD_AIS_TRANSCEIVER_INFORMATION_CHANNEL_B_VDL_RECEPTION_CHOICE (1u)
#define NMEA2000_EXXO_AIS_ASSIGNMENT_MODE_CMD_AIS_TRANSCEIVER_INFORMATION_CHANNEL_A_VDL_TRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AIS_ASSIGNMENT_MODE_CMD_AIS_TRANSCEIVER_INFORMATION_CHANNEL_B_VDL_TRANSMISSION_CHOICE (3u)
#define NMEA2000_EXXO_AIS_ASSIGNMENT_MODE_CMD_AIS_TRANSCEIVER_INFORMATION_OWN_INFORMATION_NOT_BROADCAST_CHOICE (4u)
#define NMEA2000_EXXO_AIS_ASSIGNMENT_MODE_CMD_AIS_TRANSCEIVER_INFORMATION_RESERVED_CHOICE (5u)

#define NMEA2000_EXXO_ACKM_CONTROL_BYTE_ACK_CHOICE (0u)
#define NMEA2000_EXXO_ACKM_CONTROL_BYTE_NACK_CHOICE (1u)
#define NMEA2000_EXXO_ACKM_CONTROL_BYTE_ACCESS_DENIED_CHOICE (2u)
#define NMEA2000_EXXO_ACKM_CONTROL_BYTE_CANNOT_RESPOND_CHOICE (3u)

#define NMEA2000_EXXO_DIRECTION_DATA_DATA_MODE_AUTONOMOUS_MODE_CHOICE (0u)
#define NMEA2000_EXXO_DIRECTION_DATA_DATA_MODE_DIFFERENTIAL__ENHANCED_MODE_CHOICE (1u)
#define NMEA2000_EXXO_DIRECTION_DATA_DATA_MODE_ESTIMATED_MODE_CHOICE (2u)
#define NMEA2000_EXXO_DIRECTION_DATA_DATA_MODE_SIMULATOR_MODE_CHOICE (3u)
#define NMEA2000_EXXO_DIRECTION_DATA_DATA_MODE_MANUAL_MODE_CHOICE (4u)
#define NMEA2000_EXXO_DIRECTION_DATA_DATA_MODE_ERROR_CHOICE (14u)
#define NMEA2000_EXXO_DIRECTION_DATA_DATA_MODE_DATA_NOT_AVAILABLE_CHOICE (15u)

#define NMEA2000_EXXO_DIRECTION_DATA_SET_COG_HEADING_REF_TRUE_CHOICE (0u)
#define NMEA2000_EXXO_DIRECTION_DATA_SET_COG_HEADING_REF_MAGNETIC_CHOICE (1u)
#define NMEA2000_EXXO_DIRECTION_DATA_SET_COG_HEADING_REF_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_DIRECTION_DATA_SET_COG_HEADING_REF_NULL_CHOICE (3u)

#define NMEA2000_EXXO_DIRECTION_DATA_SID_N_VLD_PS_FX_TT_IT_T_RNG0_T250_FR_VLD_PSTN_FX_CHOICE (255u)

#define NMEA2000_EXXO_DGNSS_CORRECTIONS_SEQUENCE_ID__N_VLD_PS_FX_TT_IT_T_RNG0_T250_FR_VLD_PSTN_FX_CHOICE (255u)

#define NMEA2000_EXXO_DGNSS_CORRECTIONS_REFERENCE_STATION_TYPE_GLONASS__CHOICE (1u)
#define NMEA2000_EXXO_DGNSS_CORRECTIONS_REFERENCE_STATION_TYPE_RESERVED_CHOICE (13u)
#define NMEA2000_EXXO_DGNSS_CORRECTIONS_REFERENCE_STATION_TYPE_ERROR_CHOICE (14u)
#define NMEA2000_EXXO_DGNSS_CORRECTIONS_REFERENCE_STATION_TYPE_NULL_CHOICE (15u)

#define NMEA2000_EXXO_DGNSS_CORRECTIONS_STATION_HEALTH_NOT_WORKING_CHOICE (0u)
#define NMEA2000_EXXO_DGNSS_CORRECTIONS_STATION_HEALTH_UNMONITORED_CHOICE (1u)
#define NMEA2000_EXXO_DGNSS_CORRECTIONS_STATION_HEALTH_HEALTHY___OPERATIONAL_CHOICE (2u)
#define NMEA2000_EXXO_DGNSS_CORRECTIONS_STATION_HEALTH_HEALTHY___IN_TEST_MODE_CHOICE (3u)
#define NMEA2000_EXXO_DGNSS_CORRECTIONS_STATION_HEALTH_IN_TEST_MODE_DONOTUSE0X05_CHOICE (4u)
#define NMEA2000_EXXO_DGNSS_CORRECTIONS_STATION_HEALTH_RESERVED_CHOICE (21u)

#define NMEA2000_EXXO_DGNSS_CORRECTIONS_SATELLITE_ID_NOT_CHOICE (0u)
#define NMEA2000_EXXO_DGNSS_CORRECTIONS_SATELLITE_ID_GPS___CHOICE (1u)
#define NMEA2000_EXXO_DGNSS_CORRECTIONS_SATELLITE_ID_0_CHOICE (33u)
#define NMEA2000_EXXO_DGNSS_CORRECTIONS_SATELLITE_ID_SBAS_STLLT_BSD_AGMENTATION_SYSTEM65_CHOICE (64u)
#define NMEA2000_EXXO_DGNSS_CORRECTIONS_SATELLITE_ID_GLONASS_FR_GLONASS_STLLTS_AR_IDNTFD_BY_CHOICE (96u)

#define NMEA2000_EXXO_CURRENT_STATION_DATA_MODE_AUTONOMOUS_MODE_CHOICE (0u)
#define NMEA2000_EXXO_CURRENT_STATION_DATA_MODE_DIFFERENTIAL__ENHANCED_MODE_CHOICE (1u)
#define NMEA2000_EXXO_CURRENT_STATION_DATA_MODE_ESTIMATED_MODE_CHOICE (2u)
#define NMEA2000_EXXO_CURRENT_STATION_DATA_MODE_SIMULATOR_MODE_CHOICE (3u)
#define NMEA2000_EXXO_CURRENT_STATION_DATA_MODE_MANUAL_MODE_CHOICE (4u)
#define NMEA2000_EXXO_CURRENT_STATION_DATA_MODE_ERROR_CHOICE (14u)
#define NMEA2000_EXXO_CURRENT_STATION_DATA_MODE_DATA_NOT_AVAILABLE_CHOICE (15u)

#define NMEA2000_EXXO_CURRENT_STATION_DATA_STATE_FLOOD_CHOICE (0u)
#define NMEA2000_EXXO_CURRENT_STATION_DATA_STATE_SLACK_CHOICE (1u)
#define NMEA2000_EXXO_CURRENT_STATION_DATA_STATE_EBB_CHOICE (10u)
#define NMEA2000_EXXO_CURRENT_STATION_DATA_STATE_RESERVED_CHOICE (101u)
#define NMEA2000_EXXO_CURRENT_STATION_DATA_STATE_ERROR_CHOICE (110u)
#define NMEA2000_EXXO_CURRENT_STATION_DATA_STATE_UNAVAILABLE__UNKNOWN_CHOICE (111u)

#define NMEA2000_EXXO_CURRENT_STATION_DATA_MEASUREMENT_TIME_MIDNIGHT__TIME_IS_IN_UTC_CHOICE (0u)

#define NMEA2000_EXXO_CROSS_TRACK_ERROR_SID_N_VLD_PS_FX_TT_IT_T_RNG0_T250_FR_VLD_PSTN_FX_CHOICE (255u)

#define NMEA2000_EXXO_CROSS_TRACK_ERROR_XTE_MODE_AUTONOMOUS_MODE_CHOICE (0u)
#define NMEA2000_EXXO_CROSS_TRACK_ERROR_XTE_MODE_DIFFERENTIAL__ENHANCED_MODE_CHOICE (1u)
#define NMEA2000_EXXO_CROSS_TRACK_ERROR_XTE_MODE_ESTIMATED_MODE_CHOICE (2u)
#define NMEA2000_EXXO_CROSS_TRACK_ERROR_XTE_MODE_SIMULATOR_MODE_CHOICE (3u)
#define NMEA2000_EXXO_CROSS_TRACK_ERROR_XTE_MODE_MANUAL_MODE_CHOICE (4u)
#define NMEA2000_EXXO_CROSS_TRACK_ERROR_XTE_MODE_ERROR_CHOICE (14u)
#define NMEA2000_EXXO_CROSS_TRACK_ERROR_XTE_MODE_DATA_NOT_AVAILABLE_CHOICE (15u)

#define NMEA2000_EXXO_CROSS_TRACK_ERROR_NAVIGATION_TERMINATED___NO__OFF__DISABLED__RESET___0___CHOICE (0u)
#define NMEA2000_EXXO_CROSS_TRACK_ERROR_NAVIGATION_TERMINATED___YES__ON__ENABLED__SET___1___CHOICE (1u)
#define NMEA2000_EXXO_CROSS_TRACK_ERROR_NAVIGATION_TERMINATED_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_CROSS_TRACK_ERROR_NAVIGATION_TERMINATED___UNAVAILABLE__UNKNOWN__CHOICE (3u)

#define NMEA2000_EXXO_COGSOG_RAPID_UPDATE_SID_N_VLD_PS_FX_TT_IT_T_RNG0_T250_FR_VLD_PSTN_FX_CHOICE (255u)

#define NMEA2000_EXXO_COGSOG_RAPID_UPDATE_COG_REFERENCE_TRUE_CHOICE (0u)
#define NMEA2000_EXXO_COGSOG_RAPID_UPDATE_COG_REFERENCE_MAGNETIC_CHOICE (1u)
#define NMEA2000_EXXO_COGSOG_RAPID_UPDATE_COG_REFERENCE_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_COGSOG_RAPID_UPDATE_COG_REFERENCE_NULL_CHOICE (3u)

#define NMEA2000_EXXO_AIS_ADDRESSED_SAFETY_RELATED_MSG_REPEAT_INDICATOR_DEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AIS_ADDRESSED_SAFETY_RELATED_MSG_REPEAT_INDICATOR_FIRST_RETRANSMISSION_CHOICE (1u)
#define NMEA2000_EXXO_AIS_ADDRESSED_SAFETY_RELATED_MSG_REPEAT_INDICATOR_SECOND_RETRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AIS_ADDRESSED_SAFETY_RELATED_MSG_REPEAT_INDICATOR_FNL_R_TRNS_SITURM13711_FR_MR_INFRMTON_CHOICE (3u)

#define NMEA2000_EXXO_AIS_ADDRESSED_SAFETY_RELATED_MSG_AIS_TRANSCEIVER_INFORMATION_CHANNEL_A_VDL_RECEPTION_CHOICE (0u)
#define NMEA2000_EXXO_AIS_ADDRESSED_SAFETY_RELATED_MSG_AIS_TRANSCEIVER_INFORMATION_CHANNEL_B_VDL_RECEPTION_CHOICE (1u)
#define NMEA2000_EXXO_AIS_ADDRESSED_SAFETY_RELATED_MSG_AIS_TRANSCEIVER_INFORMATION_CHANNEL_A_VDL_TRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AIS_ADDRESSED_SAFETY_RELATED_MSG_AIS_TRANSCEIVER_INFORMATION_CHANNEL_B_VDL_TRANSMISSION_CHOICE (3u)
#define NMEA2000_EXXO_AIS_ADDRESSED_SAFETY_RELATED_MSG_AIS_TRANSCEIVER_INFORMATION_OWN_INFORMATION_NOT_BROADCAST_CHOICE (4u)
#define NMEA2000_EXXO_AIS_ADDRESSED_SAFETY_RELATED_MSG_AIS_TRANSCEIVER_INFORMATION_RESERVED_CHOICE (5u)

#define NMEA2000_EXXO_AIS_ADDRESSED_BINARY_MSG_REPEAT_INDICATOR_DEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AIS_ADDRESSED_BINARY_MSG_REPEAT_INDICATOR_FIRST_RETRANSMISSION_CHOICE (1u)
#define NMEA2000_EXXO_AIS_ADDRESSED_BINARY_MSG_REPEAT_INDICATOR_SECOND_RETRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AIS_ADDRESSED_BINARY_MSG_REPEAT_INDICATOR_FNL_R_TRNS_SITURM13711_FR_MR_INFRMTON_CHOICE (3u)

#define NMEA2000_EXXO_AIS_ADDRESSED_BINARY_MSG_AIS_TRANSCEIVER_INFORMATION_CHANNEL_A_VDL_RECEPTION_CHOICE (0u)
#define NMEA2000_EXXO_AIS_ADDRESSED_BINARY_MSG_AIS_TRANSCEIVER_INFORMATION_CHANNEL_B_VDL_RECEPTION_CHOICE (1u)
#define NMEA2000_EXXO_AIS_ADDRESSED_BINARY_MSG_AIS_TRANSCEIVER_INFORMATION_CHANNEL_A_VDL_TRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AIS_ADDRESSED_BINARY_MSG_AIS_TRANSCEIVER_INFORMATION_CHANNEL_B_VDL_TRANSMISSION_CHOICE (3u)
#define NMEA2000_EXXO_AIS_ADDRESSED_BINARY_MSG_AIS_TRANSCEIVER_INFORMATION_OWN_INFORMATION_NOT_BROADCAST_CHOICE (4u)
#define NMEA2000_EXXO_AIS_ADDRESSED_BINARY_MSG_AIS_TRANSCEIVER_INFORMATION_RESERVED_CHOICE (5u)

#define NMEA2000_EXXO_AIS_ACKNOWLEDGE_REPEAT_INDICATOR_DEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AIS_ACKNOWLEDGE_REPEAT_INDICATOR_FIRST_RETRANSMISSION_CHOICE (1u)
#define NMEA2000_EXXO_AIS_ACKNOWLEDGE_REPEAT_INDICATOR_SECOND_RETRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AIS_ACKNOWLEDGE_REPEAT_INDICATOR_FNL_R_TRNS_SITURM13711_FR_MR_INFRMTON_CHOICE (3u)

#define NMEA2000_EXXO_AIS_ACKNOWLEDGE_AIS_TRANSCEIVER_INFORMATION_CHANNEL_A_VDL_RECEPTION_CHOICE (0u)
#define NMEA2000_EXXO_AIS_ACKNOWLEDGE_AIS_TRANSCEIVER_INFORMATION_CHANNEL_B_VDL_RECEPTION_CHOICE (1u)
#define NMEA2000_EXXO_AIS_ACKNOWLEDGE_AIS_TRANSCEIVER_INFORMATION_CHANNEL_A_VDL_TRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AIS_ACKNOWLEDGE_AIS_TRANSCEIVER_INFORMATION_CHANNEL_B_VDL_TRANSMISSION_CHOICE (3u)
#define NMEA2000_EXXO_AIS_ACKNOWLEDGE_AIS_TRANSCEIVER_INFORMATION_OWN_INFORMATION_NOT_BROADCAST_CHOICE (4u)
#define NMEA2000_EXXO_AIS_ACKNOWLEDGE_AIS_TRANSCEIVER_INFORMATION_RESERVED_CHOICE (5u)

#define NMEA2000_EXXO_AC_INPUT_STATUS_LINE_LINE1_CHOICE (0u)
#define NMEA2000_EXXO_AC_INPUT_STATUS_LINE_LINE2_CHOICE (1u)
#define NMEA2000_EXXO_AC_INPUT_STATUS_LINE_LINE3_CHOICE (2u)
#define NMEA2000_EXXO_AC_INPUT_STATUS_LINE_RESERVED_CHOICE (3u)

#define NMEA2000_EXXO_AC_INPUT_STATUS_ACCEPTABILITY_BAD_LEVEL_CHOICE (0u)
#define NMEA2000_EXXO_AC_INPUT_STATUS_ACCEPTABILITY_BAD_FREQUENCY_CHOICE (1u)
#define NMEA2000_EXXO_AC_INPUT_STATUS_ACCEPTABILITY_BEING_QUALIFIED_CHOICE (2u)
#define NMEA2000_EXXO_AC_INPUT_STATUS_ACCEPTABILITY_GOOD_CHOICE (3u)

#define NMEA2000_EXXO_AC_OUTPUT_STATUS_LINE_LINE1_CHOICE (0u)
#define NMEA2000_EXXO_AC_OUTPUT_STATUS_LINE_LINE2_CHOICE (1u)
#define NMEA2000_EXXO_AC_OUTPUT_STATUS_LINE_LINE3_CHOICE (2u)
#define NMEA2000_EXXO_AC_OUTPUT_STATUS_LINE_RESERVED_CHOICE (3u)

#define NMEA2000_EXXO_AC_OUTPUT_STATUS_WAVEFORM_SINE_WAVE_CHOICE (0u)
#define NMEA2000_EXXO_AC_OUTPUT_STATUS_WAVEFORM_MODIFIED_SINE_WAVE_CHOICE (1u)
#define NMEA2000_EXXO_AC_OUTPUT_STATUS_WAVEFORM_RESERVED_2_CHOICE (2u)
#define NMEA2000_EXXO_AC_OUTPUT_STATUS_WAVEFORM_RESERVED_3_CHOICE (3u)
#define NMEA2000_EXXO_AC_OUTPUT_STATUS_WAVEFORM_RESERVED_4_CHOICE (4u)
#define NMEA2000_EXXO_AC_OUTPUT_STATUS_WAVEFORM_RESERVED_5_CHOICE (5u)
#define NMEA2000_EXXO_AC_OUTPUT_STATUS_WAVEFORM_ERROR_CHOICE (6u)
#define NMEA2000_EXXO_AC_OUTPUT_STATUS_WAVEFORM_DATA_NOT_AVAILABLE_CHOICE (7u)

#define NMEA2000_EXXO_DC_DETAILED_STATUS_DC_TYPE_BATTERY_CHOICE (0u)
#define NMEA2000_EXXO_DC_DETAILED_STATUS_DC_TYPE_ALTERNATOR_CHOICE (1u)
#define NMEA2000_EXXO_DC_DETAILED_STATUS_DC_TYPE_CONVERTOR_CHOICE (2u)
#define NMEA2000_EXXO_DC_DETAILED_STATUS_DC_TYPE_SOLAR_CELL_CHOICE (3u)
#define NMEA2000_EXXO_DC_DETAILED_STATUS_DC_TYPE_WIND_GENERATOR_CHOICE (4u)
#define NMEA2000_EXXO_DC_DETAILED_STATUS_DC_TYPE_RESERVED_CHOICE (5u)

#define NMEA2000_EXXO_CHARGER_STATUS_OPERATING_STATE_NOT_CHARGING_CHOICE (0u)
#define NMEA2000_EXXO_CHARGER_STATUS_OPERATING_STATE_BULK_CHOICE (1u)
#define NMEA2000_EXXO_CHARGER_STATUS_OPERATING_STATE_ABSORPTION_CHOICE (2u)
#define NMEA2000_EXXO_CHARGER_STATUS_OPERATING_STATE_OVERCHARGE_CHOICE (3u)
#define NMEA2000_EXXO_CHARGER_STATUS_OPERATING_STATE_EQUALIZE_CHOICE (4u)
#define NMEA2000_EXXO_CHARGER_STATUS_OPERATING_STATE_FLOAT_CHOICE (5u)
#define NMEA2000_EXXO_CHARGER_STATUS_OPERATING_STATE_NO_FLOAT_CHOICE (6u)
#define NMEA2000_EXXO_CHARGER_STATUS_OPERATING_STATE_CONSTANT_VI_CHOICE (7u)
#define NMEA2000_EXXO_CHARGER_STATUS_OPERATING_STATE_DISABLED_CHOICE (8u)
#define NMEA2000_EXXO_CHARGER_STATUS_OPERATING_STATE_FAULT_9_CHOICE (9u)
#define NMEA2000_EXXO_CHARGER_STATUS_OPERATING_STATE_FAULT_10_CHOICE (10u)
#define NMEA2000_EXXO_CHARGER_STATUS_OPERATING_STATE_FAULT_11_CHOICE (11u)
#define NMEA2000_EXXO_CHARGER_STATUS_OPERATING_STATE_FAULT_12_CHOICE (12u)
#define NMEA2000_EXXO_CHARGER_STATUS_OPERATING_STATE_RESERVED_CHOICE (13u)
#define NMEA2000_EXXO_CHARGER_STATUS_OPERATING_STATE_ERROR_CHOICE (14u)
#define NMEA2000_EXXO_CHARGER_STATUS_OPERATING_STATE_DATA_NOT_AVAILABLE_CHOICE (15u)

#define NMEA2000_EXXO_CHARGER_STATUS_CHARGE_MODE_STAND_ALONE_CHOICE (0u)
#define NMEA2000_EXXO_CHARGER_STATUS_CHARGE_MODE_PRIMARY_CHOICE (1u)
#define NMEA2000_EXXO_CHARGER_STATUS_CHARGE_MODE_SECONDARY_CHOICE (2u)
#define NMEA2000_EXXO_CHARGER_STATUS_CHARGE_MODE_ECHO_CHOICE (3u)
#define NMEA2000_EXXO_CHARGER_STATUS_CHARGE_MODE_RESERVED_CHOICE (4u)

#define NMEA2000_EXXO_CHARGER_STATUS_CHARGER_ENABLE_DISABLE_NO_OFF_DISABLED_RESET0_CHOICE (0u)
#define NMEA2000_EXXO_CHARGER_STATUS_CHARGER_ENABLE_DISABLE_YES_ON_ENABLED_SET1_CHOICE (1u)
#define NMEA2000_EXXO_CHARGER_STATUS_CHARGER_ENABLE_DISABLE_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_CHARGER_STATUS_CHARGER_ENABLE_DISABLE_UNAVAILABLE_UNKNOWN_CHOICE (3u)

#define NMEA2000_EXXO_CHARGER_STATUS_EQUALIZATION_PENDING_NO_OFF_DISABLED_RESET0_CHOICE (0u)
#define NMEA2000_EXXO_CHARGER_STATUS_EQUALIZATION_PENDING_YES_ON_ENABLED_SET1_CHOICE (1u)
#define NMEA2000_EXXO_CHARGER_STATUS_EQUALIZATION_PENDING_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_CHARGER_STATUS_EQUALIZATION_PENDING_UNAVAILABLE_UNKNOWN_CHOICE (3u)

#define NMEA2000_EXXO_INVERTER_STATUS_OPERATING_STATE_INVERT_CHOICE (0u)
#define NMEA2000_EXXO_INVERTER_STATUS_OPERATING_STATE_AC_PASSTHRU_CHOICE (1u)
#define NMEA2000_EXXO_INVERTER_STATUS_OPERATING_STATE_LOAD_SENSE_CHOICE (2u)
#define NMEA2000_EXXO_INVERTER_STATUS_OPERATING_STATE_FAULT_CHOICE (3u)
#define NMEA2000_EXXO_INVERTER_STATUS_OPERATING_STATE_DISABLED_CHOICE (4u)
#define NMEA2000_EXXO_INVERTER_STATUS_OPERATING_STATE_RESERVED_CHOICE (5u)

#define NMEA2000_EXXO_INVERTER_STATUS_INVERTER_ENABLE_DISABLE_NO_OFF_DISABLED_RESET0_CHOICE (0u)
#define NMEA2000_EXXO_INVERTER_STATUS_INVERTER_ENABLE_DISABLE_YES_ON_ENABLED_SET1_CHOICE (1u)
#define NMEA2000_EXXO_INVERTER_STATUS_INVERTER_ENABLE_DISABLE_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_INVERTER_STATUS_INVERTER_ENABLE_DISABLE_UNAVAILABLE_UNKNOWN_CHOICE (3u)

#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_CHARGER_ENABLE_DISABLE_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_CHARGER_ENABLE_DISABLE_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_CHARGER_ENABLE_DISABLE_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_CHARGER_ENABLE_DISABLE_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_CHARGING_ALGORITHM_TRICKLE_CHOICE (0u)
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_CHARGING_ALGORITHM_CVCC_CONSTANT_VOLTAGE_CONSTANT_CURRENT_CHOICE (1u)
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_CHARGING_ALGORITHM_2_STAGE_NO_FLOAT_CHOICE (2u)
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_CHARGING_ALGORITHM_3_STAGE_CHOICE (3u)
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_CHARGING_ALGORITHM_RESERVED_CHOICE (4u)

#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_CHARGER_MODE_STANDALONE_CHOICE (0u)
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_CHARGER_MODE_PRIMARY_CHOICE (1u)
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_CHARGER_MODE_SECONDARY_CHOICE (2u)
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_CHARGER_MODE_ECHO_CHOICE (3u)
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_CHARGER_MODE_RESERVED_CHOICE (4u)

#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_ESTIMATED_BATTERY_TEMP_WHEN_NO_SENSOR_COLD_CHOICE (0u)
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_ESTIMATED_BATTERY_TEMP_WHEN_NO_SENSOR_WARM_CHOICE (1u)
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_ESTIMATED_BATTERY_TEMP_WHEN_NO_SENSOR_HOT_CHOICE (2u)
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_ESTIMATED_BATTERY_TEMP_WHEN_NO_SENSOR_RESERVED_CHOICE (3u)

#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_EQUALIZE_ONE_TIME_ENABLE_DISABLE_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_EQUALIZE_ONE_TIME_ENABLE_DISABLE_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_EQUALIZE_ONE_TIME_ENABLE_DISABLE_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_EQUALIZE_ONE_TIME_ENABLE_DISABLE_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_OVER_CHARGE_ENABLE_DISABLE_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_OVER_CHARGE_ENABLE_DISABLE_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_OVER_CHARGE_ENABLE_DISABLE_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_OVER_CHARGE_ENABLE_DISABLE_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_INVERTER_CONFIGURATION_STATUS_INVERTER_ENABLE_DISABLE_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_INVERTER_CONFIGURATION_STATUS_INVERTER_ENABLE_DISABLE_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_INVERTER_CONFIGURATION_STATUS_INVERTER_ENABLE_DISABLE_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_INVERTER_CONFIGURATION_STATUS_INVERTER_ENABLE_DISABLE_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_INVERTER_CONFIGURATION_STATUS_INVERTER_MODE_STANDALONE_CHOICE (0u)
#define NMEA2000_EXXO_INVERTER_CONFIGURATION_STATUS_INVERTER_MODE_SERIES_MASTER_CHOICE (1u)
#define NMEA2000_EXXO_INVERTER_CONFIGURATION_STATUS_INVERTER_MODE_SERIES_SLAVE_CHOICE (2u)
#define NMEA2000_EXXO_INVERTER_CONFIGURATION_STATUS_INVERTER_MODE_PARALLEL_MASTER_CHOICE (3u)
#define NMEA2000_EXXO_INVERTER_CONFIGURATION_STATUS_INVERTER_MODE_PARALLEL_SLAVE_CHOICE (4u)
#define NMEA2000_EXXO_INVERTER_CONFIGURATION_STATUS_INVERTER_MODE_RESERVED_CHOICE (5u)

#define NMEA2000_EXXO_INVERTER_CONFIGURATION_STATUS_LOAD_SENSE_ENABLE_DISABLE_TURN_OFF_DISABLE_RESET_MAKE0_CHOICE (0u)
#define NMEA2000_EXXO_INVERTER_CONFIGURATION_STATUS_LOAD_SENSE_ENABLE_DISABLE_TURN_ON_ENABLE_SET_MAKE1_CHOICE (1u)
#define NMEA2000_EXXO_INVERTER_CONFIGURATION_STATUS_LOAD_SENSE_ENABLE_DISABLE_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_INVERTER_CONFIGURATION_STATUS_LOAD_SENSE_ENABLE_DISABLE_NO_ACTION_CHOICE (3u)

#define NMEA2000_EXXO_AGS_CONFIGURATION_STATUS_AGS_MODE_OFF_CHOICE (0u)
#define NMEA2000_EXXO_AGS_CONFIGURATION_STATUS_AGS_MODE_ON_CHOICE (1u)
#define NMEA2000_EXXO_AGS_CONFIGURATION_STATUS_AGS_MODE_AUTOMATIC_CHOICE (2u)
#define NMEA2000_EXXO_AGS_CONFIGURATION_STATUS_AGS_MODE_RESERVED_CHOICE (3u)

#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_BATTERY_TYPE_FLOODED_CHOICE (0u)
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_BATTERY_TYPE_GEL_CHOICE (1u)
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_BATTERY_TYPE_AGM_CHOICE (2u)
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_BATTERY_TYPE_RESERVED_CHOICE (3u)

#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_SUPPORT_EQUALIZATION_NO_OFF_DISABLED_RESET0_CHOICE (0u)
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_SUPPORT_EQUALIZATION_YES_ON_ENABLED_SET1_CHOICE (1u)
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_SUPPORT_EQUALIZATION_ERROR_CHOICE (2u)
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_SUPPORT_EQUALIZATION_UNAVAILABLE_UNKNOWN_CHOICE (3u)

#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_NOMINAL_VOLTAGE_6_VOLTS_CHOICE (0u)
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_NOMINAL_VOLTAGE_12_VOLTS_CHOICE (1u)
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_NOMINAL_VOLTAGE_24_VOLTS_CHOICE (2u)
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_NOMINAL_VOLTAGE_32_VOLTS_CHOICE (3u)
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_NOMINAL_VOLTAGE_36_VOLTS_CHOICE (4u)
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_NOMINAL_VOLTAGE_42_VOLTS_CHOICE (5u)
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_NOMINAL_VOLTAGE_48_VOLTS_CHOICE (6u)
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_NOMINAL_VOLTAGE_RESERVED_CHOICE (7u)

#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_BATTERY_CHEMISTRY_LEAD_ACID_CHOICE (0u)
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_BATTERY_CHEMISTRY_LI_ION_CHOICE (1u)
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_BATTERY_CHEMISTRY_NI_CAD_CHOICE (2u)
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_BATTERY_CHEMISTRY_ZN_O_CHOICE (3u)
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_BATTERY_CHEMISTRY_NI_MH_CHOICE (4u)
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_BATTERY_CHEMISTRY_RESERVED_CHOICE (5u)

#define NMEA2000_EXXO_AGS_STATUS_AGS_OPERATING_STATE_QUIET_TIME_CHOICE (0u)
#define NMEA2000_EXXO_AGS_STATUS_AGS_OPERATING_STATE_AUTO_ON_CHOICE (1u)
#define NMEA2000_EXXO_AGS_STATUS_AGS_OPERATING_STATE_AUTO_OFF_CHOICE (2u)
#define NMEA2000_EXXO_AGS_STATUS_AGS_OPERATING_STATE_MANUAL_ON_CHOICE (3u)
#define NMEA2000_EXXO_AGS_STATUS_AGS_OPERATING_STATE_MANUAL_OFF_CHOICE (4u)
#define NMEA2000_EXXO_AGS_STATUS_AGS_OPERATING_STATE_GENERATOR_SHUTDOWN_CHOICE (5u)
#define NMEA2000_EXXO_AGS_STATUS_AGS_OPERATING_STATE_EXTERNAL_SHUTDOWN_CHOICE (6u)
#define NMEA2000_EXXO_AGS_STATUS_AGS_OPERATING_STATE_FAULT_CHOICE (7u)
#define NMEA2000_EXXO_AGS_STATUS_AGS_OPERATING_STATE_SUSPEND_CHOICE (8u)
#define NMEA2000_EXXO_AGS_STATUS_AGS_OPERATING_STATE_NOT_OPERATING_CHOICE (9u)
#define NMEA2000_EXXO_AGS_STATUS_AGS_OPERATING_STATE_RESERVED_CHOICE (10u)

#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_STATE_PREHEATING_CHOICE (0u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_STATE_START_DELAY_CHOICE (1u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_STATE_CRANKING_CHOICE (2u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_STATE_STARTER_COOLING_CHOICE (3u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_STATE_WARMING_UP_CHOICE (4u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_STATE_COLLING_DOWN_CHOICE (5u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_STATE_SPINNING_DOWN_CHOICE (6u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_STATE_SHUTDOWN_BYPASS_CHOICE (7u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_STATE_STOPPING_CHOICE (8u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_STATE_RUNNING_CHOICE (9u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_STATE_STOPPED_CHOICE (10u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_STATE_CRANK_DELAY_CHOICE (11u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_STATE_RESERVED_CHOICE (12u)

#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_ON_REASON_NOT_ON_CHOICE (0u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_ON_REASON_DC_VOLTAGE_LOW_CHOICE (1u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_ON_REASON_BATTERY_STATE_OF_CHARGE_LOW_CHOICE (2u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_ON_REASON_AC_CURRENT_HIGH_CHOICE (3u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_ON_REASON_CONTACT_CLOSED_CHOICE (4u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_ON_REASON_MANUAL_ON_CHOICE (5u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_ON_REASON_EXERCISE_CHOICE (6u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_ON_REASON_NON_QUIET_TIME_CHOICE (7u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_ON_REASON_EXTERNAL_ON_VIA_AGS_CHOICE (8u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_ON_REASON_EXTERNAL_ON_VIA_GENERATOR_CHOICE (9u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_ON_REASON_UNABLE_TO_STOP_CHOICE (10u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_ON_REASON_RESERVED_CHOICE (11u)

#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_OFF_REASON_NOT_OFF_CHOICE (0u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_OFF_REASON_DC_VOLTAGE_HIGH_CHOICE (1u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_OFF_REASON_BATTERY_STATE_OF_CHARGE_HIGH_CHOICE (2u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_OFF_REASON_AC_CURRENT_LOW_CHOICE (3u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_OFF_REASON_CONTACT_OPENED_CHOICE (4u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_OFF_REASON_REACHED_ABSORPTION_CHOICE (5u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_OFF_REASON_REACHED_FLOAT_CHOICE (6u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_OFF_REASON_MANUAL_OFF_CHOICE (7u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_OFF_REASON_MAX_RUN_TIME_CHOICE (8u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_OFF_REASON_MAX_AUTO_CYCLE_CHOICE (9u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_OFF_REASON_EXERCISE_DONE_CHOICE (10u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_OFF_REASON_QUIET_TIME_CHOICE (11u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_OFF_REASON_EXTERNAL_OFF_VIA_AGS_CHOICE (12u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_OFF_REASON_SAFE_MODE_CHOICE (13u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_OFF_REASON_EXTERNAL_OFF_VIA_GENERATOR_CHOICE (14u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_OFF_REASON_EXTERNAL_SHUTDOWN_CHOICE (15u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_OFF_REASON_AUTO_OFF_CHOICE (16u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_OFF_REASON_FAULT_CHOICE (17u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_OFF_REASON_UNABLE_TO_START_CHOICE (18u)
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_OFF_REASON_RESERVED_CHOICE (19u)

#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_REPEAT_INDICATOR_DEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_REPEAT_INDICATOR_FIRST_RESTRANSMISSION_CHOICE (1u)
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_REPEAT_INDICATOR_SECOND_RESTRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_REPEAT_INDICATOR_FINAL_RETRANSMISSION_CHOICE (3u)

#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_AIS_TRANSCEIVER_INFORMATION_CHANNEL_AVD_LRECEPTION_CHOICE (0u)
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_AIS_TRANSCEIVER_INFORMATION_CHANNEL_BVD_LRECEPTION_CHOICE (1u)
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_AIS_TRANSCEIVER_INFORMATION_CHANNEL_AVD_LTRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_AIS_TRANSCEIVER_INFORMATION_CHANNEL_BVD_LTRANSMISSION_CHOICE (3u)
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_AIS_TRANSCEIVER_INFORMATION_OWNINFORMATIONNOTBROADCAST_CHOICE (4u)

#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_POWER_HIGH_DEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_POWER_LOW_CHOICE (1u)

#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_TX_RX_MODE_TX_A_TX_B_RX_A_RX_BDEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_TX_RX_MODE_TX_A_RX_A_RX_B_CHOICE (1u)
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_TX_RX_MODE_TX_B_RX_A_RX1_CHOICE (2u)

#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_ADDRESSED_OR_BROADCAST_MESSAGE_INDICATOR_BROADCAST_GEOGRAPHICAL_AREA_MESSAGE_CHOICE (0u)
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_ADDRESSED_OR_BROADCAST_MESSAGE_INDICATOR_ADDRESSED_MESSAGE_CHOICE (1u)

#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_CHANNEL_A_BANDWIDTH_12500_HZ_BANDWIDTH_CHOICE (0u)

#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_CHANNEL_B_BANDWIDTH_DEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_CHANNEL_B_BANDWIDTH_12500_HZ_BANDWIDTH_CHOICE (1u)

#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_REPEAT_INDICATOR_DEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_REPEAT_INDICATOR_FIRST_RESTRANSMISSION_CHOICE (1u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_REPEAT_INDICATOR_SECOND_RETRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_REPEAT_INDICATOR_FINAL_RETRANSMISSION_CHOICE (3u)

#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_TX_RX_MODE_TX_A_TX_B_RX_A_RX_BDEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_TX_RX_MODE_TX_A_RX_A_RX_B_CHOICE (1u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_TX_RX_MODE_TX_B_RX_A_RX_B_CHOICE (2u)

#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_STATION_TYPE_ALLTYPESOFMOBILESDEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_STATION_TYPE_RESERVEDFORFUTUREUSE_CHOICE (1u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_STATION_TYPE_ALLTYPESOF_CLASS_BMOBILESTATIONS_CHOICE (2u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_STATION_TYPE_SA_RAIRBORNEMOBILESTATION_CHOICE (3u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_STATION_TYPE_ATO_NSTATION_CHOICE (4u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_STATION_TYPE_CLASS_BC_SSHIPBORNEMOBILESTATIONONLY_CHOICE (5u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_STATION_TYPE_INLANDWATERWAYS_CHOICE (6u)

#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_SHIP_AND_CARGO_FILTER_ALLTYPES_CHOICE (0u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_SHIP_AND_CARGO_FILTER_SEE_ITURM1371_TABLE50_CHOICE (1u)

#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_REPORTING_INTERVAL_AS_GIVEN_BY_THE_AUTONOMOUS_MODE_CHOICE (0u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_REPORTING_INTERVAL_10MIN_CHOICE (1u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_REPORTING_INTERVAL_6MIN_CHOICE (2u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_REPORTING_INTERVAL_3MIN_CHOICE (3u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_REPORTING_INTERVAL_1MIN_CHOICE (4u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_REPORTING_INTERVAL_30SEC_CHOICE (5u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_REPORTING_INTERVAL_15SEC_CHOICE (6u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_REPORTING_INTERVAL_10SEC_CHOICE (7u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_REPORTING_INTERVAL_5SEC_CHOICE (8u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_REPORTING_INTERVAL_2SEC_CHOICE (9u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_REPORTING_INTERVAL_NEXT_SHORTER_REPORTING_INTERVAL_CHOICE (10u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_REPORTING_INTERVAL_NEXT_LONGER_REPORTING_INTERVAL_CHOICE (11u)

#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_QUIET_TIME_NO_QUIET_TIME_COMMANDED_CHOICE (0u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_QUIET_TIME_QUIET_TIME_OF1MIN_CHOICE (1u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_QUIET_TIME_QUIET_TIME_OF2MIN_CHOICE (2u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_QUIET_TIME_QUIET_TIME_OF3MIN_CHOICE (3u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_QUIET_TIME_QUIET_TIME_OF4MIN_CHOICE (4u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_QUIET_TIME_QUIET_TIME_OF5MIN_CHOICE (5u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_QUIET_TIME_QUIET_TIME_OF6MIN_CHOICE (6u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_QUIET_TIME_QUIET_TIME_OF7MIN_CHOICE (7u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_QUIET_TIME_QUIET_TIME_OF8MIN_CHOICE (8u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_QUIET_TIME_QUIET_TIME_OF9MIN_CHOICE (9u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_QUIET_TIME_QUIET_TIME_OF10MIN_CHOICE (10u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_QUIET_TIME_QUIET_TIME_OF11MIN_CHOICE (11u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_QUIET_TIME_QUIET_TIME_OF12MIN_CHOICE (12u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_QUIET_TIME_QUIET_TIME_OF13MIN_CHOICE (13u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_QUIET_TIME_QUIET_TIME_OF14MIN_CHOICE (14u)
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_QUIET_TIME_QUIET_TIME_OF15MIN_CHOICE (15u)

#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_A_REPEAT_INDICATOR_DEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_A_REPEAT_INDICATOR_FIRST_RETRANSMISSION_CHOICE (1u)
#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_A_REPEAT_INDICATOR_SECOND_RETRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_A_REPEAT_INDICATOR_FINAL_RETRANSMISSION_CHOICE (3u)

#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_B_REPEAT_INDICATOR_DEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_B_REPEAT_INDICATOR_FIRST_RETRANSMISSION_CHOICE (1u)
#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_B_REPEAT_INDICATOR_SECOND_RETRANSMISSION_CHOICE (2u)
#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_B_REPEAT_INDICATOR_FINAL_RETRANSMISSION_CHOICE (3u)

#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_B_TYPE_OF_SHIP_AND_CARGO_NOT_AVAILABLE_OR_NO_SHIP_DEFAULT_CHOICE (0u)
#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_B_TYPE_OF_SHIP_AND_CARGO_ITURM1371_SECTION338232_TABLE18_CHOICE (1u)

#define NMEA2000_EXXO_TEMPERATURE_TEMPERATURE_INSTANCE_INSTANCE0_CHOICE (0u)
#define NMEA2000_EXXO_TEMPERATURE_TEMPERATURE_INSTANCE_INSTANCE1_CHOICE (1u)

#define NMEA2000_EXXO_TEMPERATURE_TEMPERATURE_SOURCE_SEA_TEMPERATURE_CHOICE (0u)
#define NMEA2000_EXXO_TEMPERATURE_TEMPERATURE_SOURCE_OUTSIDE_TEMPERATURE_CHOICE (1u)
#define NMEA2000_EXXO_TEMPERATURE_TEMPERATURE_SOURCE_INSIDE_TEMPERATURE_CHOICE (2u)
#define NMEA2000_EXXO_TEMPERATURE_TEMPERATURE_SOURCE_ENGINE_ROOM_TEMPERATURE_CHOICE (3u)
#define NMEA2000_EXXO_TEMPERATURE_TEMPERATURE_SOURCE_MAIN_CABIN_TEMPERATURE_CHOICE (4u)
#define NMEA2000_EXXO_TEMPERATURE_TEMPERATURE_SOURCE_LIVE_WELL_TEMPERATURE_CHOICE (5u)
#define NMEA2000_EXXO_TEMPERATURE_TEMPERATURE_SOURCE_BAIT_WELL_TEMPERATURE_CHOICE (6u)
#define NMEA2000_EXXO_TEMPERATURE_TEMPERATURE_SOURCE_REFRIGERATION_TEMPERATURE_CHOICE (7u)
#define NMEA2000_EXXO_TEMPERATURE_TEMPERATURE_SOURCE_HEATING_SYSTEM_TEMPERATURE_CHOICE (8u)
#define NMEA2000_EXXO_TEMPERATURE_TEMPERATURE_SOURCE_DEW_POINT_TEMPERATURE_CHOICE (9u)
#define NMEA2000_EXXO_TEMPERATURE_TEMPERATURE_SOURCE_WIND_CHILL_TEMPERATURE_APPARENT_CHOICE (10u)
#define NMEA2000_EXXO_TEMPERATURE_TEMPERATURE_SOURCE_WIND_CHILL_TEMPERATURE_THEORICAL_CHOICE (11u)
#define NMEA2000_EXXO_TEMPERATURE_TEMPERATURE_SOURCE_HEAT_INDEX_TEMPERATURE_CHOICE (12u)
#define NMEA2000_EXXO_TEMPERATURE_TEMPERATURE_SOURCE_FREEZER_TEMPERATURE_CHOICE (13u)

#define NMEA2000_EXXO_HUMIDITY_HUMIDITY_INSTANCE_INSTANCE0_CHOICE (0u)
#define NMEA2000_EXXO_HUMIDITY_HUMIDITY_INSTANCE_INSTANCE1_CHOICE (1u)

#define NMEA2000_EXXO_HUMIDITY_HUMIDITY_SOURCE_INSIDE_HUMIDITY_CHOICE (0u)
#define NMEA2000_EXXO_HUMIDITY_HUMIDITY_SOURCE_OUTSIDE_HUMIDITY_CHOICE (1u)
#define NMEA2000_EXXO_HUMIDITY_HUMIDITY_SOURCE_RESERVED_CHOICE (2u)

#define NMEA2000_EXXO_ACTUAL_PRESSURE_PRESSURE_INSTANCE_INSTANCE0_CHOICE (0u)
#define NMEA2000_EXXO_ACTUAL_PRESSURE_PRESSURE_INSTANCE_INSTANCE1_CHOICE (1u)

#define NMEA2000_EXXO_ACTUAL_PRESSURE_PRESSURE_SOURCE_ATMOSPHERIC_PRESSURE_CHOICE (0u)
#define NMEA2000_EXXO_ACTUAL_PRESSURE_PRESSURE_SOURCE_WATER_PRESSURE_CHOICE (1u)
#define NMEA2000_EXXO_ACTUAL_PRESSURE_PRESSURE_SOURCE_STEAM_PRESSURE_CHOICE (2u)
#define NMEA2000_EXXO_ACTUAL_PRESSURE_PRESSURE_SOURCE_COMPRESSED_AIR_PRESSURE_CHOICE (3u)
#define NMEA2000_EXXO_ACTUAL_PRESSURE_PRESSURE_SOURCE_HYDRAULIC_PRESSURE_CHOICE (4u)

#define NMEA2000_EXXO_SET_PRESSURE_PRESSURE_INSTANCE_INSTANCE0_CHOICE (0u)
#define NMEA2000_EXXO_SET_PRESSURE_PRESSURE_INSTANCE_INSTANCE1_CHOICE (1u)

#define NMEA2000_EXXO_SET_PRESSURE_PRESSURE_SOURCE_ATMOSPHERIC_PRESSURE_CHOICE (0u)
#define NMEA2000_EXXO_SET_PRESSURE_PRESSURE_SOURCE_WATER_PRESSURE_CHOICE (1u)
#define NMEA2000_EXXO_SET_PRESSURE_PRESSURE_SOURCE_STEAM_PRESSURE_CHOICE (2u)
#define NMEA2000_EXXO_SET_PRESSURE_PRESSURE_SOURCE_COMPRESSED_AIR_PRESSURE_CHOICE (3u)
#define NMEA2000_EXXO_SET_PRESSURE_PRESSURE_SOURCE_HYDRAULIC_PRESSURE_CHOICE (4u)

#define NMEA2000_EXXO_ENVIRONMENTAL_PARAMETERS2_SEQUENCE_ID__N_VLD_PS_FX_TT_IT_T_RNG0_T250_FR_VLD_PSTN_FX_CHOICE (255u)

#define NMEA2000_EXXO_ENVIRONMENTAL_PARAMETERS2_TEMP_INSTANCE_TEMPERATURE_CHOICE (0u)
#define NMEA2000_EXXO_ENVIRONMENTAL_PARAMETERS2_TEMP_INSTANCE_OUTSIDE_CHOICE (1u)
#define NMEA2000_EXXO_ENVIRONMENTAL_PARAMETERS2_TEMP_INSTANCE_RESERVE__CHOICE (5u)
#define NMEA2000_EXXO_ENVIRONMENTAL_PARAMETERS2_TEMP_INSTANCE_RESERVE_CHOICE (62u)
#define NMEA2000_EXXO_ENVIRONMENTAL_PARAMETERS2_TEMP_INSTANCE_DATA_NOT_AVAILABLE_CHOICE (63u)

#define NMEA2000_EXXO_ENVIRONMENTAL_PARAMETERS2_HUMIDITY_INSTANCE_INSIDE_HUMIDITY_CHOICE (0u)
#define NMEA2000_EXXO_ENVIRONMENTAL_PARAMETERS2_HUMIDITY_INSTANCE_OUTSIDE_HUMIDITY_CHOICE (1u)
#define NMEA2000_EXXO_ENVIRONMENTAL_PARAMETERS2_HUMIDITY_INSTANCE_RESERVED_CHOICE (2u)
#define NMEA2000_EXXO_ENVIRONMENTAL_PARAMETERS2_HUMIDITY_INSTANCE_DATA_NOT_AVAILABLE_CHOICE (3u)

#define NMEA2000_EXXO_PGN_LST_TRANSMIT_PG_NS_GROUP_FUNCTION_GRP_FNCTN_TRNSMT_AND_RECEIVE_PGN_LIST_TRANSMIT_PGN_LIST_MESSAGE_CHOICE (0u)
#define NMEA2000_EXXO_PGN_LST_TRANSMIT_PG_NS_GROUP_FUNCTION_GRP_FNCTN_TRNSMT_AND_RECEIVE_PGN_LIST_RECEIVE_PGN_LIST_MESSAGE_CHOICE (1u)

/* Frame Names. */
#define NMEA2000_EXXO_TIME_DATE_NAME "Time_Date"
#define NMEA2000_EXXO_TIME_TO_FROM_MARK_NAME "TimeTo_FromMark"
#define NMEA2000_EXXO_TIDE_STATION_DATA_NAME "TideStationData"
#define NMEA2000_EXXO_SYSTEM_TIME_NAME "SystemTime"
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_NAME "SwitchBankCtrl"
#define NMEA2000_EXXO_SPEED_WATER_REFERENCED_NAME "SpeedWaterReferenced"
#define NMEA2000_EXXO_SMALL_CRAFT_STATUS_NAME "SmallCraftStatus"
#define NMEA2000_EXXO_SET_DRIFT_RAPID_UPDATE_NAME "SetDriftRapidUpdate"
#define NMEA2000_EXXO_SALINITY_STATION_DATA_NAME "SalinityStationData"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_WP_NAME_POS_NAME "RouteAndWPServiceRouteWPNamePos"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_WP_NAME_NAME "RouteAndWPServiceRouteWPName"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_LIST_NAME "RouteAndWPServiceRouteList"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_COMMENT_NAME "RouteAndWPServiceRouteComment"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_RADIUS_OF_TURN_NAME "RouteAndWPServiceRadiusOfTurn"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_DATABASE_LIST_NAME "RouteAndWPServiceDatabaseList"
#define NMEA2000_EXXO_RATE_OF_TURN_NAME "RateOfTurn"
#define NMEA2000_EXXO_RADIO_FREQUENCY_MODE_POWER_NAME "RadioFrequency_Mode_Power"
#define NMEA2000_EXXO_PS_DELTA_HIGH_PRECISION_RAPID_UPDATE_NAME "PsDeltaHighPrecisionRapidUpdate"
#define NMEA2000_EXXO_POS_RAPID_UPDATE_NAME "PosRapidUpdate"
#define NMEA2000_EXXO_NAVIGATION_ROUTE_WP_INFORMATION_NAME "NavigationRoute_WPInformation"
#define NMEA2000_EXXO_NAVIGATION_DATA_NAME "NavigationData"
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_NAME "NMEARqGroupFunction"
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_NAME "MooredBuoyStationData"
#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_NAME "MeteorologicalStationData"
#define NMEA2000_EXXO_MAGNETIC_VARIATION_NAME "MagneticVariation"
#define NMEA2000_EXXO_LORAN_CTD_DATA_NAME "LoranCTDData"
#define NMEA2000_EXXO_LORAN_C_SIGNAL_DATA_NAME "LoranCSignalData"
#define NMEA2000_EXXO_LORAN_C_RANGE_DATA_NAME "LoranCRangeData"
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_NAME "Heading_TrackCtrl"
#define NMEA2000_EXXO_GPS_ALMANAC_DATA_NAME "GPSAlmanacData"
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_NAME "GNSSSatsInView"
#define NMEA2000_EXXO_GNSSRAIM_SETTINGS_NAME "GNSSRAIMSettings"
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_NAME "BringAndDistanceBetweenTwoMarks"
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_NAME "BinarySwitchBankStatus"
#define NMEA2000_EXXO_BATTERY_STATUS_NAME "BatteryStatus"
#define NMEA2000_EXXO_ATTITUDE_NAME "Attitude"
#define NMEA2000_EXXO_ALTTD_DLT_HGH_PRECISION_RAPID_UPDATE_NAME "AlttdDltHghPrecisionRapidUpdate"
#define NMEA2000_EXXO_AISUTC_DATE_INQUIRY_NAME "AISUTC_DateInquiry"
#define NMEA2000_EXXO_AISUTC_AND_DATE_REPORT_NAME "AISUTCAndDateReport"
#define NMEA2000_EXXO_AIS_SAFETY_RELATED_BROADCAST_MSG_NAME "AISSafetyRelatedBroadcastMsg"
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_NAME "AISSARAircraftPosReport"
#define NMEA2000_EXXO_AIS_INTERROGATION_NAME "AISInterrogation"
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_NAME "AISDataLinkManagementMsg"
#define NMEA2000_EXXO_AISDGNSS_BROADCAST_BINARY_MSG_NAME "AISDGNSSBroadcastBinaryMsg"
#define NMEA2000_EXXO_AIS_CLSS_A_STTC_AND_VYAGE_RELATED_DATA_NAME "AISClssASttcAndVyageRelatedData"
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_NAME "AISClassBPosReport"
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_NAME "AISClassBExPosReport"
#define NMEA2000_EXXO_CA_NAME "CA"
#define NMEA2000_EXXO_ACL_NAME "ACL"
#define NMEA2000_EXXO_TPDT_NAME "TPDT"
#define NMEA2000_EXXO_TPCM_NAME "TPCM"
#define NMEA2000_EXXO_RQST_NAME "RQST"
#define NMEA2000_EXXO_WIND_DATA_NAME "WindData"
#define NMEA2000_EXXO_WATER_DEPTH_NAME "WaterDepth"
#define NMEA2000_EXXO_VESSEL_SPEED_COMPONENTS_NAME "VesselSpeedComponents"
#define NMEA2000_EXXO_VESSEL_HEADING_NAME "VesselHeading"
#define NMEA2000_EXXO_USER_DATUM_SETTINGS_NAME "UserDatumSettings"
#define NMEA2000_EXXO_TRIP_PARAMETERS_VESSEL_NAME "TripParametersVessel"
#define NMEA2000_EXXO_TRIP_PARAMETERS_ENG_NAME "TripParametersEng"
#define NMEA2000_EXXO_TRANS_PARAMETERS_DYNAMIC_NAME "TransParametersDynamic"
#define NMEA2000_EXXO_TRACKED_TARGET_DATA_NAME "TrackedTargetData"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_WP_LIST_WP_NAME_POS_NAME "RouteAndWPServiceWPListWPNamePos"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_DATABASE_COMMENT_NAME "RouteAndWPServiceDatabaseComment"
#define NMEA2000_EXXO_RUDDER_NAME "Rudder"
#define NMEA2000_EXXO_RT_AND_WP_SRVC_XTE_LMT_NVGATION_METHOD_NAME "RtAndWPSrvcXTELmtNvgationMethod"
#define NMEA2000_EXXO_RT_AND_WP_SRVC_RTE_WP_LIST_ATTRIBUTES_NAME "RtAndWPSrvcRte_WPListAttributes"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_WP_COMMENT_NAME "RouteAndWPServiceWPComment"
#define NMEA2000_EXXO_GNSSRAIM_OUTPUT_NAME "GNSSRAIMOutput"
#define NMEA2000_EXXO_GNSS_PSEUDORANGE_NOISE_STATISTICS_NAME "GNSSPseudorangeNoiseStatistics"
#define NMEA2000_EXXO_GNSS_PSEUDORANGE_ERROR_STATISTICS_NAME "GNSSPseudorangeErrorStatistics"
#define NMEA2000_EXXO_GNSS_POS_DATA_NAME "GNSSPosData"
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_NAME "GNSSDffCrrctonReceiverInterface"
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_NAME "GNSSDffCorrectionReceiverSignal"
#define NMEA2000_EXXO_GNSSDO_PS_NAME "GNSSDOPs"
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_NAME "GNSSCtrlStatus"
#define NMEA2000_EXXO_GLONASS_ALMANAC_DATA_NAME "GLONASSAlmanacData"
#define NMEA2000_EXXO_FLUID_LEVEL_NAME "FluidLevel"
#define NMEA2000_EXXO_ENVIRONMENTAL_PARAMETERS_NAME "EnvironmentalParameters"
#define NMEA2000_EXXO_ENG_PARAMETERS_STATIC_NAME "EngParametersStatic"
#define NMEA2000_EXXO_ENG_PARAMETERS_RAPID_UPDATE_NAME "EngParametersRapidUpdate"
#define NMEA2000_EXXO_ENG_PARAMETERS_DYNAMIC_NAME "EngParametersDynamic"
#define NMEA2000_EXXO_DISTANCE_LOG_NAME "DistanceLog"
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_NAME "AISClassAPosReport"
#define NMEA2000_EXXO_AIS_BINARY_BROADCAST_MSG_NAME "AISBinaryBroadcastMsg"
#define NMEA2000_EXXO_AIS_ASSIGNMENT_MODE_CMD_NAME "AISAssignmentModeCmd"
#define NMEA2000_EXXO_ACKM_NAME "ACKM"
#define NMEA2000_EXXO_DIRECTION_DATA_NAME "DirectionData"
#define NMEA2000_EXXO_DATUM_NAME "Datum"
#define NMEA2000_EXXO_DSC_CALL_INFORMATION_NAME "DSCCallInformation"
#define NMEA2000_EXXO_DGNSS_CORRECTIONS_NAME "DGNSSCorrections"
#define NMEA2000_EXXO_CURRENT_STATION_DATA_NAME "CurrentStationData"
#define NMEA2000_EXXO_CROSS_TRACK_ERROR_NAME "CrossTrackError"
#define NMEA2000_EXXO_COGSOG_RAPID_UPDATE_NAME "COGSOGRapidUpdate"
#define NMEA2000_EXXO_AIS_ADDRESSED_SAFETY_RELATED_MSG_NAME "AISAddressedSafetyRelatedMsg"
#define NMEA2000_EXXO_AIS_ADDRESSED_BINARY_MSG_NAME "AISAddressedBinaryMsg"
#define NMEA2000_EXXO_AIS_ACKNOWLEDGE_NAME "AISAcknowledge"
#define NMEA2000_EXXO_AC_INPUT_STATUS_NAME "AC_Input_Status"
#define NMEA2000_EXXO_AC_OUTPUT_STATUS_NAME "AC_Output_Status"
#define NMEA2000_EXXO_DC_DETAILED_STATUS_NAME "DC_Detailed_Status"
#define NMEA2000_EXXO_CHARGER_STATUS_NAME "Charger_Status"
#define NMEA2000_EXXO_INVERTER_STATUS_NAME "Inverter_Status"
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_NAME "Charger_Configuration_Status"
#define NMEA2000_EXXO_INVERTER_CONFIGURATION_STATUS_NAME "Inverter_Configuration_Status"
#define NMEA2000_EXXO_AGS_CONFIGURATION_STATUS_NAME "AGS_Configuration_Status"
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_NAME "Battery_Configuration_Status"
#define NMEA2000_EXXO_AGS_STATUS_NAME "AGS_Status"
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_NAME "AIS_Channel_Management"
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_NAME "AIS_Class_B_Group_Assignment"
#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_A_NAME "AIS_Class_B_CS_Static_Data_Report_Part_A"
#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_B_NAME "AIS_Class_B_CS_Static_Data_Report_Part_B"
#define NMEA2000_EXXO_TEMPERATURE_NAME "Temperature"
#define NMEA2000_EXXO_HUMIDITY_NAME "Humidity"
#define NMEA2000_EXXO_ACTUAL_PRESSURE_NAME "Actual_Pressure"
#define NMEA2000_EXXO_SET_PRESSURE_NAME "Set_Pressure"
#define NMEA2000_EXXO_ENVIRONMENTAL_PARAMETERS2_NAME "EnvironmentalParameters2"
#define NMEA2000_EXXO_PRODUCT_INFORMATION_NAME "ProductInformation"
#define NMEA2000_EXXO_CONFIG_INFORMATION_NAME "ConfigInformation"
#define NMEA2000_EXXO_PGN_LST_TRANSMIT_PG_NS_GROUP_FUNCTION_NAME "PGNLstTransmitPGNsGroupFunction"

/* Signal Names. */
#define NMEA2000_EXXO_TIME_DATE_DATE_NAME "Date"
#define NMEA2000_EXXO_TIME_DATE_TIME_NAME "Time"
#define NMEA2000_EXXO_TIME_DATE_LOCAL_OFFSET_MINUTES_NAME "LocalOffsetMinutes"
#define NMEA2000_EXXO_TIME_TO_FROM_MARK_SID_NAME "SID"
#define NMEA2000_EXXO_TIME_TO_FROM_MARK_TIME_ELAPSED_TOGO_TO_MARK_NAME "TimeElapsedTogoToMark"
#define NMEA2000_EXXO_TIME_TO_FROM_MARK_MARK_TYPE_NAME "MarkType"
#define NMEA2000_EXXO_TIME_TO_FROM_MARK_MARK_ID_NAME "MarkID"
#define NMEA2000_EXXO_TIDE_STATION_DATA_MODE_NAME "Mode"
#define NMEA2000_EXXO_TIDE_STATION_DATA_TIDE_TENDENCY_NAME "TideTendency"
#define NMEA2000_EXXO_TIDE_STATION_DATA_MEASUREMENT_DATE_NAME "MeasurementDate"
#define NMEA2000_EXXO_TIDE_STATION_DATA_MEASUREMENT_TIME_NAME "MeasurementTime"
#define NMEA2000_EXXO_TIDE_STATION_DATA_STATION_LOCATION_LATITUDE_NAME "StationLocationLatitude"
#define NMEA2000_EXXO_TIDE_STATION_DATA_STATION_LOCATION_LONGITUDE_NAME "StationLocationLongitude"
#define NMEA2000_EXXO_TIDE_STATION_DATA_TIDE_LEVEL_NAME "TideLevel"
#define NMEA2000_EXXO_TIDE_STATION_DATA_TIDE_LEVEL_STANDARD_DEVIATION_NAME "TideLevelStandardDeviation"
#define NMEA2000_EXXO_TIDE_STATION_DATA_STATION_ID_STRING_NAME "StationIDString"
#define NMEA2000_EXXO_TIDE_STATION_DATA_STATION_NAME_STRING_NAME "StationNameString"
#define NMEA2000_EXXO_SYSTEM_TIME_SID_NAME "SID"
#define NMEA2000_EXXO_SYSTEM_TIME_SOURCE_NAME "Source"
#define NMEA2000_EXXO_SYSTEM_TIME_DATE_NAME "Date"
#define NMEA2000_EXXO_SYSTEM_TIME_TIME_NAME "Time"
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH_BANK_INSTANCE_NAME "SwitchBankInstance"
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH1_NAME "Switch1"
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH2_NAME "Switch2"
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH3_NAME "Switch3"
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH4_NAME "Switch4"
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH5_NAME "Switch5"
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH6_NAME "Switch6"
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH7_NAME "Switch7"
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH8_NAME "Switch8"
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH9_NAME "Switch9"
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH10_NAME "Switch10"
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH11_NAME "Switch11"
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH12_NAME "Switch12"
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH13_NAME "Switch13"
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH14_NAME "Switch14"
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH15_NAME "Switch15"
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH16_NAME "Switch16"
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH17_NAME "Switch17"
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH18_NAME "Switch18"
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH19_NAME "Switch19"
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH20_NAME "Switch20"
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH21_NAME "Switch21"
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH22_NAME "Switch22"
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH23_NAME "Switch23"
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH24_NAME "Switch24"
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH25_NAME "Switch25"
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH26_NAME "Switch26"
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH27_NAME "Switch27"
#define NMEA2000_EXXO_SWITCH_BANK_CTRL_SWITCH28_NAME "Switch28"
#define NMEA2000_EXXO_SPEED_WATER_REFERENCED_SEQUENCE_ID__NAME "SequenceID_"
#define NMEA2000_EXXO_SPEED_WATER_REFERENCED_SPEED_WATER_REFERENCED_NAME "SpeedWaterReferenced"
#define NMEA2000_EXXO_SPEED_WATER_REFERENCED_SPEED_GROUND_REFERENCED_NAME "SpeedGroundReferenced"
#define NMEA2000_EXXO_SPEED_WATER_REFERENCED_SPEED_WATER_REFERENCED_TYPE_NAME "SpeedWaterReferencedType"
#define NMEA2000_EXXO_SMALL_CRAFT_STATUS_PORT_TRIM_TAB_NAME "PortTrimTab"
#define NMEA2000_EXXO_SMALL_CRAFT_STATUS_STARBOARD_TRIM_TAB_NAME "StarboardTrimTab"
#define NMEA2000_EXXO_SET_DRIFT_RAPID_UPDATE_SID_NAME "SID"
#define NMEA2000_EXXO_SET_DRIFT_RAPID_UPDATE_SET_REFERENCE_NAME "SetReference"
#define NMEA2000_EXXO_SET_DRIFT_RAPID_UPDATE_SET_NAME "Set"
#define NMEA2000_EXXO_SET_DRIFT_RAPID_UPDATE_DRIFT_NAME "Drift"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_WP_NAME_POS_START_RPS_NAME "StartRPS"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_WP_NAME_POS_N_ITEMS_NAME "nItems"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_WP_NAME_POS_NUMBER_OF_W_PS_IN_ROUTE_NAME "NumberOfWPsInRoute"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_WP_NAME_POS_DATABASE_ID_NAME "DatabaseID"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_WP_NAME_POS_ROUTE_ID_NAME "RouteID"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_WP_NAME_POS_WPID_NAME "WPID"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_WP_NAME_POS_WP_NAME_NAME "WPName"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_WP_NAME_START_RPS_NAME "StartRPS"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_WP_NAME_N_ITEMS_NAME "nItems"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_WP_NAME_NUMBER_OF_W_PS_IN_ROUTE_NAME "NumberOfWPsInRoute"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_WP_NAME_DATABASE_ID_NAME "DatabaseID"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_WP_NAME_ROUTE_ID_NAME "RouteID"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_WP_NAME_WPID_NAME "WPID"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_WP_NAME_WP_NAME_NAME "WPName"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_LIST_START_ROUTE_ID_NAME "StartRouteID"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_LIST_N_ITEMS_NAME "nItems"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_LIST_NMBR_OF_ROUTES_AVAILABLE_IN_DATABASE_NAME "NmbrOfRoutesAvailableInDatabase"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_LIST_DATABASE_ID_NAME "DatabaseID"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_LIST_ROUTE_ID_NAME "RouteID"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_LIST_ROUTE_NAME_NAME "RouteName"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_COMMENT_START_ROUTE_ID_NAME "StartRouteID"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_COMMENT_N_ITEMS_NAME "nItems"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_COMMENT_NUMBER_OF_ROUTES_WITH_COMMENTS_NAME "NumberOfRoutesWithComments"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_COMMENT_DATABASE_ID_NAME "DatabaseID"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_COMMENT_ROUTE_ID_NAME "RouteID"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_ROUTE_COMMENT_COMMENT_NAME "Comment"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_RADIUS_OF_TURN_START_RPS_NAME "StartRPS"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_RADIUS_OF_TURN_N_ITEMS_NAME "nItems"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_RADIUS_OF_TURN_NMBR_OF_WYPNTS_WTH_A_SPCFC_RDUS_OF_TURN_NAME "NmbrOfWypntsWthASpcfcRdusOfTurn"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_RADIUS_OF_TURN_DATABASE_ID_NAME "DatabaseID"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_RADIUS_OF_TURN_ROUTE_ID_NAME "RouteID"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_RADIUS_OF_TURN_RPS_NAME "RPS"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_RADIUS_OF_TURN_RADIUS_OF_TURN_NAME "RadiusOfTurn"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_DATABASE_LIST_START_DATABASE_ID_NAME "StartDatabaseID"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_DATABASE_LIST_N_ITEMS_NAME "nItems"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_DATABASE_LIST_NUMBER_OF_DATABASES_AVAILABLE_NAME "NumberOfDatabasesAvailable"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_DATABASE_LIST_DATABASE_ID_NAME "DatabaseID"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_DATABASE_LIST_DATABASE_NAME_NAME "DatabaseName"
#define NMEA2000_EXXO_RATE_OF_TURN_SEQUENCE_ID__NAME "SequenceID_"
#define NMEA2000_EXXO_RATE_OF_TURN_RATE_OF_TURN_NAME "RateOfTurn"
#define NMEA2000_EXXO_RADIO_FREQUENCY_MODE_POWER_RX_FREQUENCY_NAME "RxFrequency"
#define NMEA2000_EXXO_RADIO_FREQUENCY_MODE_POWER_TX_FREQUENCY_NAME "TxFrequency"
#define NMEA2000_EXXO_RADIO_FREQUENCY_MODE_POWER_RADIO_CHANNEL_NAME "RadioChannel"
#define NMEA2000_EXXO_PS_DELTA_HIGH_PRECISION_RAPID_UPDATE_SEQUENCE_ID__NAME "SequenceID_"
#define NMEA2000_EXXO_PS_DELTA_HIGH_PRECISION_RAPID_UPDATE_TIME_DELTA_NAME "TimeDelta"
#define NMEA2000_EXXO_PS_DELTA_HIGH_PRECISION_RAPID_UPDATE_LATITUDE_DELTA_NAME "LatitudeDelta"
#define NMEA2000_EXXO_PS_DELTA_HIGH_PRECISION_RAPID_UPDATE_LONGITUDE_DELTA_NAME "LongitudeDelta"
#define NMEA2000_EXXO_POS_RAPID_UPDATE_LATITUDE__NAME "Latitude_"
#define NMEA2000_EXXO_POS_RAPID_UPDATE_LONGITUDE__NAME "Longitude_"
#define NMEA2000_EXXO_NAVIGATION_ROUTE_WP_INFORMATION_START_RPS_NAME "StartRPS"
#define NMEA2000_EXXO_NAVIGATION_ROUTE_WP_INFORMATION_N_ITEMS_NAME "nItems"
#define NMEA2000_EXXO_NAVIGATION_ROUTE_WP_INFORMATION_DATABASE_ID_NAME "DatabaseID"
#define NMEA2000_EXXO_NAVIGATION_ROUTE_WP_INFORMATION_ROUTE_ID_NAME "RouteID"
#define NMEA2000_EXXO_NAVIGATION_ROUTE_WP_INFORMATION_NAVIGATION_DIRECTION_IN_ROUTE_NAME "NavigationDirectionInRoute"
#define NMEA2000_EXXO_NAVIGATION_ROUTE_WP_INFORMATION_SPPLMNTARY_ROUTE_WP_DATA_AVAILABLE_NAME "SpplmntaryRoute_WPDataAvailable"
#define NMEA2000_EXXO_NAVIGATION_ROUTE_WP_INFORMATION_ROUTE_NAME_NAME "RouteName"
#define NMEA2000_EXXO_NAVIGATION_ROUTE_WP_INFORMATION_WP_NAME_NAME "WPName"
#define NMEA2000_EXXO_NAVIGATION_DATA_SID_NAME "SID"
#define NMEA2000_EXXO_NAVIGATION_DATA_DISTANCE_TO_DESTINATION_WAYPOINT_NAME "DistanceToDestinationWaypoint"
#define NMEA2000_EXXO_NAVIGATION_DATA_COURSE_BEARING_REF_NAME "Course_BearingRef"
#define NMEA2000_EXXO_NAVIGATION_DATA_PERPENDICULAR_CROSSED_NAME "PerpendicularCrossed"
#define NMEA2000_EXXO_NAVIGATION_DATA_ARRIVAL_CIRCLE_ENTERED_NAME "ArrivalCircleEntered"
#define NMEA2000_EXXO_NAVIGATION_DATA_CALCULATION_TYPE_NAME "CalculationType"
#define NMEA2000_EXXO_NAVIGATION_DATA_ETA_TIME_NAME "ETATime"
#define NMEA2000_EXXO_NAVIGATION_DATA_ETA_DATE_NAME "ETADate"
#define NMEA2000_EXXO_NAVIGATION_DATA_BARINGIGIN_TO_DESTINATION_WAYPOINT_NAME "BaringiginToDestinationWaypoint"
#define NMEA2000_EXXO_NAVIGATION_DATA_BEARING_POS_TO_DESTINATION_WAYPOINT_NAME "BearingPosToDestinationWaypoint"
#define NMEA2000_EXXO_NAVIGATION_DATA_ORIGIN_WAYPOINT_NUMBER_NAME "OriginWaypointNumber"
#define NMEA2000_EXXO_NAVIGATION_DATA_DESTINATION_WAYPOINT_NUMBER_NAME "DestinationWaypointNumber"
#define NMEA2000_EXXO_NAVIGATION_DATA_DESTINATION_WPT_LATITUDE_NAME "DestinationWptLatitude"
#define NMEA2000_EXXO_NAVIGATION_DATA_DESTINATION_WPT_LONGITUDE_NAME "DestinationWptLongitude"
#define NMEA2000_EXXO_NAVIGATION_DATA_WAYPOINT_CLOSING_VELOCITY_NAME "WaypointClosingVelocity"
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_GROUP_FUNCTION_RQ_CMD_ACKNOWLEDGE_NAME "GroupFunctionRq_Cmd_Acknowledge"
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_PGN_ERROR_CODE_NAME "PGNErrorCode"
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_CMDED_PGN_NAME "CmdedPGN"
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_RQED_PGN_NAME "RqedPGN"
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_RQED_CMDED_PGN_BEING_ACKNOWLEDGED_NAME "RqedCmdedPGNBeingAcknowledged"
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_PRIORITY_SETTING_NAME "PrioritySetting"
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_TRANS_INTERVAL_NAME "TransInterval"
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_TRANS_INTERVAL_PRIORITY_ERROR_CODE_NAME "TransInterval_PriorityErrorCode"
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_FIRST_PARAMETER_ERROR_CODE_NAME "FirstParameterErrorCode"
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_NMBR_OF_PRS_OF_CMDD_PRMETERS_TO_FOLLOW_NAME "NmbrOfPrsOfCmddPrmetersToFollow"
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_VRBL_NMBR_OF_FLDS_FLD_NMBER6_REPEATED3_NAME "VrblNmbrOfFldsFldNmber6Repeated3"
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_NUMBER_OF_RQED_CMDED_PARAMETERS_NAME "NumberOfRqedCmdedParameters"
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_FELD_NUMBER_OF_FIRST_CMDED_PARAMETER_NAME "FeldNumberOfFirstCmdedParameter"
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_VRBL_NMBR_OF_FLDS_FLD_NMBER6_REPEATED2_NAME "VrblNmbrOfFldsFldNmber6Repeated2"
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_TRANS_INTERVAL_OFFSET_NAME "TransIntervalOffset"
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_NMBR_OF_PRS_OF_RQ_PARAMETERS_TO_FOLLOW_NAME "NmbrOfPrsOfRqParametersToFollow"
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_FIELD_NUMBER_OF_FIRST_RQED_PARAMETER_NAME "FieldNumberOfFirstRqedParameter"
#define NMEA2000_EXXO_NMEA_RQ_GROUP_FUNCTION_VRBL_NMBR_OF_FLDS_FLD_NMBER6_REPEATED_NAME "VrblNmbrOfFldsFldNmber6Repeated"
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_MODE_NAME "Mode"
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_MEASUREMENT_DATE_NAME "MeasurementDate"
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_MEASUREMENT_TIME_NAME "MeasurementTime"
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_STATION_LOCATION_LATITUDE_NAME "StationLocationLatitude"
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_STATION_LOCATION_LONGITUDE_NAME "StationLocationLongitude"
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_WIND_SPEED_NAME "WindSpeed"
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_WIND_DIRECTION_NAME "WindDirection"
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_WIND_REFERENCE_NAME "WindReference"
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_WIND_GUSTS_NAME "WindGusts"
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_WAVE_HEIGHT_NAME "WaveHeight"
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_DOMINATE_WAVE_PERIOD_NAME "DominateWavePeriod"
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_ATMOSPHERIC_PRESS_NAME "AtmosphericPress"
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_PRESS_TENDENCY_RATE_NAME "PressTendencyRate"
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_AIR_TEMP_NAME "AirTemp"
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_WATER_TEMP_NAME "WaterTemp"
#define NMEA2000_EXXO_MOORED_BUOY_STATION_DATA_STATION_ID_STRING_NAME "StationIDString"
#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_MODE_NAME "Mode"
#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_MEASUREMENT_DATE_NAME "MeasurementDate"
#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_MEASUREMENT_TIME_NAME "MeasurementTime"
#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_STATION_LOCATION_LATITUDE_NAME "StationLocationLatitude"
#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_STATION_LOCATION_LONGITUDE_NAME "StationLocationLongitude"
#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_WIND_SPEED_NAME "WindSpeed"
#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_WIND_DIRECTION_NAME "WindDirection"
#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_WIND_REFERENCE_NAME "WindReference"
#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_WIND_GUSTS_NAME "WindGusts"
#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_ATMOSPHERIC_PRESS_NAME "AtmosphericPress"
#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_AIR_TEMP_NAME "AirTemp"
#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_STATION_ID_STRING_NAME "StationIDString"
#define NMEA2000_EXXO_METEOROLOGICAL_STATION_DATA_STATION_NAME_STRING_NAME "StationNameString"
#define NMEA2000_EXXO_MAGNETIC_VARIATION_SEQUENCE_ID__NAME "SequenceID_"
#define NMEA2000_EXXO_MAGNETIC_VARIATION_VARIATION_SOURCE_NAME "VariationSource"
#define NMEA2000_EXXO_MAGNETIC_VARIATION_AGE_OF_SERVICE_NAME "AgeOfService"
#define NMEA2000_EXXO_MAGNETIC_VARIATION_VARIATION_NAME "Variation"
#define NMEA2000_EXXO_LORAN_CTD_DATA_GROUP_REPETITION_INTERVAL_NAME "GroupRepetitionInterval"
#define NMEA2000_EXXO_LORAN_CTD_DATA_MASTER_RANGE_NAME "MasterRange"
#define NMEA2000_EXXO_LORAN_CTD_DATA_V_SECOND_TD_NAME "VSecondTD"
#define NMEA2000_EXXO_LORAN_CTD_DATA_W_SECOND_TD_NAME "WSecondTD"
#define NMEA2000_EXXO_LORAN_CTD_DATA_X_SECOND_TD_NAME "XSecondTD"
#define NMEA2000_EXXO_LORAN_CTD_DATA_Y_SECOND_TD_NAME "YSecondTD"
#define NMEA2000_EXXO_LORAN_CTD_DATA_Z_SECOND_TD_NAME "ZSecondTD"
#define NMEA2000_EXXO_LORAN_CTD_DATA_STATION_STATUS_MASTER_NAME "StationStatusMaster"
#define NMEA2000_EXXO_LORAN_CTD_DATA_STATION_STATUS_V_NAME "StationStatusV"
#define NMEA2000_EXXO_LORAN_CTD_DATA_STATION_STATUS_W_NAME "StationStatusW"
#define NMEA2000_EXXO_LORAN_CTD_DATA_STATION_STATUS_X_NAME "StationStatusX"
#define NMEA2000_EXXO_LORAN_CTD_DATA_STATION_STATUS_Y_NAME "StationStatusY"
#define NMEA2000_EXXO_LORAN_CTD_DATA_STATION_STATUS_Z_NAME "StationStatusZ"
#define NMEA2000_EXXO_LORAN_CTD_DATA_MODE_NAME "Mode"
#define NMEA2000_EXXO_LORAN_C_SIGNAL_DATA_GROUP_REPETITION_INTERVAL_NAME "GroupRepetitionInterval"
#define NMEA2000_EXXO_LORAN_C_SIGNAL_DATA_STATION_IDENTIFIER_NAME "StationIdentifier"
#define NMEA2000_EXXO_LORAN_C_RANGE_DATA_GROUP_REPETITION_INTERVAL_NAME "GroupRepetitionInterval"
#define NMEA2000_EXXO_LORAN_C_RANGE_DATA_MASTER_RANGE_NAME "MasterRange"
#define NMEA2000_EXXO_LORAN_C_RANGE_DATA_V_SECOND_RANGE_NAME "VSecondRange"
#define NMEA2000_EXXO_LORAN_C_RANGE_DATA_W_SECOND_RANGE_NAME "WSecondRange"
#define NMEA2000_EXXO_LORAN_C_RANGE_DATA_X_SECOND_RANGE_NAME "XSecondRange"
#define NMEA2000_EXXO_LORAN_C_RANGE_DATA_Y_SECOND_RANGE_NAME "YSecondRange"
#define NMEA2000_EXXO_LORAN_C_RANGE_DATA_Z_SECOND_RANGE_NAME "ZSecondRange"
#define NMEA2000_EXXO_LORAN_C_RANGE_DATA_STATION_STATUS_MASTER_NAME "StationStatusMaster"
#define NMEA2000_EXXO_LORAN_C_RANGE_DATA_STATION_STATUS_V_NAME "StationStatusV"
#define NMEA2000_EXXO_LORAN_C_RANGE_DATA_STATION_STATUS_W_NAME "StationStatusW"
#define NMEA2000_EXXO_LORAN_C_RANGE_DATA_STATION_STATUS_X_NAME "StationStatusX"
#define NMEA2000_EXXO_LORAN_C_RANGE_DATA_STATION_STATUS_Y_NAME "StationStatusY"
#define NMEA2000_EXXO_LORAN_C_RANGE_DATA_STATION_STATUS_Z_NAME "StationStatusZ"
#define NMEA2000_EXXO_LORAN_C_RANGE_DATA_MODE_NAME "Mode"
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_RUDDER_LIMIT_EXCEEDED_NAME "RudderLimitExceeded"
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_OFF_HEADING_LIMIT_EXCEEDED_NAME "OffHeadingLimitExceeded"
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_OFF_TRACK_LIMIT_EXCEEDED_NAME "OffTrackLimitExceeded"
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_OVERRIDE_NAME "Override"
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_STEER_MODE_NAME "SteerMode"
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_TURN_MODE_NAME "TurnMode"
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_HEADING_REFERENCE_NAME "HeadingReference"
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_CMDED_RUDDER_DIRECTION_NAME "CmdedRudderDirection"
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_CMDED_RUDDER_ANGLE_NAME "CmdedRudderAngle"
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_HEADING_TO_STEER_NAME "HeadingToSteer"
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_TRACK_NAME "Track"
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_RUDDER_LIMIT_NAME "RudderLimit"
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_OFF_HEADING_LIMIT_NAME "OffHeadingLimit"
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_RADIUS_OF_TURNDER_NAME "RadiusOfTurnder"
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_RATE_OF_TURNDER_NAME "RateOfTurnder"
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_OFF_TRACK_LIMIT_NAME "OffTrackLimit"
#define NMEA2000_EXXO_HEADING_TRACK_CTRL_VESSEL_HEADING_NAME "VesselHeading"
#define NMEA2000_EXXO_GPS_ALMANAC_DATA_PRN_NAME "PRN"
#define NMEA2000_EXXO_GPS_ALMANAC_DATA_GPS_WEEK_NUMBER_NAME "GPSWeekNumber"
#define NMEA2000_EXXO_GPS_ALMANAC_DATA_SV_HEALTH_BITS_NAME "SVHealthBits"
#define NMEA2000_EXXO_GPS_ALMANAC_DATA_ECCENTRICITY_NAME "Eccentricity"
#define NMEA2000_EXXO_GPS_ALMANAC_DATA_ALMANAC_REFERENCE_TIME_NAME "AlmanacReferenceTime"
#define NMEA2000_EXXO_GPS_ALMANAC_DATA_INCLINATION_ANGLE_NAME "InclinationAngle"
#define NMEA2000_EXXO_GPS_ALMANAC_DATA_RATE_OF_RIGHT_ASCENSION_NAME "RateOfRightAscension"
#define NMEA2000_EXXO_GPS_ALMANAC_DATA_ROOT_OF_SEMIMAJOR_AXIS_NAME "RootOfSemimajorAxis"
#define NMEA2000_EXXO_GPS_ALMANAC_DATA_ARGUMENT_OF_PERIGEE_NAME "ArgumentOfPerigee"
#define NMEA2000_EXXO_GPS_ALMANAC_DATA_LONGITUDE_OF_ASCENSION_NODE_NAME "LongitudeOfAscensionNode"
#define NMEA2000_EXXO_GPS_ALMANAC_DATA_MEAN_ANOMALY_NAME "MeanAnomaly"
#define NMEA2000_EXXO_GPS_ALMANAC_DATA_CLOCK_PARAMETER1_NAME "ClockParameter1"
#define NMEA2000_EXXO_GPS_ALMANAC_DATA_CLOCK_PARAMETER2_NAME "ClockParameter2"
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_SID_NAME "SID"
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_RANGE_RESIDUAL_MODE_NAME "RangeResidualMode"
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_NUMBER_OF_S_VS__NAME "NumberOfSVs_"
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_PRN1_NAME "PRN1"
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_ELEVATION1_NAME "Elevation1"
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_AZIMUTH1_NAME "Azimuth1"
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_SNR1_NAME "SNR1"
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_RANGE_RESIDUALS1_NAME "RangeResiduals1"
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_PRN_STATUS1_NAME "PRNStatus1"
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_PRNN_NAME "PRNN"
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_ELEVATION_N_NAME "ElevationN"
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_AZIMUTH_N_NAME "AzimuthN"
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_SNRN_NAME "SNRN"
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_RANGE_RESIDUALS_N_NAME "RangeResidualsN"
#define NMEA2000_EXXO_GNSS_SATS_IN_VIEW_PRN_STATUS_N_NAME "PRNStatusN"
#define NMEA2000_EXXO_GNSSRAIM_SETTINGS_RADIAL_POS_ERROR_MAX_THRESHOLD_NAME "RadialPosErrorMaxThreshold"
#define NMEA2000_EXXO_GNSSRAIM_SETTINGS_PROBABILITY_OF_FALSE_ALARM_NAME "ProbabilityOfFalseAlarm"
#define NMEA2000_EXXO_GNSSRAIM_SETTINGS_PROBABILITY_OF_MISSED_DETECTION_NAME "ProbabilityOfMissedDetection"
#define NMEA2000_EXXO_GNSSRAIM_SETTINGS_PSDRNG_RSDL_FILTERING_TIME_CONSTANT_NAME "PsdrngRsdlFilteringTimeConstant"
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_SID_NAME "SID"
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_BEARING_REF_NAME "BearingRef"
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_CALCULATION_TYPE_NAME "CalculationType"
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_BEARINGIGIN_TO_DESTINATION_NAME "BearingiginToDestination"
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_DISTANCE_NAME "Distance"
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_ORIGIN_MARK_TYPE_NAME "OriginMarkType"
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_DESTINATION_MARK_TYPE_NAME "DestinationMarkType"
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_ORIGIN_MARK_ID_NAME "OriginMarkId"
#define NMEA2000_EXXO_BRING_AND_DISTANCE_BETWEEN_TWO_MARKS_DESTINATION_MARK_ID_NAME "DestinationMarkID"
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDICATOR_BANK_INSTANCE_NAME "IndicatorBankInstance"
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC1_NAME "Indic1"
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC2_NAME "Indic2"
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC3_NAME "Indic3"
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC4_NAME "Indic4"
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC5_NAME "Indic5"
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC6_NAME "Indic6"
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC7_NAME "Indic7"
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC8_NAME "Indic8"
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC9_NAME "Indic9"
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC10_NAME "Indic10"
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC11_NAME "Indic11"
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC12_NAME "Indic12"
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC13_NAME "Indic13"
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC14_NAME "Indic14"
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC15_NAME "Indic15"
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC16_NAME "Indic16"
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC17_NAME "Indic17"
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC18_NAME "Indic18"
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC19_NAME "Indic19"
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC20_NAME "Indic20"
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC21_NAME "Indic21"
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC22_NAME "Indic22"
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC23_NAME "Indic23"
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC24_NAME "Indic24"
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC25_NAME "Indic25"
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC26_NAME "Indic26"
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC27_NAME "Indic27"
#define NMEA2000_EXXO_BINARY_SWITCH_BANK_STATUS_INDIC28_NAME "Indic28"
#define NMEA2000_EXXO_BATTERY_STATUS_BATTERY_INSTANCE_NAME "BatteryInstance"
#define NMEA2000_EXXO_BATTERY_STATUS_BATTERY_POTENTIAL_NAME "BatteryPotential"
#define NMEA2000_EXXO_BATTERY_STATUS_BATTERY_CURRENT_NAME "BatteryCurrent"
#define NMEA2000_EXXO_BATTERY_STATUS_BATTERY_CASE_TEMP_NAME "BatteryCaseTemp"
#define NMEA2000_EXXO_BATTERY_STATUS_SID_NAME "SID"
#define NMEA2000_EXXO_ATTITUDE_SID_NAME "SID"
#define NMEA2000_EXXO_ATTITUDE_YAW_NAME "Yaw"
#define NMEA2000_EXXO_ATTITUDE_PITCH__NAME "Pitch_"
#define NMEA2000_EXXO_ATTITUDE_ROLL_NAME "Roll"
#define NMEA2000_EXXO_ALTTD_DLT_HGH_PRECISION_RAPID_UPDATE_SEQUENCE_ID__NAME "SequenceID_"
#define NMEA2000_EXXO_ALTTD_DLT_HGH_PRECISION_RAPID_UPDATE_TIME_DELTA_NAME "TimeDelta"
#define NMEA2000_EXXO_ALTTD_DLT_HGH_PRECISION_RAPID_UPDATE_GNSS_QUALITY_NAME "GNSSQuality"
#define NMEA2000_EXXO_ALTTD_DLT_HGH_PRECISION_RAPID_UPDATE_DIRECTION_NAME "Direction"
#define NMEA2000_EXXO_ALTTD_DLT_HGH_PRECISION_RAPID_UPDATE_COURSE_OVER_GROUND_NAME "CourseOverGround"
#define NMEA2000_EXXO_ALTTD_DLT_HGH_PRECISION_RAPID_UPDATE_ALTITUDE_DELTA_NAME "AltitudeDelta"
#define NMEA2000_EXXO_AISUTC_DATE_INQUIRY_MSG_ID_NAME "MsgID"
#define NMEA2000_EXXO_AISUTC_DATE_INQUIRY_REPEAT_INDICATOR_NAME "RepeatIndicator"
#define NMEA2000_EXXO_AISUTC_DATE_INQUIRY_SOURCE_ID_NAME "SourceID"
#define NMEA2000_EXXO_AISUTC_DATE_INQUIRY_AIS_TRANSCEIVER_INFORMATION_NAME "AISTransceiverInformation"
#define NMEA2000_EXXO_AISUTC_DATE_INQUIRY_DESTINATION_ID_NAME "DestinationID"
#define NMEA2000_EXXO_AISUTC_AND_DATE_REPORT_MSG_ID_NAME "MsgID"
#define NMEA2000_EXXO_AISUTC_AND_DATE_REPORT_REPEAT_INDICATOR_NAME "RepeatIndicator"
#define NMEA2000_EXXO_AISUTC_AND_DATE_REPORT_USER_ID_NAME "UserID"
#define NMEA2000_EXXO_AISUTC_AND_DATE_REPORT_LONGITUDE__NAME "Longitude_"
#define NMEA2000_EXXO_AISUTC_AND_DATE_REPORT_LATITUDE__NAME "Latitude_"
#define NMEA2000_EXXO_AISUTC_AND_DATE_REPORT_POS_ACCURACY_NAME "PosAccuracy"
#define NMEA2000_EXXO_AISUTC_AND_DATE_REPORT_RAI_MFLAG_NAME "RAIMflag"
#define NMEA2000_EXXO_AISUTC_AND_DATE_REPORT_POS_TIME_NAME "PosTime"
#define NMEA2000_EXXO_AISUTC_AND_DATE_REPORT_COMMUNICATION_STATE_NAME "CommunicationState"
#define NMEA2000_EXXO_AISUTC_AND_DATE_REPORT_AIS_TRANSCEIVER_INFORMATION_NAME "AISTransceiverInformation"
#define NMEA2000_EXXO_AISUTC_AND_DATE_REPORT_POS_DATE_NAME "PosDate"
#define NMEA2000_EXXO_AISUTC_AND_DATE_REPORT_TYPE_OF_ELECTRONIC_POSING_DEVICE_NAME "TypeOfElectronicPosingDevice"
#define NMEA2000_EXXO_AIS_SAFETY_RELATED_BROADCAST_MSG_MSG_ID_NAME "MsgID"
#define NMEA2000_EXXO_AIS_SAFETY_RELATED_BROADCAST_MSG_REPEAT_INDICATOR_NAME "RepeatIndicator"
#define NMEA2000_EXXO_AIS_SAFETY_RELATED_BROADCAST_MSG_SOURCE_ID_NAME "SourceID"
#define NMEA2000_EXXO_AIS_SAFETY_RELATED_BROADCAST_MSG_AIS_TRANSCEIVER_INFORMATION_NAME "AISTransceiverInformation"
#define NMEA2000_EXXO_AIS_SAFETY_RELATED_BROADCAST_MSG_SAFETY_RELATED_TEXT_NAME "SafetyRelatedText"
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_MSG_ID_NAME "MsgID"
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_REPEAT_INDICATOR_NAME "RepeatIndicator"
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_USER_ID_NAME "UserID"
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_LONGITUDE__NAME "Longitude_"
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_LATITUDE__NAME "Latitude_"
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_POS_ACCURACY_NAME "PosAccuracy"
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_RAIM_FLAG_NAME "RAIMFlag"
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_TIME_STAMP_NAME "TimeStamp"
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_COG_NAME "COG"
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_SOG_NAME "SOG"
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_COMMUNICATION_STATE_NAME "CommunicationState"
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_AIS_TRANSCEIVER_INFORMATION_NAME "AISTransceiverInformation"
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_ALTITUDE__NAME "Altitude_"
#define NMEA2000_EXXO_AISSAR_AIRCRAFT_POS_REPORT_DATA_TERMINAL_EQUIPMENT_NAME "DataTerminalEquipment"
#define NMEA2000_EXXO_AIS_INTERROGATION_MSG_ID_NAME "MsgID"
#define NMEA2000_EXXO_AIS_INTERROGATION_REPEAT_INDICATOR_NAME "RepeatIndicator"
#define NMEA2000_EXXO_AIS_INTERROGATION_SOURCE_ID_NAME "SourceID"
#define NMEA2000_EXXO_AIS_INTERROGATION_AIS_TRANSCEIVER_INFORMATION_NAME "AISTransceiverInformation"
#define NMEA2000_EXXO_AIS_INTERROGATION_DESTINATION_ID1_NAME "DestinationID1"
#define NMEA2000_EXXO_AIS_INTERROGATION_MSG_ID11_NAME "MsgID11"
#define NMEA2000_EXXO_AIS_INTERROGATION_SLOT_OFFSET11_NAME "SlotOffset11"
#define NMEA2000_EXXO_AIS_INTERROGATION_MSG_ID12_NAME "MsgID12"
#define NMEA2000_EXXO_AIS_INTERROGATION_SLOT_OFFSET12_NAME "SlotOffset12"
#define NMEA2000_EXXO_AIS_INTERROGATION_DESTINATION_ID2_NAME "DestinationID2"
#define NMEA2000_EXXO_AIS_INTERROGATION_MSG_ID21_NAME "MsgID21"
#define NMEA2000_EXXO_AIS_INTERROGATION_SLOT_OFFSET21_NAME "SlotOffset21"
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_MSG_ID_NAME "MsgID"
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_REPEAT_INDICATOR_NAME "RepeatIndicator"
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_SOURCE_STATION_ID_NAME "SourceStationID"
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_AIS_TRANSCEIVER_INFORMATION_NAME "AISTransceiverInformation"
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_OFFSET_NUMBER1_NAME "OffsetNumber1"
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_NUMBER_OF_SLOTS1_NAME "NumberOfSlots1"
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_TIME_OUT1_NAME "TimeOut1"
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_INCREMENT1_NAME "Increment1"
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_OFFSET_NUMBER2_NAME "OffsetNumber2"
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_NUMBER_OF_SLOTS2_NAME "NumberOfSlots2"
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_TIME_OUT2_NAME "TimeOut2"
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_INCREMENT2_NAME "Increment2"
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_OFFSET_NUMBER3_NAME "OffsetNumber3"
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_NUMBER_OF_SLOTS3_NAME "NumberOfSlots3"
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_TIME_OUT3_NAME "TimeOut3"
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_INCREMENT3_NAME "Increment3"
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_OFFSET_NUMBER4_NAME "OffsetNumber4"
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_NUMBER_OF_SLOTS4_NAME "NumberOfSlots4"
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_TIME_OUT4_NAME "TimeOut4"
#define NMEA2000_EXXO_AIS_DATA_LINK_MANAGEMENT_MSG_INCREMENT4_NAME "Increment4"
#define NMEA2000_EXXO_AISDGNSS_BROADCAST_BINARY_MSG_MSG_ID_NAME "MsgID"
#define NMEA2000_EXXO_AISDGNSS_BROADCAST_BINARY_MSG_REPEAT_INDICATOR_NAME "RepeatIndicator"
#define NMEA2000_EXXO_AISDGNSS_BROADCAST_BINARY_MSG_SOURCE_ID_NAME "SourceID"
#define NMEA2000_EXXO_AISDGNSS_BROADCAST_BINARY_MSG_AIS_TRANSCEIVER_INFORMATION_NAME "AISTransceiverInformation"
#define NMEA2000_EXXO_AISDGNSS_BROADCAST_BINARY_MSG_LONGITUDE__NAME "Longitude_"
#define NMEA2000_EXXO_AISDGNSS_BROADCAST_BINARY_MSG_LATITUDE__NAME "Latitude_"
#define NMEA2000_EXXO_AISDGNSS_BROADCAST_BINARY_MSG_NUMBER_OF_BITS_IN_BINARY_DATA_FIELD_NAME "NumberOfBitsInBinaryDataField"
#define NMEA2000_EXXO_AIS_CLSS_A_STTC_AND_VYAGE_RELATED_DATA_MSG_ID_NAME "MsgID"
#define NMEA2000_EXXO_AIS_CLSS_A_STTC_AND_VYAGE_RELATED_DATA_REPEAT_INDICATOR_NAME "RepeatIndicator"
#define NMEA2000_EXXO_AIS_CLSS_A_STTC_AND_VYAGE_RELATED_DATA_USER_ID_NAME "UserID"
#define NMEA2000_EXXO_AIS_CLSS_A_STTC_AND_VYAGE_RELATED_DATA_IMO_NAME "IMO"
#define NMEA2000_EXXO_AIS_CLSS_A_STTC_AND_VYAGE_RELATED_DATA_CALL_SIGN_NAME "CallSign"
#define NMEA2000_EXXO_AIS_CLSS_A_STTC_AND_VYAGE_RELATED_DATA_NAME_NAME "Name"
#define NMEA2000_EXXO_AIS_CLSS_A_STTC_AND_VYAGE_RELATED_DATA_DESTINATION_NAME "Destination"
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_MSG_ID_NAME "MsgID"
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_REPEAT_INDICATOR_NAME "RepeatIndicator"
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_USER_ID_NAME "UserID"
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_LONGITUDE__NAME "Longitude_"
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_LATITUDE__NAME "Latitude_"
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_POS_ACCURACY_NAME "PosAccuracy"
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_RAI_MFLAG_NAME "RAIMflag"
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_TIME_STAMP_NAME "TimeStamp"
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_COG_NAME "COG"
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_SOG_NAME "SOG"
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_COMMUNICATION_STATE_NAME "CommunicationState"
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_AIS_TRANSCEIVER_INFORMATION_NAME "AISTransceiverInformation"
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_TRUE_HEADING_NAME "TrueHeading"
#define NMEA2000_EXXO_AIS_CLASS_B_POS_REPORT_COMMINICATION_STATE_SELECTOR_FLAG_NAME "ComminicationStateSelectorFlag"
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_MSG_ID_NAME "MsgID"
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_REPEAT_INDICATOR_NAME "RepeatIndicator"
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_USER_ID_NAME "UserID"
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_LONGITUDE__NAME "Longitude_"
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_LATITUDE__NAME "Latitude_"
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_POS_ACCURACY_NAME "PosAccuracy"
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_RAI_MFLAG_NAME "RAIMflag"
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_TIME_STAMP_NAME "TimeStamp"
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_COG_NAME "COG"
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_SOG_NAME "SOG"
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_SHIP_CARGO_TYPE_NAME "Ship_CargoType"
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_TRUE_HEADING_NAME "TrueHeading"
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_TYPE_OF_ELECTRONIC_POSING_DEVICE_NAME "TypeOfElectronicPosingDevice"
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_SHIP_LENGTH_NAME "ShipLength"
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_SHIP_BEAM_NAME "ShipBeam"
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_POS_REFERENCE_POINT_FROM_STARBOARD_NAME "PosReferencePointFromStarboard"
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_POS_REFERENCE_POINT_AFT_OF_SHIPS_BOW_NAME "PosReferencePointAftOfShipsBow"
#define NMEA2000_EXXO_AIS_CLASS_B_EX_POS_REPORT_NAME_NAME "Name"
#define NMEA2000_EXXO_CA_IDENTITY_NUMBER_NAME "IdentityNumber"
#define NMEA2000_EXXO_CA_MANUFACTURER_CODE_NAME "ManufacturerCode"
#define NMEA2000_EXXO_CA_ECU_INSTANCE_NAME "ECUInstance"
#define NMEA2000_EXXO_CA_FUNCTION_INSTANCE_NAME "FunctionInstance"
#define NMEA2000_EXXO_CA_FUNCTION_NAME "Function"
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM_NAME "VehicleSystem"
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM5_NAME "VehicleSystem5"
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM4_NAME "VehicleSystem4"
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM3_NAME "VehicleSystem3"
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM2_NAME "VehicleSystem2"
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM1_NAME "VehicleSystem1"
#define NMEA2000_EXXO_CA_VEHICLE_SYSTEM_INSTANCE_NAME "VehicleSystemInstance"
#define NMEA2000_EXXO_CA_INDUSTRY_GROUP_NAME "IndustryGroup"
#define NMEA2000_EXXO_CA_ARBITRARY_ADDRESS_CAPABLE_NAME "ArbitraryAddressCapable"
#define NMEA2000_EXXO_CA_ADDRESS_ASSIGNMENT_NAME "AddressAssignment"
#define NMEA2000_EXXO_ACL_IDENTITY_NUMBER_NAME "IdentityNumber"
#define NMEA2000_EXXO_ACL_MANUFACTURER_CODE_NAME "ManufacturerCode"
#define NMEA2000_EXXO_ACL_ECU_INSTANCE_NAME "ECUInstance"
#define NMEA2000_EXXO_ACL_FUNCTION_INSTANCE_NAME "FunctionInstance"
#define NMEA2000_EXXO_ACL_FUNCTION_NAME "Function"
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM_NAME "VehicleSystem"
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM5_NAME "VehicleSystem5"
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM4_NAME "VehicleSystem4"
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM3_NAME "VehicleSystem3"
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM2_NAME "VehicleSystem2"
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM1_NAME "VehicleSystem1"
#define NMEA2000_EXXO_ACL_VEHICLE_SYSTEM_INSTANCE_NAME "VehicleSystemInstance"
#define NMEA2000_EXXO_ACL_INDUSTRY_GROUP_NAME "IndustryGroup"
#define NMEA2000_EXXO_ACL_ARBITRARY_ADDRESS_CAPABLE_NAME "ArbitraryAddressCapable"
#define NMEA2000_EXXO_TPDT_SEQUENCE_NUMBER_NAME "SequenceNumber"
#define NMEA2000_EXXO_TPCM_CONTROL_BYTE_NAME "ControlByte"
#define NMEA2000_EXXO_TPCM_TOTAL_MESSAGE_SIZE_EO_MA_NAME "TotalMessageSizeEoMA"
#define NMEA2000_EXXO_TPCM_TOTAL_MESSAGE_SIZE_BAM_NAME "TotalMessageSizeBAM"
#define NMEA2000_EXXO_TPCM_CONNECTION_ABORT_REASON_NAME "ConnectionAbortReason"
#define NMEA2000_EXXO_TPCM_NUMBER_OF_PACKETS_THAT_CAN_BE_SENT_NAME "NumberOfPacketsThatCanBeSent"
#define NMEA2000_EXXO_TPCM_TOTAL_MESSAGE_SIZE_NAME "TotalMessageSize"
#define NMEA2000_EXXO_TPCM_NEXT_PACKET_NUMBER_TO_BE_SENT_NAME "NextPacketNumberToBeSent"
#define NMEA2000_EXXO_TPCM_TOTAL_NUMBER_OF_PACKETS_EO_MA_NAME "TotalNumberOfPacketsEoMA"
#define NMEA2000_EXXO_TPCM_TOTAL_NUMBER_OF_PACKETS_BAM_NAME "TotalNumberOfPacketsBAM"
#define NMEA2000_EXXO_TPCM_TOTAL_NUMBER_OF_PACKETS_NAME "TotalNumberOfPackets"
#define NMEA2000_EXXO_TPCM_MAXIMUM_NUMBER_OF_PACKETS_NAME "MaximumNumberOfPackets"
#define NMEA2000_EXXO_TPCM_PG_NUMBER_NAME "PGNumber"
#define NMEA2000_EXXO_RQST_PARAMETER_GROUP_NUMBER_NAME "ParameterGroupNumber"
#define NMEA2000_EXXO_WIND_DATA_SEQUENCE_ID__NAME "SequenceID_"
#define NMEA2000_EXXO_WIND_DATA_WIND_SPEED_NAME "WindSpeed"
#define NMEA2000_EXXO_WIND_DATA_WIND_DIRECTION_NAME "WindDirection"
#define NMEA2000_EXXO_WIND_DATA_WIND_REFERENCE_NAME "WindReference"
#define NMEA2000_EXXO_WATER_DEPTH_SID_NAME "SID"
#define NMEA2000_EXXO_WATER_DEPTH_WATER_DEPTH_TRANSDUCER_NAME "WaterDepthTransducer"
#define NMEA2000_EXXO_WATER_DEPTH_OFFSET_NAME "Offset"
#define NMEA2000_EXXO_VESSEL_SPEED_COMPONENTS_LNGITUDINAL_SPEED_WATERREFERENCED_NAME "LngitudinalSpeedWaterreferenced"
#define NMEA2000_EXXO_VESSEL_SPEED_COMPONENTS_TRANSVERSE_SPEED_WATERREFERENCED_NAME "TransverseSpeedWaterreferenced"
#define NMEA2000_EXXO_VESSEL_SPEED_COMPONENTS_LNGTUDINAL_SPEED_GROUNDREFERENCED_NAME "LngtudinalSpeedGroundreferenced"
#define NMEA2000_EXXO_VESSEL_SPEED_COMPONENTS_TRANSVERSE_SPEED_GROUNDREFERENCED_NAME "TransverseSpeedGroundreferenced"
#define NMEA2000_EXXO_VESSEL_SPEED_COMPONENTS_STERN_SPEED_WATERREFERENCED_NAME "SternSpeedWaterreferenced"
#define NMEA2000_EXXO_VESSEL_SPEED_COMPONENTS_STERN_SPEED_GROUNDREFERENCED_NAME "SternSpeedGroundreferenced"
#define NMEA2000_EXXO_VESSEL_HEADING_SID_NAME "SID"
#define NMEA2000_EXXO_VESSEL_HEADING_HEADING_SENSOR_READING_NAME "HeadingSensorReading"
#define NMEA2000_EXXO_VESSEL_HEADING_DEVIATION_NAME "Deviation"
#define NMEA2000_EXXO_VESSEL_HEADING_VARIATION_NAME "Variation"
#define NMEA2000_EXXO_VESSEL_HEADING_HEADING_SENSOR_REFERENCE_NAME "HeadingSensorReference"
#define NMEA2000_EXXO_TRIP_PARAMETERS_VESSEL_TIME_TO_EMPTY_NAME "TimeToEmpty"
#define NMEA2000_EXXO_TRIP_PARAMETERS_VESSEL_DISTANCE_TO_EMPTY_NAME "DistanceToEmpty"
#define NMEA2000_EXXO_TRIP_PARAMETERS_VESSEL_EST_FUEL_REMAINING_NAME "EstFuelRemaining"
#define NMEA2000_EXXO_TRIP_PARAMETERS_VESSEL_TRIP_RUN_TIME_NAME "TripRunTime"
#define NMEA2000_EXXO_TRIP_PARAMETERS_ENG_ENG_INSTANCE_NAME "EngInstance"
#define NMEA2000_EXXO_TRIP_PARAMETERS_ENG_TRIP_FUEL_USED_NAME "TripFuelUsed"
#define NMEA2000_EXXO_TRIP_PARAMETERS_ENG_FUEL_RATE_AVERAGE_NAME "FuelRateAverage"
#define NMEA2000_EXXO_TRIP_PARAMETERS_ENG_FUEL_RATE_ECONOMY_NAME "FuelRateEconomy"
#define NMEA2000_EXXO_TRIP_PARAMETERS_ENG_INSTANTANEOUS_FUEL_ECONOMY_NAME "InstantaneousFuelEconomy"
#define NMEA2000_EXXO_TRANS_PARAMETERS_DYNAMIC_TRANS_INSTANCE_NAME "TransInstance"
#define NMEA2000_EXXO_TRANS_PARAMETERS_DYNAMIC_TRANS_GEAR_NAME "TransGear"
#define NMEA2000_EXXO_TRANS_PARAMETERS_DYNAMIC_TRANS_OIL_PRESS__NAME "TransOilPress_"
#define NMEA2000_EXXO_TRANS_PARAMETERS_DYNAMIC_TRANS_OIL_TEMP__NAME "TransOilTemp_"
#define NMEA2000_EXXO_TRANS_PARAMETERS_DYNAMIC_TRANS_DISCRETE_STATUS_NAME "TransDiscreteStatus"
#define NMEA2000_EXXO_TRACKED_TARGET_DATA_SEQUENCE_ID__NAME "SequenceID_"
#define NMEA2000_EXXO_TRACKED_TARGET_DATA_TARGET_ID_NAME "TargetID"
#define NMEA2000_EXXO_TRACKED_TARGET_DATA_TRACK_STATUS_NAME "TrackStatus"
#define NMEA2000_EXXO_TRACKED_TARGET_DATA_BEARING_REFERENCE_NAME "BearingReference"
#define NMEA2000_EXXO_TRACKED_TARGET_DATA_BEARING_NAME "Bearing"
#define NMEA2000_EXXO_TRACKED_TARGET_DATA_DISTANCE_NAME "Distance"
#define NMEA2000_EXXO_TRACKED_TARGET_DATA_COURSE_NAME "Course"
#define NMEA2000_EXXO_TRACKED_TARGET_DATA_SPEED_NAME "Speed"
#define NMEA2000_EXXO_TRACKED_TARGET_DATA_CPA_NAME "CPA"
#define NMEA2000_EXXO_TRACKED_TARGET_DATA_TCPA_NAME "TCPA"
#define NMEA2000_EXXO_TRACKED_TARGET_DATA_UTC_OF_FIX_NAME "UTCOfFix"
#define NMEA2000_EXXO_TRACKED_TARGET_DATA_NAME_NAME "Name"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_WP_LIST_WP_NAME_POS_START_WPID_NAME "StartWPID"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_WP_LIST_WP_NAME_POS_N_ITEMS_NAME "nItems"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_WP_LIST_WP_NAME_POS_NUMBER_OF_VALID_W_PS_IN_WP_LIST_NAME "NumberOfValidWPsInWPList"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_WP_LIST_WP_NAME_POS_DATABASE_ID_NAME "DatabaseID"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_WP_LIST_WP_NAME_POS_RESERVED_NAME "reserved"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_WP_LIST_WP_NAME_POS_WPID_NAME "WPID"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_WP_LIST_WP_NAME_POS_WP_NAME_NAME "WPName"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_DATABASE_COMMENT_START_DATABASE_ID_NAME "StartDatabaseID"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_DATABASE_COMMENT_N_ITEMS_NAME "nItems"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_DATABASE_COMMENT_NUMBER_OF_DATABASES_WITH_COMMENTS_NAME "NumberOfDatabasesWithComments"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_DATABASE_COMMENT_DATABASE_ID_NAME "DatabaseID"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_DATABASE_COMMENT_COMMENT_TEXT_NAME "CommentText"
#define NMEA2000_EXXO_RUDDER_RUDDER_INSTANCE_NAME "RudderInstance"
#define NMEA2000_EXXO_RUDDER_DIRECTIONDER_NAME "Directionder"
#define NMEA2000_EXXO_RUDDER_ANGLEDER_NAME "Angleder"
#define NMEA2000_EXXO_RUDDER_POS_NAME "Pos"
#define NMEA2000_EXXO_RT_AND_WP_SRVC_XTE_LMT_NVGATION_METHOD_START_RPS_NAME "StartRPS"
#define NMEA2000_EXXO_RT_AND_WP_SRVC_XTE_LMT_NVGATION_METHOD_N_ITEMS_NAME "nItems"
#define NMEA2000_EXXO_RT_AND_WP_SRVC_XTE_LMT_NVGATION_METHOD_NMBR_OF_WYPNTS_WTH_A_SPCFC_XTE_LMT_NV_MTH_NAME "NmbrOfWypntsWthASpcfcXTELmtNvMth"
#define NMEA2000_EXXO_RT_AND_WP_SRVC_XTE_LMT_NVGATION_METHOD_DATABASE_ID_NAME "DatabaseID"
#define NMEA2000_EXXO_RT_AND_WP_SRVC_XTE_LMT_NVGATION_METHOD_ROUTE_ID_NAME "RouteID"
#define NMEA2000_EXXO_RT_AND_WP_SRVC_XTE_LMT_NVGATION_METHOD_RPS_NAME "RPS"
#define NMEA2000_EXXO_RT_AND_WP_SRVC_XTE_LMT_NVGATION_METHOD_XTE_LIMIT_IN_LEG_AFTER_WP_NAME "XTELimitInLegAfterWP"
#define NMEA2000_EXXO_RT_AND_WP_SRVC_XTE_LMT_NVGATION_METHOD_NAV_METHOD_IN_LEG_AFTER_WP_NAME "NavMethodInLegAfterWP"
#define NMEA2000_EXXO_RT_AND_WP_SRVC_RTE_WP_LIST_ATTRIBUTES_DATABASE_ID_NAME "DatabaseID"
#define NMEA2000_EXXO_RT_AND_WP_SRVC_RTE_WP_LIST_ATTRIBUTES_ROUTE_ID_NAME "RouteID"
#define NMEA2000_EXXO_RT_AND_WP_SRVC_RTE_WP_LIST_ATTRIBUTES_ROUTE_WP_LIST_NAME_NAME "Route_WPListName"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_WP_COMMENT_START_ID_NAME "StartID"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_WP_COMMENT_N_ITEMS_NAME "nItems"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_WP_COMMENT_NUMBER_OF_W_PS_WITH_COMMENTS_NAME "NumberOfWPsWithComments"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_WP_COMMENT_DATABASE_ID_NAME "DatabaseID"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_WP_COMMENT_ROUTE_ID_NAME "RouteID"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_WP_COMMENT_WPID_RPS_NAME "WPID_RPS"
#define NMEA2000_EXXO_ROUTE_AND_WP_SERVICE_WP_COMMENT_COMMENT_NAME "Comment"
#define NMEA2000_EXXO_GNSSRAIM_OUTPUT_SEQUENCE_ID__NAME "SequenceID_"
#define NMEA2000_EXXO_GNSSRAIM_OUTPUT_INTEGRITY_FLAG_NAME "IntegrityFlag"
#define NMEA2000_EXXO_GNSSRAIM_OUTPUT_LATITUDE_EXPECTED_ERROR_NAME "LatitudeExpectedError"
#define NMEA2000_EXXO_GNSSRAIM_OUTPUT_LONGITUDE_EXPECTED_ERROR_NAME "LongitudeExpectedError"
#define NMEA2000_EXXO_GNSSRAIM_OUTPUT_ALTITUDE_EXPECTED_ERROR_NAME "AltitudeExpectedError"
#define NMEA2000_EXXO_GNSSRAIM_OUTPUT_SVID_OF_MOST_LIKELY_FAILED_SAT_NAME "SVIDOfMostLikelyFailedSat"
#define NMEA2000_EXXO_GNSSRAIM_OUTPUT_PROBABILITY_OF_MISSED_DETECTION_NAME "ProbabilityOfMissedDetection"
#define NMEA2000_EXXO_GNSSRAIM_OUTPUT_ESTIMATE_OF_PSEUDORANGE_BIAS_NAME "EstimateOfPseudorangeBias"
#define NMEA2000_EXXO_GNSSRAIM_OUTPUT_STD_DEVIATION_OF_BIAS_NAME "StdDeviationOfBias"
#define NMEA2000_EXXO_GNSS_PSEUDORANGE_NOISE_STATISTICS_SID_NAME "SID"
#define NMEA2000_EXXO_GNSS_PSEUDORANGE_NOISE_STATISTICS_RMS_OF_POS_UNCERTAINTY_NAME "RMSOfPosUncertainty"
#define NMEA2000_EXXO_GNSS_PSEUDORANGE_NOISE_STATISTICS_STD_OF_MAJOR_AXIS_NAME "STDOfMajorAxis"
#define NMEA2000_EXXO_GNSS_PSEUDORANGE_NOISE_STATISTICS_STD_OF_MINOR_AXIS_NAME "STDOfMinorAxis"
#define NMEA2000_EXXO_GNSS_PSEUDORANGE_NOISE_STATISTICS_ORIENTATION_OF_MAJOR_AXIS_NAME "OrientationOfMajorAxis"
#define NMEA2000_EXXO_GNSS_PSEUDORANGE_NOISE_STATISTICS_STD_OF_LAT_ERROR_NAME "STDOfLatError"
#define NMEA2000_EXXO_GNSS_PSEUDORANGE_NOISE_STATISTICS_STD_OF_LON_ERROR_NAME "STDOfLonError"
#define NMEA2000_EXXO_GNSS_PSEUDORANGE_NOISE_STATISTICS_STD_OF_ALT_ERROR_NAME "STDOfAltError"
#define NMEA2000_EXXO_GNSS_PSEUDORANGE_ERROR_STATISTICS_SEQUENCE_ID__NAME "SequenceID_"
#define NMEA2000_EXXO_GNSS_PSEUDORANGE_ERROR_STATISTICS_RMS_STD_DEV_OF_RANGE_INPUTS_NAME "RMSStdDevOfRangeInputs"
#define NMEA2000_EXXO_GNSS_PSEUDORANGE_ERROR_STATISTICS_STD_DEV_MAJOR_ERROR_ELLIPSE_NAME "StdDevMajorErrorEllipse"
#define NMEA2000_EXXO_GNSS_PSEUDORANGE_ERROR_STATISTICS_STD_DEV_MINOR_ERROR_ELLIPSE_NAME "StdDevMinorErrorEllipse"
#define NMEA2000_EXXO_GNSS_PSEUDORANGE_ERROR_STATISTICS_ORIENTATION_OF_ERROR_ELLIPSE_NAME "OrientationOfErrorEllipse"
#define NMEA2000_EXXO_GNSS_PSEUDORANGE_ERROR_STATISTICS_STD_DEV_LATITUDE_ERROR_NAME "StdDevLatitudeError"
#define NMEA2000_EXXO_GNSS_PSEUDORANGE_ERROR_STATISTICS_STD_DEV_LONGITUDE_ERROR_NAME "StdDevLongitudeError"
#define NMEA2000_EXXO_GNSS_PSEUDORANGE_ERROR_STATISTICS_STD_DEV_ALTITUDE_ERROR_NAME "StdDevAltitudeError"
#define NMEA2000_EXXO_GNSS_POS_DATA_SID_NAME "SID"
#define NMEA2000_EXXO_GNSS_POS_DATA_POS_DATE_NAME "PosDate"
#define NMEA2000_EXXO_GNSS_POS_DATA_POS_TIME_NAME "PosTime"
#define NMEA2000_EXXO_GNSS_POS_DATA_LATITUDE_LOW_NAME "Latitude_low"
#define NMEA2000_EXXO_GNSS_POS_DATA_LATITUDE_HIGH_NAME "Latitude_high"
#define NMEA2000_EXXO_GNSS_POS_DATA_LONGITUDE_LOW_NAME "Longitude_low"
#define NMEA2000_EXXO_GNSS_POS_DATA_LONGITUDE_HIGH_NAME "Longitude_high"
#define NMEA2000_EXXO_GNSS_POS_DATA_ALTITUDE_LOW_NAME "Altitude_low"
#define NMEA2000_EXXO_GNSS_POS_DATA_ALTITUDE_HIGH_NAME "Altitude_high"
#define NMEA2000_EXXO_GNSS_POS_DATA_TYPE_OF_SYSTEM__NAME "TypeOfSystem_"
#define NMEA2000_EXXO_GNSS_POS_DATA_METHOD_GNSS_NAME "MethodGNSS"
#define NMEA2000_EXXO_GNSS_POS_DATA_INTEGRITY_NAME "Integrity"
#define NMEA2000_EXXO_GNSS_POS_DATA_NUMBER_OF_S_VS__NAME "NumberOfSVs_"
#define NMEA2000_EXXO_GNSS_POS_DATA_HDOP__NAME "HDOP_"
#define NMEA2000_EXXO_GNSS_POS_DATA_PDOP__NAME "PDOP_"
#define NMEA2000_EXXO_GNSS_POS_DATA_GEOIDAL_SEPARATION__NAME "GeoidalSeparation_"
#define NMEA2000_EXXO_GNSS_POS_DATA_NUMBER_OF_REFERENCE_STATIONS__NAME "NumberOfReferenceStations_"
#define NMEA2000_EXXO_GNSS_POS_DATA_REFERENCE_STATION_TYPE1_NAME "ReferenceStationType1"
#define NMEA2000_EXXO_GNSS_POS_DATA_REFERENCE_STATION_ID1__NAME "ReferenceStationID1_"
#define NMEA2000_EXXO_GNSS_POS_DATA_AGE_OF_DGNSS_CORRECTIONS1__NAME "AgeOfDGNSSCorrections1_"
#define NMEA2000_EXXO_GNSS_POS_DATA_REFERENCE_STATION_TYPE_N_NAME "ReferenceStationTypeN"
#define NMEA2000_EXXO_GNSS_POS_DATA_REFERENCE_STATION_IDN_NAME "ReferenceStationIDN"
#define NMEA2000_EXXO_GNSS_POS_DATA_AGE_OF_DGNSS_REFERENCE_STATION_N_NAME "AgeOfDGNSSReferenceStationN"
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_CHANNEL_NAME "Channel"
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_FREQUENCY_NAME "Frequency"
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_SERIAL_INTERFACE_BIT_RATE_NAME "SerialInterfaceBitRate"
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_SERIAL_INTERFACE_DETECTION_MODE_NAME "SerialInterfaceDetectionMode"
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_DIFF_SOURCE_NAME "DiffSource"
#define NMEA2000_EXXO_GNSS_DFF_CRRCTON_RECEIVER_INTERFACE_DIFF_OPERATION_MODE_NAME "DiffOperationMode"
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_SID_NAME "SID"
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_CHANNEL_NAME "Channel"
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_SIGNAL_STRENGTH_NAME "SignalStrength"
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_SIGNAL_SNR_NAME "SignalSNR"
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_FREQUENCY_NAME "Frequency"
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_STATION_TYPE_NAME "StationType"
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_STATION_ID_NAME "StationID"
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_DIFF_SIGNAL_BIT_RATE_NAME "DiffSignalBitRate"
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_DIFF_SIGNAL_DETECTION_MODE_NAME "DiffSignalDetectionMode"
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_USED_AS_CORRECTION_SOURCE_NAME "UsedAsCorrectionSource"
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_DIFF_SOURCE_NAME "DiffSource"
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_TIME_SINCE_LAST_SAT_DIFF_SYNC_NAME "TimeSinceLastSatDiffSync"
#define NMEA2000_EXXO_GNSS_DFF_CORRECTION_RECEIVER_SIGNAL_SATELLITE_SERVICE_ID_NO_NAME "SatelliteServiceIDNo"
#define NMEA2000_EXXO_GNSSDO_PS_SID_NAME "SID"
#define NMEA2000_EXXO_GNSSDO_PS_SET_MODE_NAME "SetMode"
#define NMEA2000_EXXO_GNSSDO_PS_OP_MODE_NAME "OpMode"
#define NMEA2000_EXXO_GNSSDO_PS_HDOP__NAME "HDOP_"
#define NMEA2000_EXXO_GNSSDO_PS_VDOP_NAME "VDOP"
#define NMEA2000_EXXO_GNSSDO_PS_TDOP_NAME "TDOP"
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_SV_ELEVATION_MASK_NAME "SVElevationMask"
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_PDOP_MASK_NAME "PDOPMask"
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_PDOP_SWITCH_NAME "PDOPSwitch"
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_SNR_MASK_NAME "SNRMask"
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_GNSS_MODE_NAME "GNSSMode"
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_DGNSS_MODE_NAME "DGNSSMode"
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_POS_VELOCITY_FILTER_NAME "Pos_VelocityFilter"
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_MAX_CORRECTION_AGE_NAME "MaxCorrectionAge"
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_ANTENNA_ALTITUDE_FOR2_D_MODE_NAME "AntennaAltitudeFor2DMode"
#define NMEA2000_EXXO_GNSS_CTRL_STATUS_USE_ANTENNA_ALTITUDE_FOR2_D_MODE_NAME "UseAntennaAltitudeFor2DMode"
#define NMEA2000_EXXO_GLONASS_ALMANAC_DATA_PRN_NAME "PRN"
#define NMEA2000_EXXO_GLONASS_ALMANAC_DATA_NA_NAME "NA"
#define NMEA2000_EXXO_GLONASS_ALMANAC_DATA_CN_A_NAME "CnA"
#define NMEA2000_EXXO_GLONASS_ALMANAC_DATA_HN_A_NAME "HnA"
#define NMEA2000_EXXO_GLONASS_ALMANAC_DATA_N_A_NAME "nA"
#define NMEA2000_EXXO_GLONASS_ALMANAC_DATA_DOT_NAME "DOT"
#define NMEA2000_EXXO_GLONASS_ALMANAC_DATA_N_A2_NAME "nA2"
#define NMEA2000_EXXO_GLONASS_ALMANAC_DATA_TN_A_NAME "TnA"
#define NMEA2000_EXXO_GLONASS_ALMANAC_DATA_TN_A_NAME "tnA"
#define NMEA2000_EXXO_GLONASS_ALMANAC_DATA_N_A3_NAME "nA3"
#define NMEA2000_EXXO_GLONASS_ALMANAC_DATA_IN_A_NAME "inA"
#define NMEA2000_EXXO_GLONASS_ALMANAC_DATA_TC_A_NAME "tcA"
#define NMEA2000_EXXO_GLONASS_ALMANAC_DATA_TN_A2_NAME "tnA2"
#define NMEA2000_EXXO_FLUID_LEVEL_FLUID_INSTANCE_NAME "FluidInstance"
#define NMEA2000_EXXO_FLUID_LEVEL_FLUID_TYPE_NAME "FluidType"
#define NMEA2000_EXXO_FLUID_LEVEL_FLUID_LEVEL_NAME "FluidLevel"
#define NMEA2000_EXXO_FLUID_LEVEL_TANK_CAPACITY_NAME "TankCapacity"
#define NMEA2000_EXXO_ENVIRONMENTAL_PARAMETERS_SEQUENCE_ID__NAME "SequenceID_"
#define NMEA2000_EXXO_ENVIRONMENTAL_PARAMETERS_WATER_TEMP_NAME "WaterTemp"
#define NMEA2000_EXXO_ENVIRONMENTAL_PARAMETERS_OUTSIDE_AMBIENT_AIR_TEMP_NAME "OutsideAmbientAirTemp"
#define NMEA2000_EXXO_ENVIRONMENTAL_PARAMETERS_ATMOSPHERIC_PRESS_NAME "AtmosphericPress"
#define NMEA2000_EXXO_ENG_PARAMETERS_STATIC_ENG_INSTANCE_NAME "EngInstance"
#define NMEA2000_EXXO_ENG_PARAMETERS_STATIC_RATED_ENG_SPEED_NAME "RatedEngSpeed"
#define NMEA2000_EXXO_ENG_PARAMETERS_STATIC_VIN_NAME "VIN"
#define NMEA2000_EXXO_ENG_PARAMETERS_STATIC_SOFTWARE_ID_NAME "SoftwareID"
#define NMEA2000_EXXO_ENG_PARAMETERS_RAPID_UPDATE_ENG_INSTANCE_NAME "EngInstance"
#define NMEA2000_EXXO_ENG_PARAMETERS_RAPID_UPDATE_ENG_SPEED__NAME "EngSpeed_"
#define NMEA2000_EXXO_ENG_PARAMETERS_RAPID_UPDATE_ENG_BOOST_PRESS_NAME "EngBoostPress"
#define NMEA2000_EXXO_ENG_PARAMETERS_RAPID_UPDATE_ENG_TILT_TRIM_NAME "EngTilt_Trim"
#define NMEA2000_EXXO_ENG_PARAMETERS_DYNAMIC_ENG_INSTANCE_NAME "EngInstance"
#define NMEA2000_EXXO_ENG_PARAMETERS_DYNAMIC_ENG_OIL_PRESS__NAME "EngOilPress_"
#define NMEA2000_EXXO_ENG_PARAMETERS_DYNAMIC_ENG_OIL_TEMP_NAME "EngOilTemp"
#define NMEA2000_EXXO_ENG_PARAMETERS_DYNAMIC_ENG_TEMP_NAME "EngTemp"
#define NMEA2000_EXXO_ENG_PARAMETERS_DYNAMIC_ALT_POTENTIAL_NAME "AltPotential"
#define NMEA2000_EXXO_ENG_PARAMETERS_DYNAMIC_FUEL_RATE_NAME "FuelRate"
#define NMEA2000_EXXO_ENG_PARAMETERS_DYNAMIC_TOTAL_ENG_HOURS_NAME "TotalEngHours"
#define NMEA2000_EXXO_ENG_PARAMETERS_DYNAMIC_ENG_COOLANT_PRESS__NAME "EngCoolantPress_"
#define NMEA2000_EXXO_ENG_PARAMETERS_DYNAMIC_FUEL_PRESS_NAME "FuelPress"
#define NMEA2000_EXXO_ENG_PARAMETERS_DYNAMIC_ENG_DISCRETE_STATUS1_NAME "EngDiscreteStatus1"
#define NMEA2000_EXXO_ENG_PARAMETERS_DYNAMIC_ENG_DISCRETE_STATUS2_NAME "EngDiscreteStatus2"
#define NMEA2000_EXXO_ENG_PARAMETERS_DYNAMIC_PERCENT_ENG_LOAD_NAME "PercentEngLoad"
#define NMEA2000_EXXO_ENG_PARAMETERS_DYNAMIC_PERCENT_ENG_TORQUE_NAME "PercentEngTorque"
#define NMEA2000_EXXO_DISTANCE_LOG_MEASUREMENT_DATE_NAME "MeasurementDate"
#define NMEA2000_EXXO_DISTANCE_LOG_MEASUREMENT_TIME_NAME "MeasurementTime"
#define NMEA2000_EXXO_DISTANCE_LOG_TOTAL_CUMULATIVE_DISTANCE_NAME "TotalCumulativeDistance"
#define NMEA2000_EXXO_DISTANCE_LOG_DISTANCE_SINCE_LAST_RESET_NAME "DistanceSinceLastReset"
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_MSG_ID_NAME "MsgID"
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_REPEAT_INDICATOR_NAME "RepeatIndicator"
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_USER_ID_NAME "UserID"
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_LONGITUDE__NAME "Longitude_"
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_LATITUDE__NAME "Latitude_"
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_POS_ACCURACY_NAME "PosAccuracy"
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_RAI_MFLAG_NAME "RAIMflag"
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_TIME_STAMP_NAME "TimeStamp"
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_COG_NAME "COG"
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_SOG_NAME "SOG"
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_COMMUNICATION_STATE_NAME "CommunicationState"
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_AIS_TRANSCEIVER_INFORMATION_NAME "AISTransceiverInformation"
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_TRUE_HEADING_NAME "TrueHeading"
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_RATE_OF_TURN_NAME "RateOfTurn"
#define NMEA2000_EXXO_AIS_CLASS_A_POS_REPORT_NAVIGATIONAL_STATUS_NAME "NavigationalStatus"
#define NMEA2000_EXXO_AIS_BINARY_BROADCAST_MSG_MSG_ID_NAME "MsgID"
#define NMEA2000_EXXO_AIS_BINARY_BROADCAST_MSG_REPEAT_INDICATOR_NAME "RepeatIndicator"
#define NMEA2000_EXXO_AIS_BINARY_BROADCAST_MSG_SOURCE_ID_NAME "SourceID"
#define NMEA2000_EXXO_AIS_BINARY_BROADCAST_MSG_AIS_TRANSCEIVER_INFORMATION_NAME "AISTransceiverInformation"
#define NMEA2000_EXXO_AIS_BINARY_BROADCAST_MSG_NUMBER_OF_BITS_IN_BINARY_DATA_FIELD_NAME "NumberOfBitsInBinaryDataField"
#define NMEA2000_EXXO_AIS_ASSIGNMENT_MODE_CMD_MSG_ID_NAME "MsgID"
#define NMEA2000_EXXO_AIS_ASSIGNMENT_MODE_CMD_REPEAT_INDICATOR_NAME "RepeatIndicator"
#define NMEA2000_EXXO_AIS_ASSIGNMENT_MODE_CMD_SOURCE_ID_NAME "SourceID"
#define NMEA2000_EXXO_AIS_ASSIGNMENT_MODE_CMD_AIS_TRANSCEIVER_INFORMATION_NAME "AISTransceiverInformation"
#define NMEA2000_EXXO_AIS_ASSIGNMENT_MODE_CMD_DESTINATION_IDA_NAME "DestinationIDA"
#define NMEA2000_EXXO_AIS_ASSIGNMENT_MODE_CMD_OFFSET_A_NAME "OffsetA"
#define NMEA2000_EXXO_AIS_ASSIGNMENT_MODE_CMD_INCREMENT_A_NAME "IncrementA"
#define NMEA2000_EXXO_AIS_ASSIGNMENT_MODE_CMD_DESTINATION_IDB_NAME "DestinationIDB"
#define NMEA2000_EXXO_AIS_ASSIGNMENT_MODE_CMD_OFFSET_B_NAME "OffsetB"
#define NMEA2000_EXXO_AIS_ASSIGNMENT_MODE_CMD_INCREMENT_B_NAME "IncrementB"
#define NMEA2000_EXXO_ACKM_CONTROL_BYTE_NAME "ControlByte"
#define NMEA2000_EXXO_ACKM_GROUP_FUNCTION_VALUE_NAME "GroupFunctionValue"
#define NMEA2000_EXXO_ACKM_ADDRESS_BUSY_NAME "AddressBusy"
#define NMEA2000_EXXO_ACKM_ADDRESS_ACCESS_DENIED_NAME "AddressAccessDenied"
#define NMEA2000_EXXO_ACKM_ADDRESS_NEGATIVE_ACKNOWLEDGEMENT_NAME "AddressNegativeAcknowledgement"
#define NMEA2000_EXXO_ACKM_ADDRESS_ACKNOWLEDGED_NAME "AddressAcknowledged"
#define NMEA2000_EXXO_ACKM_PARAMETER_GROUP_NUMBER_NAME "ParameterGroupNumber"
#define NMEA2000_EXXO_DIRECTION_DATA_DATA_MODE_NAME "DataMode"
#define NMEA2000_EXXO_DIRECTION_DATA_SET_COG_HEADING_REF_NAME "Set_COG_HeadingRef"
#define NMEA2000_EXXO_DIRECTION_DATA_SID_NAME "SID"
#define NMEA2000_EXXO_DIRECTION_DATA_COURSE_OVER_GROUND_NAME "CourseOverGround"
#define NMEA2000_EXXO_DIRECTION_DATA_SPEED_OVER_GROUND_NAME "SpeedOverGround"
#define NMEA2000_EXXO_DIRECTION_DATA_HEADING_NAME "Heading"
#define NMEA2000_EXXO_DIRECTION_DATA_SPEED_THROUGH_WATER_NAME "SpeedThroughWater"
#define NMEA2000_EXXO_DIRECTION_DATA_SET_NAME "Set"
#define NMEA2000_EXXO_DIRECTION_DATA_DRIFT_NAME "Drift"
#define NMEA2000_EXXO_DATUM_LOCAL_DATUM_NAME "LocalDatum"
#define NMEA2000_EXXO_DATUM_REFERENCE_DATUM_NAME "ReferenceDatum"
#define NMEA2000_EXXO_DSC_CALL_INFORMATION_DSC_FORMAT_SYMBOL_NAME "DSCFormatSymbol"
#define NMEA2000_EXXO_DSC_CALL_INFORMATION_DSC_CATEGORY_SYMBOL_NAME "DSCCategorySymbol"
#define NMEA2000_EXXO_DSC_CALL_INFORMATION_DSC_MSG_ADDRESS_NAME "DSCMsgAddress"
#define NMEA2000_EXXO_DSC_CALL_INFORMATION_PROPOSED_RX_FREQUENCY_CHANNEL_NAME "ProposedRxFrequencyChannel"
#define NMEA2000_EXXO_DSC_CALL_INFORMATION_PROPOSED_TX_FREQUENCY_CHANNEL_NAME "ProposedTxFrequencyChannel"
#define NMEA2000_EXXO_DSC_CALL_INFORMATION_TELEPHONE_NUMBER_NAME "TelephoneNumber"
#define NMEA2000_EXXO_DSC_CALL_INFORMATION_MMSI_OF_SHIP_IN_DISTRESS_NAME "MMSIOfShipInDistress"
#define NMEA2000_EXXO_DSC_CALL_INFORMATION_CALLING_RX_FREQUENCY_CHANNEL_NAME "CallingRxFrequencyChannel"
#define NMEA2000_EXXO_DSC_CALL_INFORMATION_CALLING_TX_FREQUENCY_CHANNEL_NAME "CallingTxFrequencyChannel"
#define NMEA2000_EXXO_DSC_CALL_INFORMATION_DSC_EXPANSION_FIELD_DATA_NAME "DSCExpansionFieldData"
#define NMEA2000_EXXO_DSC_CALL_INFORMATION_VAR_NBR_OF_FLDS_FLD22_REP_EXP_FLD_DATA_NAME "VarNbrOfFldsFld22RepExpFldData"
#define NMEA2000_EXXO_DGNSS_CORRECTIONS_SEQUENCE_ID__NAME "SequenceID_"
#define NMEA2000_EXXO_DGNSS_CORRECTIONS_REFERENCE_STATION_ID_NAME "ReferenceStationID"
#define NMEA2000_EXXO_DGNSS_CORRECTIONS_REFERENCE_STATION_TYPE_NAME "ReferenceStationType"
#define NMEA2000_EXXO_DGNSS_CORRECTIONS_TIME_OF_CORRECTIONS_NAME "TimeOfCorrections"
#define NMEA2000_EXXO_DGNSS_CORRECTIONS_STATION_HEALTH_NAME "StationHealth"
#define NMEA2000_EXXO_DGNSS_CORRECTIONS_SATELLITE_ID_NAME "SatelliteID"
#define NMEA2000_EXXO_DGNSS_CORRECTIONS_PRC_NAME "PRC"
#define NMEA2000_EXXO_DGNSS_CORRECTIONS_RRC_NAME "RRC"
#define NMEA2000_EXXO_DGNSS_CORRECTIONS_UDRE_NAME "UDRE"
#define NMEA2000_EXXO_DGNSS_CORRECTIONS_IOD_NAME "IOD"
#define NMEA2000_EXXO_CURRENT_STATION_DATA_MODE_NAME "Mode"
#define NMEA2000_EXXO_CURRENT_STATION_DATA_STATE_NAME "State"
#define NMEA2000_EXXO_CURRENT_STATION_DATA_MEASUREMENT_DATE_NAME "MeasurementDate"
#define NMEA2000_EXXO_CURRENT_STATION_DATA_MEASUREMENT_TIME_NAME "MeasurementTime"
#define NMEA2000_EXXO_CURRENT_STATION_DATA_STATION_LOCATION_LATITUDE_NAME "StationLocationLatitude"
#define NMEA2000_EXXO_CURRENT_STATION_DATA_STATION_LOCATION_LONGITUDE_NAME "StationLocationLongitude"
#define NMEA2000_EXXO_CURRENT_STATION_DATA_MEASUREMENT_DEPTH_NAME "MeasurementDepth"
#define NMEA2000_EXXO_CURRENT_STATION_DATA_CURRENT_SPEED_NAME "CurrentSpeed"
#define NMEA2000_EXXO_CURRENT_STATION_DATA_CURRENT_FLOW_DIRECTION_NAME "CurrentFlowDirection"
#define NMEA2000_EXXO_CURRENT_STATION_DATA_WATER_TEMP_NAME "WaterTemp"
#define NMEA2000_EXXO_CURRENT_STATION_DATA_STATION_ID_STRING_NAME "StationIDString"
#define NMEA2000_EXXO_CURRENT_STATION_DATA_STATION_NAME_STRING_NAME "StationNameString"
#define NMEA2000_EXXO_CROSS_TRACK_ERROR_SID_NAME "SID"
#define NMEA2000_EXXO_CROSS_TRACK_ERROR_XTE_MODE_NAME "XTEMode"
#define NMEA2000_EXXO_CROSS_TRACK_ERROR_NAVIGATION_TERMINATED_NAME "NavigationTerminated"
#define NMEA2000_EXXO_CROSS_TRACK_ERROR_XTE_NAME "XTE"
#define NMEA2000_EXXO_COGSOG_RAPID_UPDATE_SID_NAME "SID"
#define NMEA2000_EXXO_COGSOG_RAPID_UPDATE_COG_REFERENCE_NAME "COGReference"
#define NMEA2000_EXXO_COGSOG_RAPID_UPDATE_COURSE_OVER_GROUND_NAME "CourseOverGround"
#define NMEA2000_EXXO_COGSOG_RAPID_UPDATE_SPEED_OVER_GROUND_NAME "SpeedOverGround"
#define NMEA2000_EXXO_AIS_ADDRESSED_SAFETY_RELATED_MSG_MSG_ID_NAME "MsgID"
#define NMEA2000_EXXO_AIS_ADDRESSED_SAFETY_RELATED_MSG_REPEAT_INDICATOR_NAME "RepeatIndicator"
#define NMEA2000_EXXO_AIS_ADDRESSED_SAFETY_RELATED_MSG_SOURCE_ID_NAME "SourceID"
#define NMEA2000_EXXO_AIS_ADDRESSED_SAFETY_RELATED_MSG_AIS_TRANSCEIVER_INFORMATION_NAME "AISTransceiverInformation"
#define NMEA2000_EXXO_AIS_ADDRESSED_SAFETY_RELATED_MSG_SEQUENCE_NUMBER__NAME "SequenceNumber_"
#define NMEA2000_EXXO_AIS_ADDRESSED_SAFETY_RELATED_MSG_DESTINATION_ID_NAME "DestinationID"
#define NMEA2000_EXXO_AIS_ADDRESSED_SAFETY_RELATED_MSG_RETRANSMIT_FLAG_NAME "RetransmitFlag"
#define NMEA2000_EXXO_AIS_ADDRESSED_SAFETY_RELATED_MSG_SAFETY_RELATED_TEXT_NAME "SafetyRelatedText"
#define NMEA2000_EXXO_AIS_ADDRESSED_BINARY_MSG_MSG_ID_NAME "MsgID"
#define NMEA2000_EXXO_AIS_ADDRESSED_BINARY_MSG_REPEAT_INDICATOR_NAME "RepeatIndicator"
#define NMEA2000_EXXO_AIS_ADDRESSED_BINARY_MSG_SOURCE_ID_NAME "SourceID"
#define NMEA2000_EXXO_AIS_ADDRESSED_BINARY_MSG_AIS_TRANSCEIVER_INFORMATION_NAME "AISTransceiverInformation"
#define NMEA2000_EXXO_AIS_ADDRESSED_BINARY_MSG_SEQUENCE_NUMBER__NAME "SequenceNumber_"
#define NMEA2000_EXXO_AIS_ADDRESSED_BINARY_MSG_DESTINATION_ID_NAME "DestinationID"
#define NMEA2000_EXXO_AIS_ADDRESSED_BINARY_MSG_RETRANSMIT_FLAG_NAME "RetransmitFlag"
#define NMEA2000_EXXO_AIS_ADDRESSED_BINARY_MSG_NUMBER_OF_BITS_IN_BINARY_DATA_FIELD_NAME "NumberOfBitsInBinaryDataField"
#define NMEA2000_EXXO_AIS_ACKNOWLEDGE_MSG_ID_NAME "MsgID"
#define NMEA2000_EXXO_AIS_ACKNOWLEDGE_REPEAT_INDICATOR_NAME "RepeatIndicator"
#define NMEA2000_EXXO_AIS_ACKNOWLEDGE_SOURCE_ID_NAME "SourceID"
#define NMEA2000_EXXO_AIS_ACKNOWLEDGE_AIS_TRANSCEIVER_INFORMATION_NAME "AISTransceiverInformation"
#define NMEA2000_EXXO_AIS_ACKNOWLEDGE_DESTINATION_ID1_NAME "DestinationID1"
#define NMEA2000_EXXO_AIS_ACKNOWLEDGE_SEQUENCE_NUMBER_FOR_ID1_NAME "SequenceNumberForID1"
#define NMEA2000_EXXO_AIS_ACKNOWLEDGE_SEQUENCE_NUMBER_FOR_I_DN_NAME "SequenceNumberForIDn"
#define NMEA2000_EXXO_AC_INPUT_STATUS_AC_INSTANCE_NAME "AC_Instance"
#define NMEA2000_EXXO_AC_INPUT_STATUS_NUMBER_OF_LINES_NAME "Number_Of_Lines"
#define NMEA2000_EXXO_AC_INPUT_STATUS_LINE_NAME "Line"
#define NMEA2000_EXXO_AC_INPUT_STATUS_ACCEPTABILITY_NAME "Acceptability"
#define NMEA2000_EXXO_AC_INPUT_STATUS_VOLTAGE_NAME "Voltage"
#define NMEA2000_EXXO_AC_INPUT_STATUS_CURRENT_NAME "Current"
#define NMEA2000_EXXO_AC_INPUT_STATUS_FREQUENCY_NAME "Frequency"
#define NMEA2000_EXXO_AC_INPUT_STATUS_BREAKER_SIZE_NAME "Breaker_Size"
#define NMEA2000_EXXO_AC_INPUT_STATUS_REAL_POWER_NAME "Real_Power"
#define NMEA2000_EXXO_AC_INPUT_STATUS_REACTIVE_POWER_NAME "Reactive_Power"
#define NMEA2000_EXXO_AC_INPUT_STATUS_POWER_FACTOR_NAME "Power_Factor"
#define NMEA2000_EXXO_AC_OUTPUT_STATUS_AC_INSTANCE_NAME "AC_Instance"
#define NMEA2000_EXXO_AC_OUTPUT_STATUS_NUMBER_OF_LINES_NAME "Number_Of_Lines"
#define NMEA2000_EXXO_AC_OUTPUT_STATUS_LINE_NAME "Line"
#define NMEA2000_EXXO_AC_OUTPUT_STATUS_WAVEFORM_NAME "Waveform"
#define NMEA2000_EXXO_AC_OUTPUT_STATUS_VOLTAGE_NAME "Voltage"
#define NMEA2000_EXXO_AC_OUTPUT_STATUS_CURRENT_NAME "Current"
#define NMEA2000_EXXO_AC_OUTPUT_STATUS_FREQUENCY_NAME "Frequency"
#define NMEA2000_EXXO_AC_OUTPUT_STATUS_BREAKER_SIZE_NAME "Breaker_Size"
#define NMEA2000_EXXO_AC_OUTPUT_STATUS_REAL_POWER_NAME "Real_Power"
#define NMEA2000_EXXO_AC_OUTPUT_STATUS_REACTIVE_POWER_NAME "Reactive_Power"
#define NMEA2000_EXXO_AC_OUTPUT_STATUS_POWER_FACTOR_NAME "Power_Factor"
#define NMEA2000_EXXO_DC_DETAILED_STATUS_SID_NAME "SID"
#define NMEA2000_EXXO_DC_DETAILED_STATUS_DC_INSTANCE_NAME "DC_Instance"
#define NMEA2000_EXXO_DC_DETAILED_STATUS_DC_TYPE_NAME "DC_Type"
#define NMEA2000_EXXO_DC_DETAILED_STATUS_STATE_OF_CHARGE_NAME "State_Of_Charge"
#define NMEA2000_EXXO_DC_DETAILED_STATUS_STATE_OF_HEALTH_NAME "State_Of_Health"
#define NMEA2000_EXXO_DC_DETAILED_STATUS_TIME_REMAINING_NAME "Time_Remaining"
#define NMEA2000_EXXO_DC_DETAILED_STATUS_RIPPLE_VOLTAGE_NAME "Ripple_Voltage"
#define NMEA2000_EXXO_CHARGER_STATUS_CHARGER_INSTANCE_NAME "Charger_Instance"
#define NMEA2000_EXXO_CHARGER_STATUS_BATTERY_INSTANCE_NAME "Battery_Instance"
#define NMEA2000_EXXO_CHARGER_STATUS_OPERATING_STATE_NAME "Operating_State"
#define NMEA2000_EXXO_CHARGER_STATUS_CHARGE_MODE_NAME "Charge_Mode"
#define NMEA2000_EXXO_CHARGER_STATUS_CHARGER_ENABLE_DISABLE_NAME "Charger_EnableDisable"
#define NMEA2000_EXXO_CHARGER_STATUS_EQUALIZATION_PENDING_NAME "Equalization_Pending"
#define NMEA2000_EXXO_CHARGER_STATUS_EQUALIZATION_TIME_REMAINING_NAME "Equalization_Time_Remaining"
#define NMEA2000_EXXO_INVERTER_STATUS_INVERTER_INSTANCE_NAME "Inverter_Instance"
#define NMEA2000_EXXO_INVERTER_STATUS_AC_INSTANCE_NAME "AC_Instance"
#define NMEA2000_EXXO_INVERTER_STATUS_DC_INSTANCE_NAME "DC_Instance"
#define NMEA2000_EXXO_INVERTER_STATUS_OPERATING_STATE_NAME "Operating_State"
#define NMEA2000_EXXO_INVERTER_STATUS_INVERTER_ENABLE_DISABLE_NAME "Inverter_EnableDisable"
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_CHARGER_INSTANCE_NAME "Charger_Instance"
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_BATTERY_INSTANCE_NAME "Battery_Instance"
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_CHARGER_ENABLE_DISABLE_NAME "Charger_EnableDisable"
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_CHARGE_CURRENT_LIMIT_NAME "Charge_Current_Limit"
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_CHARGING_ALGORITHM_NAME "Charging_Algorithm"
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_CHARGER_MODE_NAME "Charger_Mode"
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_ESTIMATED_BATTERY_TEMP_WHEN_NO_SENSOR_NAME "Estimated_Battery_Temp_When_No_Sensor"
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_EQUALIZE_ONE_TIME_ENABLE_DISABLE_NAME "Equalize_One_Time_EnableDisable"
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_OVER_CHARGE_ENABLE_DISABLE_NAME "Over_Charge_EnableDisable"
#define NMEA2000_EXXO_CHARGER_CONFIGURATION_STATUS_EQUALIZE_TIME_NAME "Equalize_Time"
#define NMEA2000_EXXO_INVERTER_CONFIGURATION_STATUS_INVERTER_INSTANCE_NAME "Inverter_Instance"
#define NMEA2000_EXXO_INVERTER_CONFIGURATION_STATUS_AC_INSTANCE_NAME "AC_Instance"
#define NMEA2000_EXXO_INVERTER_CONFIGURATION_STATUS_DC_INSTANCE_NAME "DC_Instance"
#define NMEA2000_EXXO_INVERTER_CONFIGURATION_STATUS_INVERTER_ENABLE_DISABLE_NAME "Inverter_EnableDisable"
#define NMEA2000_EXXO_INVERTER_CONFIGURATION_STATUS_INVERTER_MODE_NAME "Inverter_Mode"
#define NMEA2000_EXXO_INVERTER_CONFIGURATION_STATUS_LOAD_SENSE_ENABLE_DISABLE_NAME "Load_Sense_EnableDisable"
#define NMEA2000_EXXO_INVERTER_CONFIGURATION_STATUS_LOAD_SENSE_POWER_THRESHOLD_NAME "Load_Sense_Power_Threshold"
#define NMEA2000_EXXO_INVERTER_CONFIGURATION_STATUS_LOAD_SENSE_INTERVAL_NAME "Load_Sense_Interval"
#define NMEA2000_EXXO_AGS_CONFIGURATION_STATUS_AGS_INSTANCE_NAME "AGS_Instance"
#define NMEA2000_EXXO_AGS_CONFIGURATION_STATUS_GENERATOR_INSTANCE_NAME "Generator_Instance"
#define NMEA2000_EXXO_AGS_CONFIGURATION_STATUS_AGS_MODE_NAME "AGS_Mode"
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_BATTERY_INSTANCE_NAME "Battery_Instance"
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_BATTERY_TYPE_NAME "Battery_Type"
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_SUPPORT_EQUALIZATION_NAME "Support_Equalization"
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_NOMINAL_VOLTAGE_NAME "Nominal_Voltage"
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_BATTERY_CHEMISTRY_NAME "Battery_Chemistry"
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_BATTERY_CAPACITY_NAME "Battery_Capacity"
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_BATTERY_TEMPERATURE_COEFFICIENT_NAME "Battery_Temperature_Coefficient"
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_PEUKERT_EXPONENT_NAME "Peukert_Exponent"
#define NMEA2000_EXXO_BATTERY_CONFIGURATION_STATUS_CHARGE_EFFICIENCY_FACTOR_NAME "Charge_Efficiency_Factor"
#define NMEA2000_EXXO_AGS_STATUS_AGS_INSTANCE_NAME "AGS_Instance"
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_INSTANCE_NAME "Generator_Instance"
#define NMEA2000_EXXO_AGS_STATUS_AGS_OPERATING_STATE_NAME "AGS_Operating_State"
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_STATE_NAME "Generator_State"
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_ON_REASON_NAME "Generator_On_Reason"
#define NMEA2000_EXXO_AGS_STATUS_GENERATOR_OFF_REASON_NAME "GeneratorOffReason"
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_MESSAGE_ID_NAME "MessageID"
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_REPEAT_INDICATOR_NAME "Repeat_Indicator"
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_STATION_ID_NAME "StationID"
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_AIS_TRANSCEIVER_INFORMATION_NAME "AIS_Transceiver_Information"
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_CHANNEL_A_NAME "Channel_A"
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_CHANNEL_B_NAME "Channel_B"
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_POWER_NAME "Power"
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_TX_RX_MODE_NAME "TxRx_Mode"
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_NORTH_EAST_LONGITUDE_CORNER_1_NAME "North_East_Longitude_Corner_1"
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_NORTH_EAST_LATITUDE_CORNER_1_NAME "North_East_Latitude_Corner_1"
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_SOUTH_WEST_LONGITUDE_CORNER_2_NAME "South_West_Longitude_Corner_2"
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_SOUTH_WEST_LATITUDE_CORNER_2_NAME "South_West_Latitude_Corner_2"
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_ADDRESSED_OR_BROADCAST_MESSAGE_INDICATOR_NAME "Addressed_or_Broadcast_Message_Indicator"
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_CHANNEL_A_BANDWIDTH_NAME "Channel_A_Bandwidth"
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_CHANNEL_B_BANDWIDTH_NAME "Channel_B_Bandwidth"
#define NMEA2000_EXXO_AIS_CHANNEL_MANAGEMENT_TRANSITIONAL_ZONE_SITE_NAME "Transitional_Zone_Site"
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_MESSAGE_ID_NAME "MessageID"
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_REPEAT_INDICATOR_NAME "Repeat_Indicator"
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_SOURCE_ID_NAME "SourceID"
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_TX_RX_MODE_NAME "TxRx_Mode"
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_NORTH_EAST_LONGITUDE_CORNER_1_NAME "North_East_Longitude_Corner_1"
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_NORTH_EAST_LATITUDE_CORNER_1_NAME "North_East_Latitude_Corner_1"
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_SOUTH_WEST_LONGITUDE_CORNER_2_NAME "South_West_Longitude_Corner_2"
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_SOUTH_WEST_LATITUDE_CORNER_2_NAME "South_West_Latitude_Corner_2"
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_STATION_TYPE_NAME "Station_Type"
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_SHIP_AND_CARGO_FILTER_NAME "Ship_and_Cargo_Filter"
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_REPORTING_INTERVAL_NAME "Reporting_Interval"
#define NMEA2000_EXXO_AIS_CLASS_B_GROUP_ASSIGNMENT_QUIET_TIME_NAME "Quiet_Time"
#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_A_MESSAGE_ID_NAME "MessageID"
#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_A_REPEAT_INDICATOR_NAME "Repeat_Indicator"
#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_A_USER_ID_NAME "UserID"
#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_A_NAME_NAME "Name"
#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_B_MESSAGE_ID_NAME "MessageID"
#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_B_REPEAT_INDICATOR_NAME "Repeat_Indicator"
#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_B_USER_ID_NAME "UserID"
#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_B_TYPE_OF_SHIP_AND_CARGO_NAME "Type_Of_Ship_And_Cargo"
#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_B_VENDOR_ID_NAME "VendorID"
#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_B_CALL_SIGN_NAME "Call_Sign"
#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_B_SHIP_LENGTH_NAME "Ship_Length"
#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_B_SHIP_BEAM_NAME "Ship_Beam"
#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_B_REFERENCE_POINT_POSITION_FROM_STARBOARD_NAME "Reference_Point_Position_from_Starboard"
#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_B_REFERENCE_POINT_POSITION_AFT_OF_BOW_NAME "Reference_Point_Position_Aft_of_Bow"
#define NMEA2000_EXXO_AIS_CLASS_B_CS_STATIC_DATA_REPORT_PART_B_MOTHER_SHIP_MMSI_NAME "Mother_Ship_MMSI"
#define NMEA2000_EXXO_TEMPERATURE_SID_NAME "SID"
#define NMEA2000_EXXO_TEMPERATURE_TEMPERATURE_INSTANCE_NAME "Temperature_Instance"
#define NMEA2000_EXXO_TEMPERATURE_TEMPERATURE_SOURCE_NAME "Temperature_Source"
#define NMEA2000_EXXO_TEMPERATURE_ACTUAL_TEMPERATURE_NAME "Actual_Temperature"
#define NMEA2000_EXXO_TEMPERATURE_SET_TEMPERATURE_NAME "Set_Temperature"
#define NMEA2000_EXXO_HUMIDITY_SID_NAME "SID"
#define NMEA2000_EXXO_HUMIDITY_HUMIDITY_INSTANCE_NAME "Humidity_Instance"
#define NMEA2000_EXXO_HUMIDITY_HUMIDITY_SOURCE_NAME "Humidity_Source"
#define NMEA2000_EXXO_HUMIDITY_ACTUAL_HUMIDITY_NAME "Actual_Humidity"
#define NMEA2000_EXXO_HUMIDITY_SET_HUMIDITY_NAME "Set_Humidity"
#define NMEA2000_EXXO_ACTUAL_PRESSURE_SID_NAME "SID"
#define NMEA2000_EXXO_ACTUAL_PRESSURE_PRESSURE_INSTANCE_NAME "Pressure_Instance"
#define NMEA2000_EXXO_ACTUAL_PRESSURE_PRESSURE_SOURCE_NAME "Pressure_Source"
#define NMEA2000_EXXO_ACTUAL_PRESSURE_PRESSURE_NAME "Pressure"
#define NMEA2000_EXXO_SET_PRESSURE_SID_NAME "SID"
#define NMEA2000_EXXO_SET_PRESSURE_PRESSURE_INSTANCE_NAME "Pressure_Instance"
#define NMEA2000_EXXO_SET_PRESSURE_PRESSURE_SOURCE_NAME "Pressure_Source"
#define NMEA2000_EXXO_SET_PRESSURE_PRESSURE_NAME "Pressure"
#define NMEA2000_EXXO_ENVIRONMENTAL_PARAMETERS2_SEQUENCE_ID__NAME "SequenceID_"
#define NMEA2000_EXXO_ENVIRONMENTAL_PARAMETERS2_TEMP_INSTANCE_NAME "TempInstance"
#define NMEA2000_EXXO_ENVIRONMENTAL_PARAMETERS2_HUMIDITY_INSTANCE_NAME "HumidityInstance"
#define NMEA2000_EXXO_ENVIRONMENTAL_PARAMETERS2_TEMP_NAME "Temp"
#define NMEA2000_EXXO_ENVIRONMENTAL_PARAMETERS2_HUMIDITY_NAME "Humidity"
#define NMEA2000_EXXO_ENVIRONMENTAL_PARAMETERS2_ATMOSPHERIC_PRESS_NAME "AtmosphericPress"
#define NMEA2000_EXXO_PRODUCT_INFORMATION_NMEA2000_DATABASE_VERSION_NAME "NMEA2000DatabaseVersion"
#define NMEA2000_EXXO_PRODUCT_INFORMATION_NMEA_MANUFACTURERS_PRODUCT_CODE_NAME "NMEAManufacturersProductCode"
#define NMEA2000_EXXO_PRODUCT_INFORMATION_MANUFACTURERS_MODEL_ID_NAME "ManufacturersModelID"
#define NMEA2000_EXXO_PRODUCT_INFORMATION_MANUFACTURERS_SOFTWARE_VERSION_CODE_NAME "ManufacturersSoftwareVersionCode"
#define NMEA2000_EXXO_PRODUCT_INFORMATION_MANUFACTURERS_MODEL_VERSION_NAME "ManufacturersModelVersion"
#define NMEA2000_EXXO_PRODUCT_INFORMATION_MANUFACTURERS_MODEL_SERIAL_CODE_NAME "ManufacturersModelSerialCode"
#define NMEA2000_EXXO_CONFIG_INFORMATION_INSTALLATION_DESCRIPTION_FIELD1_NAME "InstallationDescriptionField1"
#define NMEA2000_EXXO_CONFIG_INFORMATION_INSTALLATION_DESCRIPTION_FIELD2_NAME "InstallationDescriptionField2"
#define NMEA2000_EXXO_CONFIG_INFORMATION_MANUFACTURER_INFORMATION_FIELD3_NAME "ManufacturerInformationField3"
#define NMEA2000_EXXO_PGN_LST_TRANSMIT_PG_NS_GROUP_FUNCTION_GRP_FNCTN_TRNSMT_AND_RECEIVE_PGN_LIST_NAME "GrpFnctnTrnsmtAndReceivePGNList"
#define NMEA2000_EXXO_PGN_LST_TRANSMIT_PG_NS_GROUP_FUNCTION_FIRST_PGN_SUPPORTED2_NAME "FirstPGNSupported2"
#define NMEA2000_EXXO_PGN_LST_TRANSMIT_PG_NS_GROUP_FUNCTION_FIRST_PGN_SUPPORTED_NAME "FirstPGNSupported"
#define NMEA2000_EXXO_PGN_LST_TRANSMIT_PG_NS_GROUP_FUNCTION_VRBL_NMBR_OF_FLDS_FLD_NMBER2_REPEATED2_NAME "VrblNmbrOfFldsFldNmber2Repeated2"
#define NMEA2000_EXXO_PGN_LST_TRANSMIT_PG_NS_GROUP_FUNCTION_VRBL_NMBR_OF_FLDS_FLD_NMBER2_REPEATED_NAME "VrblNmbrOfFldsFldNmber2Repeated"
#define NMEA2000_EXXO_PGN_LST_TRANSMIT_PG_NS_GROUP_FUNCTION_PGN_SUPPORTED3_NAME "PGNSupported3"
#define NMEA2000_EXXO_PGN_LST_TRANSMIT_PG_NS_GROUP_FUNCTION_PGN_SUPPORTED3_2_NAME "PGNSupported3_2"
#define NMEA2000_EXXO_PGN_LST_TRANSMIT_PG_NS_GROUP_FUNCTION_PGN_SUPPORTED4_NAME "PGNSupported4"
#define NMEA2000_EXXO_PGN_LST_TRANSMIT_PG_NS_GROUP_FUNCTION_PGN_SUPPORTED4_2_NAME "PGNSupported4_2"
#define NMEA2000_EXXO_PGN_LST_TRANSMIT_PG_NS_GROUP_FUNCTION_PGN_SUPPORTED5_NAME "PGNSupported5"
#define NMEA2000_EXXO_PGN_LST_TRANSMIT_PG_NS_GROUP_FUNCTION_PGN_SUPPORTED5_2_NAME "PGNSupported5_2"

/**
 * Signals in message Time_Date.
 *
 * This_PGN_has_a_single_transmission_that_provides:_-_UTC_Time_-_UTC_Date_-_Local_offset_Products_that_can_maintain_or_have_a_method_of_calculating_or_manually_providing_local_offset_should_transmit_this_PGN
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_time_date_t {
    /**
     * Days_since_January_1,_1970,___Date_is_relative_to_UTC_Time.
     *
     * Range: 0..65532 (0..65532 day)
     * Scale: 1
     * Offset: 0
     */
    uint16_t date;

    /**
     * 24_hour_clock,_0_=__midnight,__time_is_in_UTC
     *
     * Range: 0..864010000 (0..86401 sec)
     * Scale: 0.0001
     * Offset: 0
     */
    uint32_t time;

    /**
     * Local_time_zone_offset_in_minutes.__Local_time_zone_is_added_to_local_time_to_obtain_UTC.__Local_zone_is_generally_negative_for_East_longitudes,_with_local_exceptions_near_the_International_Date_Line.
     *
     * Range: -32764..32764 (-32764..32764 mins)
     * Scale: 1
     * Offset: 0
     */
    int16_t local_offset_minutes;
};

/**
 * Signals in message TimeTo_FromMark.
 *
 * Time_to_go_to_elapsed_from_a_generic_mark,that_may_be_non-fixedmark_is_not_generally_a_specific_geographic_point_but_may_vary_continuously_and_is_most_often_determined_by_calculationrecommended_turning_tacking_point_for_sailing_vessels,wheel-over_point_
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_time_to_from_mark_t {
    /**
     * An_upward_counting_number_used_to_tie_related_information_together_between_different_PGNs.For_example,SID_would_be_used_to_tie_together_COG,SOG_and_RAIM_values_to_a_given_Pos.255=no_valid_Pos_fix_to_tie_it_to.Range_0_to_250_for_valid_Pos_fixes.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sid;

    /**
     * Time_interval_in_milli-sec.__'-'__=_time_elapsed_since_event,_'+'_=_time_to_go_before_event.
     *
     * Range: -2148000000..2148000000 (-2148000..2148000 sec)
     * Scale: 0.001
     * Offset: 0
     */
    int32_t time_elapsed_togo_to_mark;

    /**
     * 0___=_Collision,__1_=_Turning_Point,_2_=_Reference_(general),_3_=_Wheelover,_4_=_Waypoint,_5-13_=_Reserved,_14_=_Error,_15_=_Null
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mark_type;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t mark_id;
};

/**
 * Signals in message TideStationData.
 *
 * Tide_station_measurement_data_including_station_location,_numeric_identifier,_and_name
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_tide_station_data_t {
    /**
     * Range_Residual_used_in_position_calculation_or_range_residuals_were_calculated_after_the_position.___0=range_residuals_were_used_to_calculate_dat
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mode;

    /**
     * msb/lsb:__00_=_Falling,_01_=_Rising,_10_=_Error,_11_=_Unavailable,_Unknown
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tide_tendency;

    /**
     * Days_since_January_1,_1970,___Date_is_relative_to_UTC_Time.
     *
     * Range: 0..65532 (0..65532 day)
     * Scale: 1
     * Offset: 0
     */
    uint16_t measurement_date;

    /**
     * 24_hour_clock,_0_=__midnight,__time_is_in_UTC
     *
     * Range: 0..864010000 (0..86401 sec)
     * Scale: 0.0001
     * Offset: 0
     */
    uint32_t measurement_time;

    /**
     * Range: -90..90 (-90..90 deg)
     * Scale: 1
     * Offset: 0
     */
    int32_t station_location_latitude;

    /**
     * Range: -180..180 (-180..180 deg)
     * Scale: 1
     * Offset: 0
     */
    int32_t station_location_longitude;

    /**
     * This_value_is_relative_to_mean_lower_low_water_(MLLW).
     *
     * Range: -32764..32764 (-32.764..32.764 m)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t tide_level;

    /**
     * following_text_is_from_NOAA_and_is_placed_here_to_convey_an_understanding_of_expected_magnitude_of_values.'tide_gage_processes_181_water_level_samples,1_second_apart,centered_on_6_minute_mark.It_then_computes_standard_deviation_of_Samples.Samples_more_tha
     *
     * Range: 0..65532 (0..655.32 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t tide_level_standard_deviation;

    /**
     * Name_of_place,_route,_waypoint,_destination,_vessel,_vehicle,_etc.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint16_t station_id_string;

    /**
     * Name_of_place,_route,_waypoint,_destination,_vessel,_vehicle,_etc.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint16_t station_name_string;
};

/**
 * Signals in message SystemTime.
 *
 * The_purpose_of_this_PGN_is_twofold:_-_To_provide_a_regular_transmission_of_UTC_time_and_date_-_To_provide_synchronism_for_measurement_data
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_system_time_t {
    /**
     * An_upward_counting_number_used_to_tie_related_information_together_between_different_PGNs.For_example,SID_would_be_used_to_tie_together_COG,SOG_and_RAIM_values_to_a_given_Pos.255=no_valid_Pos_fix_to_tie_it_to.Range_0_to_250_for_valid_Pos_fixes.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sid;

    /**
     * 0x0_=_GPS,__0x1_=GLONASS,_0x2_=_WWV_or_equivalent_Radio_Station_Time_Sync,_0x3_=_Local_Cesium_clock,_0x4_=_Local_Rubidium_clock,_0x5_=_Local_Crystal_clock,_0x6_-_0xE_=_reserved,_0xF_=_Null
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t source;

    /**
     * Days_since_January_1,_1970,___Date_is_relative_to_UTC_Time.
     *
     * Range: 0..65532 (0..65532 day)
     * Scale: 1
     * Offset: 0
     */
    uint16_t date;

    /**
     * 24_hour_clock,_0_=__midnight,__time_is_in_UTC
     *
     * Range: 0..864010000 (0..86401 sec)
     * Scale: 0.0001
     * Offset: 0
     */
    uint32_t time;
};

/**
 * Signals in message SwitchBankCtrl.
 *
 * Universal_commands_to_multiple_banks_of_two-state_devices
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_switch_bank_ctrl_t {
    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch_bank_instance;

    /**
     * 00_=_[Turn_Off,_Disable,_Reset,_Make_'0'],_01_=_[Turn_On,_Enable,_Set,_Make_'1'],_02_=_Reserved,_03_=_No_action
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch1;

    /**
     * 00_=_[Turn_Off,_Disable,_Reset,_Make_'0'],_01_=_[Turn_On,_Enable,_Set,_Make_'1'],_02_=_Reserved,_03_=_No_action
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch2;

    /**
     * 00_=_[Turn_Off,_Disable,_Reset,_Make_'0'],_01_=_[Turn_On,_Enable,_Set,_Make_'1'],_02_=_Reserved,_03_=_No_action
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch3;

    /**
     * 00_=_[Turn_Off,_Disable,_Reset,_Make_'0'],_01_=_[Turn_On,_Enable,_Set,_Make_'1'],_02_=_Reserved,_03_=_No_action
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch4;

    /**
     * 00_=_[Turn_Off,_Disable,_Reset,_Make_'0'],_01_=_[Turn_On,_Enable,_Set,_Make_'1'],_02_=_Reserved,_03_=_No_action
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch5;

    /**
     * 00_=_[Turn_Off,_Disable,_Reset,_Make_'0'],_01_=_[Turn_On,_Enable,_Set,_Make_'1'],_02_=_Reserved,_03_=_No_action
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch6;

    /**
     * 00_=_[Turn_Off,_Disable,_Reset,_Make_'0'],_01_=_[Turn_On,_Enable,_Set,_Make_'1'],_02_=_Reserved,_03_=_No_action
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch7;

    /**
     * 00_=_[Turn_Off,_Disable,_Reset,_Make_'0'],_01_=_[Turn_On,_Enable,_Set,_Make_'1'],_02_=_Reserved,_03_=_No_action
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch8;

    /**
     * 00_=_[Turn_Off,_Disable,_Reset,_Make_'0'],_01_=_[Turn_On,_Enable,_Set,_Make_'1'],_02_=_Reserved,_03_=_No_action
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch9;

    /**
     * 00_=_[Turn_Off,_Disable,_Reset,_Make_'0'],_01_=_[Turn_On,_Enable,_Set,_Make_'1'],_02_=_Reserved,_03_=_No_action
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch10;

    /**
     * 00_=_[Turn_Off,_Disable,_Reset,_Make_'0'],_01_=_[Turn_On,_Enable,_Set,_Make_'1'],_02_=_Reserved,_03_=_No_action
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch11;

    /**
     * 00_=_[Turn_Off,_Disable,_Reset,_Make_'0'],_01_=_[Turn_On,_Enable,_Set,_Make_'1'],_02_=_Reserved,_03_=_No_action
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch12;

    /**
     * 00_=_[Turn_Off,_Disable,_Reset,_Make_'0'],_01_=_[Turn_On,_Enable,_Set,_Make_'1'],_02_=_Reserved,_03_=_No_action
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch13;

    /**
     * 00_=_[Turn_Off,_Disable,_Reset,_Make_'0'],_01_=_[Turn_On,_Enable,_Set,_Make_'1'],_02_=_Reserved,_03_=_No_action
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch14;

    /**
     * 00_=_[Turn_Off,_Disable,_Reset,_Make_'0'],_01_=_[Turn_On,_Enable,_Set,_Make_'1'],_02_=_Reserved,_03_=_No_action
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch15;

    /**
     * 00_=_[Turn_Off,_Disable,_Reset,_Make_'0'],_01_=_[Turn_On,_Enable,_Set,_Make_'1'],_02_=_Reserved,_03_=_No_action
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch16;

    /**
     * 00_=_[Turn_Off,_Disable,_Reset,_Make_'0'],_01_=_[Turn_On,_Enable,_Set,_Make_'1'],_02_=_Reserved,_03_=_No_action
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch17;

    /**
     * 00_=_[Turn_Off,_Disable,_Reset,_Make_'0'],_01_=_[Turn_On,_Enable,_Set,_Make_'1'],_02_=_Reserved,_03_=_No_action
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch18;

    /**
     * 00_=_[Turn_Off,_Disable,_Reset,_Make_'0'],_01_=_[Turn_On,_Enable,_Set,_Make_'1'],_02_=_Reserved,_03_=_No_action
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch19;

    /**
     * 00_=_[Turn_Off,_Disable,_Reset,_Make_'0'],_01_=_[Turn_On,_Enable,_Set,_Make_'1'],_02_=_Reserved,_03_=_No_action
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch20;

    /**
     * 00_=_[Turn_Off,_Disable,_Reset,_Make_'0'],_01_=_[Turn_On,_Enable,_Set,_Make_'1'],_02_=_Reserved,_03_=_No_action
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch21;

    /**
     * 00_=_[Turn_Off,_Disable,_Reset,_Make_'0'],_01_=_[Turn_On,_Enable,_Set,_Make_'1'],_02_=_Reserved,_03_=_No_action
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch22;

    /**
     * 00_=_[Turn_Off,_Disable,_Reset,_Make_'0'],_01_=_[Turn_On,_Enable,_Set,_Make_'1'],_02_=_Reserved,_03_=_No_action
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch23;

    /**
     * 00_=_[Turn_Off,_Disable,_Reset,_Make_'0'],_01_=_[Turn_On,_Enable,_Set,_Make_'1'],_02_=_Reserved,_03_=_No_action
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch24;

    /**
     * 00_=_[Turn_Off,_Disable,_Reset,_Make_'0'],_01_=_[Turn_On,_Enable,_Set,_Make_'1'],_02_=_Reserved,_03_=_No_action
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch25;

    /**
     * 00_=_[Turn_Off,_Disable,_Reset,_Make_'0'],_01_=_[Turn_On,_Enable,_Set,_Make_'1'],_02_=_Reserved,_03_=_No_action
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch26;

    /**
     * 00_=_[Turn_Off,_Disable,_Reset,_Make_'0'],_01_=_[Turn_On,_Enable,_Set,_Make_'1'],_02_=_Reserved,_03_=_No_action
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch27;

    /**
     * 00_=_[Turn_Off,_Disable,_Reset,_Make_'0'],_01_=_[Turn_On,_Enable,_Set,_Make_'1'],_02_=_Reserved,_03_=_No_action
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch28;
};

/**
 * Signals in message SpeedWaterReferenced.
 *
 * The_purpose_of_this_PGN_is_to_provide_a_single_transmission_that_describes_the_motion_of_a_vessel
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_speed_water_referenced_t {
    /**
     * An_upward_counting_number_used_to_tie_related_information_together_between_different_PGNs.For_example,SID_would_be_used_to_tie_together_COG,SOG_and_RAIM_values_to_a_given_Pos.255=no_valid_Pos_fix_to_tie_it_to.Range_0_to_250_for_valid_Pos_fixes.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sequence_id_;

    /**
     * Range: 0..65532 (0..655.32 m/s)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t speed_water_referenced;

    /**
     * Range: 0..65532 (0..655.32 m/s)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t speed_ground_referenced;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t speed_water_referenced_type;
};

/**
 * Signals in message SmallCraftStatus.
 *
 * Provides_data_on_various_small_craft_control_surfaces_and_speed_through_the_water_Used_primarily_by_display_or_instrumentation_devices
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_small_craft_status_t {
    /**
     * Range: -124..124 (-124..124 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t port_trim_tab;

    /**
     * Range: -124..124 (-124..124 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t starboard_trim_tab;
};

/**
 * Signals in message SetDriftRapidUpdate.
 *
 * Set_and_Drift_effect_on_Vessel_is_direction_and_speed_of__a_currentCourse&Speedthrough_watervector_added_to_Set&Drift_vector_is_COG&SOG_vectorbearings_may_be_True_Magnetic_referenced_When_Set&Drift_is_calculated_from_data_from_a_GPS,a_compass_and_a_
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_set_drift_rapid_update_t {
    /**
     * An_upward_counting_number_used_to_tie_related_information_together_between_different_PGNs.For_example,SID_would_be_used_to_tie_together_COG,SOG_and_RAIM_values_to_a_given_Pos.255=no_valid_Pos_fix_to_tie_it_to.Range_0_to_250_for_valid_Pos_fixes.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sid;

    /**
     * 0_=_True,__1_=_Magnetic,_2_=_Error,_3_=_Null
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t set_reference;

    /**
     * Direction_towards_which_current_flows.__Degrees_relative_to_True_North.
     *
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t set;

    /**
     * Range: 0..65532 (0..655.32 m/s)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t drift;
};

/**
 * Signals in message SalinityStationData.
 *
 * Salinity_station_measurement_data_including_station_location,_numeric_identifier,_and_name
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_salinity_station_data_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message RouteAndWPServiceRouteWPNamePos.
 *
 * Complex_Rq_of_this_PGN_should_return_Waypoints_belonging_to_a_Route_WARNING:Route_Track_may_not_be_defined_by_Waypoint_Poss_only:Navigation_MethodGC/RLand_Radius_of_Turn_at_each_Waypoint_are_optional_additional_parameters_defining_Track_PGN_130066
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_route_and_wp_service_route_wp_name_pos_t {
    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t start_rps;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_items;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t number_of_w_ps_in_route;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t database_id;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t route_id;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t wpid;

    /**
     * Name_of_place,_route,_waypoint,_destination,_vessel,_vehicle,_etc.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint16_t wp_name;
};

/**
 * Signals in message RouteAndWPServiceRouteWPName.
 *
 * Complex_Rq_of_this_PGN_should_return_Waypoints_belonging_to_a_Route_WARNING:Route_Track_may_not_be_defined_by_Waypoint_Poss_only:Navigation_MethodGC/RLand_Radius_of_Turn_at_each_Waypoint_are_optional_additional_parameters_defining_Track_PGN_130066
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_route_and_wp_service_route_wp_name_t {
    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t start_rps;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_items;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t number_of_w_ps_in_route;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t database_id;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t route_id;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t wpid;

    /**
     * Name_of_place,_route,_waypoint,_destination,_vessel,_vehicle,_etc.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint16_t wp_name;
};

/**
 * Signals in message RouteAndWPServiceRouteList.
 *
 * Complex_Rq_for_this_PGN_should_return_a_list_of_Routes_in_a_Database_A_Database_may_contain_Routes_identified_with_Route_ID_in_range_0-65532There_may_be_empty_gapsRoute_ID_does_not_represent_a_valid/existent_Routeanywhere_in_this_rangeThis_PGN_sha
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_route_and_wp_service_route_list_t {
    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t start_route_id;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_items;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t nmbr_of_routes_available_in_database;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t database_id;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t route_id;

    /**
     * Name_of_place,_route,_waypoint,_destination,_vessel,_vehicle,_etc.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint16_t route_name;
};

/**
 * Signals in message RouteAndWPServiceRouteComment.
 *
 * Complex_Rq_of_this_PGN_should_return_supplementary_Comments_attached_to_Routes_Database_ID_shall_be_specified_in_Rq/reply_Routes_without_a_comment_shall_not_be_included_in_this_PGN_reply_should_use_same_transfer_Protcl_as_Rq_ISO_Rq_for_this_PG
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_route_and_wp_service_route_comment_t {
    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t start_route_id;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_items;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t number_of_routes_with_comments;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t database_id;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t route_id;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t comment;
};

/**
 * Signals in message RouteAndWPServiceRadiusOfTurn.
 *
 * Complex_Rq_of_this_PGN_should_return_Radius_of_Turn_at_specific_Waypoints_of_a_Route_For_a_complete_description_of_Route_and_WP_PGNs,see_App_note_in_Appendix_DRadius_of_Turn_is_described_in_Appendix_D5156_Database_ID_and_Route_ID_shall_be_spec
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_route_and_wp_service_radius_of_turn_t {
    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t start_rps;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_items;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t nmbr_of_wypnts_wth_a_spcfc_rdus_of_turn;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t database_id;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t route_id;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t rps;

    /**
     * A_commanded_distance_like_radius_order,_off-track_limit,_etc.
     *
     * Range: -32764..32764 (-32764..32764 m)
     * Scale: 1
     * Offset: 0
     */
    int16_t radius_of_turn;
};

/**
 * Signals in message RouteAndWPServiceDatabaseList.
 *
 * Complex_Rq_for_this_PGN_should_return_a_list_of_Databases_in_which_a_navigation_Deviceganizes_its_Routes_and_WPs_A_Database_may_contain_one_WP-List_and_multiple_Routes_A_device_need_not_support_concept_of_multiple_Databasessupport_of_this_PGN_is_
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_route_and_wp_service_database_list_t {
    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t start_database_id;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_items;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t number_of_databases_available;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t database_id;

    /**
     * Name_of_place,_route,_waypoint,_destination,_vessel,_vehicle,_etc.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint16_t database_name;
};

/**
 * Signals in message RateOfTurn.
 *
 * Rate_of_Turn_is_the_rate_of_change_of_the_Heading_Heading_is_defined_as_the_direction_of_the_vertical_projection_of_the_fore-and-aft_line_of_the_ship_onto_the_horizontal_plane
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_rate_of_turn_t {
    /**
     * An_upward_counting_number_used_to_tie_related_information_together_between_different_PGNs.For_example,SID_would_be_used_to_tie_together_COG,SOG_and_RAIM_values_to_a_given_Pos.255=no_valid_Pos_fix_to_tie_it_to.Range_0_to_250_for_valid_Pos_fixes.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sequence_id_;

    /**
     * +_=_Bow_turning_to_starboard,_1_deg/min_=_.00029_rad/sec
     *
     * Range: -32768..32767 (-32768..32767 rad/s)
     * Scale: 1
     * Offset: 0
     */
    int16_t rate_of_turn;
};

/**
 * Signals in message RadioFrequency_Mode_Power.
 *
 * This_PGN_provides_status_and_control_for_a_Radiotelephone,_connected_to_a_NMEA_2000_network_The_Radiotelephone_will_transmit_and_receive_status_along_with_remote_control_and_repeater_products
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_radio_frequency_mode_power_t {
    /**
     * Range: 0..32704 (0..327040 Hz)
     * Scale: 10
     * Offset: 0
     */
    uint32_t rx_frequency;

    /**
     * Range: 0..32704 (0..327040 Hz)
     * Scale: 10
     * Offset: 0
     */
    uint32_t tx_frequency;

    /**
     * MF/HF_telephone_channels_to_have_first_digit_3_followed_by_ITU_channel_numbers_with_leading_zeros_as_required.MF/HF_teletype_channels_to_have_first_digit_4_second_and_third_digit_give_frequency_bands_and_fourth_to_sixth_digits_ITU_channel_numbers_each_
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint64_t radio_channel;
};

/**
 * Signals in message PsDeltaHighPrecisionRapidUpdate.
 *
 * ThePos_Delta,High_Precision_Rapid_UpdateParameter_Group_is_intended_for_Apps_where_very_high_precision_and_very_fast_update_rates_are_needed_for_Pos_dataThis_PG_can_provide_delta_Pos_changes_down_to_1_millimeter_with_a_delta_time_period_accurate_to_5_m
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_ps_delta_high_precision_rapid_update_t {
    /**
     * An_upward_counting_number_used_to_tie_related_information_together_between_different_PGNs.For_example,SID_would_be_used_to_tie_together_COG,SOG_and_RAIM_values_to_a_given_Pos.255=no_valid_Pos_fix_to_tie_it_to.Range_0_to_250_for_valid_Pos_fixes.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sequence_id_;

    /**
     * Range: 0..252 (0..1.26 sec)
     * Scale: 0.005
     * Offset: 0
     */
    uint8_t time_delta;

    /**
     * Range: -8300000..8300000 (-83..83 s)
     * Scale: 1e-05
     * Offset: 0
     */
    int32_t latitude_delta;

    /**
     * Range: -8300000..8300000 (-83..83 s)
     * Scale: 1e-05
     * Offset: 0
     */
    int32_t longitude_delta;
};

/**
 * Signals in message PosRapidUpdate.
 *
 * This_PGN_provides_latitude_and_longitude_referenced_to_WGS84Being_defined_as_single_frame_Msg,as_opposed_to_other_PGNs_that_include_latitude_and_longitude_and_are_defined_as_fast_multi-packet,this_PGN_lends_itself_to_being_transmitted_more_frequently_wit
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_pos_rapid_update_t {
    /**
     * Range: -90..90 (-90..90 deg)
     * Scale: 1
     * Offset: 0
     */
    int32_t latitude_;

    /**
     * Range: -180..180 (-180..180 deg)
     * Scale: 1
     * Offset: 0
     */
    int32_t longitude_;
};

/**
 * Signals in message NavigationRoute_WPInformation.
 *
 * This_PGN_shall_return_Route_and_WP_data_ahead_in_Active_Route_It_can_be_Rqed_may_be_transmitted_without_a_Rq,typically_at_each_Waypoint_advance_When_navigating_Route_in_Forward_direction,Waypoints_shall_be_included_inder_of_increasing_RPSsWhen_na
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_navigation_route_wp_information_t {
    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t start_rps;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_items;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t database_id;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t route_id;

    /**
     * 0=Forward,__1=Reverse,_2-5_Reserved,_6=_Error,_7=Null_(info_not_available)
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t navigation_direction_in_route;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t spplmntary_route_wp_data_available;

    /**
     * Name_of_place,_route,_waypoint,_destination,_vessel,_vehicle,_etc.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint16_t route_name;

    /**
     * Name_of_place,_route,_waypoint,_destination,_vessel,_vehicle,_etc.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint16_t wp_name;
};

/**
 * Signals in message NavigationData.
 *
 * This_PGN_provides_essential_navigation_data_for_following_a_route_Transmissions_will_originate_from_products_that_can_create_and_manage_routes_using_waypoints_This_information_is_intended_for_navigational_repeaters
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_navigation_data_t {
    /**
     * An_upward_counting_number_used_to_tie_related_information_together_between_different_PGNs.For_example,SID_would_be_used_to_tie_together_COG,SOG_and_RAIM_values_to_a_given_Pos.255=no_valid_Pos_fix_to_tie_it_to.Range_0_to_250_for_valid_Pos_fixes.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sid;

    /**
     * Range: 0..4295000000 (0..42950000 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint32_t distance_to_destination_waypoint;

    /**
     * 0_=_True,__1_=_Magnetic,_2_=_Error,_3_=_Null
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t course_bearing_ref;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t perpendicular_crossed;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t arrival_circle_entered;

    /**
     * 0_=_Great_Circle_calculations,__1_=_Rhumb_Line_calculations,_2_=_Error,_3_=_Null
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t calculation_type;

    /**
     * 24_hour_clock,_0_=__midnight,__time_is_in_UTC
     *
     * Range: 0..864010000 (0..86401 sec)
     * Scale: 0.0001
     * Offset: 0
     */
    uint32_t eta_time;

    /**
     * Days_since_January_1,_1970,___Date_is_relative_to_UTC_Time.
     *
     * Range: 0..65532 (0..65532 day)
     * Scale: 1
     * Offset: 0
     */
    uint16_t eta_date;

    /**
     * The_horizontal_direction_of_one_terrestrial_point_from_another,_expressed_as_the_angular_distance_from_a_reference_direction,_measured_from_000_at_the_reference_direction_clockwise_through_359_degrees.
     *
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t baringigin_to_destination_waypoint;

    /**
     * The_horizontal_direction_of_one_terrestrial_point_from_another,_expressed_as_the_angular_distance_from_a_reference_direction,_measured_from_000_at_the_reference_direction_clockwise_through_359_degrees.
     *
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t bearing_pos_to_destination_waypoint;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t origin_waypoint_number;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t destination_waypoint_number;

    /**
     * Range: -90..90 (-90..90 deg)
     * Scale: 1
     * Offset: 0
     */
    int32_t destination_wpt_latitude;

    /**
     * Range: -180..180 (-180..180 deg)
     * Scale: 1
     * Offset: 0
     */
    int32_t destination_wpt_longitude;

    /**
     * Positive_values_represent_ahead_or_starboard_transverse_speed_and_negative_values_represent_astern_or_port_transverse_speed.
     *
     * Range: -32766..32766 (-327.66..327.66 m/s)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t waypoint_closing_velocity;
};

/**
 * Signals in message NMEARqGroupFunction.
 *
 * Rq/Cmd/Acknowledge_Group_type_of_function_is_defined_by_first_fieldMsg_will_be_a_Rq,Cmd,or_Acknowledge_Group_FunctionThese_are_defined_as_follows:_Rq_Group_Function:This_Msg_Rqs_Trans_of_a_specific_set_of_data_in_a_Parameter_Group_by_setting_variable
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_nmea_rq_group_function_t {
    /**
     * 0_=_Request_Message,__1_=_Command_Message,_2_=_Acknowledge_Message
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t group_function_rq_cmd_acknowledge;

    /**
     * 0x0_=_No_Error/Acknowledge,__0x1_=_PGN_not_supported,_0x2_=_PGN_temporarily_not_available,_0x3_=_Access_denied,_0x4_=_Request_is_not_supported.
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pgn_error_code;

    /**
     * 24-bit_Parameter_Group_Number_(PGN)_expressed_in_binary,_LSB_is_transmitted_first
     *
     * Range: 0..16777215 (0..16777215 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t cmded_pgn;

    /**
     * 24-bit_Parameter_Group_Number_(PGN)_expressed_in_binary,_LSB_is_transmitted_first
     *
     * Range: 0..16777215 (0..16777215 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t rqed_pgn;

    /**
     * 24-bit_Parameter_Group_Number_(PGN)_expressed_in_binary,_LSB_is_transmitted_first
     *
     * Range: 0..16777215 (0..16777215 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t rqed_cmded_pgn_being_acknowledged;

    /**
     * 0x0_to_0x7_=_commanded_priority_value_
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t priority_setting;

    /**
     * Time_interval_between_data_transmissions:_0x0_=_Turn-off_transmission__0xFFFF_FFFF_=_Do_not_change_interval
     *
     * Range: 0..4295000000 (0..4295000 sec)
     * Scale: 0.001
     * Offset: 0
     */
    uint32_t trans_interval;

    /**
     * 0x0_=_No_Error/Acknowledge,__0x1_=_Transmit_Interval_/Priority_not_supported,_0x2_=_Transmit_interval_is_less_than_measurement/calculation_interval,_0x3_=_Access_denied._0x4_=_Request_is_not_supported.
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t trans_interval_priority_error_code;

    /**
     * 0x0_=_No_Error/Acknowledge_
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t first_parameter_error_code;

    /**
     * Numeric_count,_event_counter,_sequence_counter
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nmbr_of_prs_of_cmdd_prmeters_to_follow;

    /**
     * 0x0_=_No_Error/Acknowledge_
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vrbl_nmbr_of_flds_fld_nmber6_repeated3;

    /**
     * Numeric_count,_event_counter,_sequence_counter
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t number_of_rqed_cmded_parameters;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feld_number_of_first_cmded_parameter;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vrbl_nmbr_of_flds_fld_nmber6_repeated2;

    /**
     * Offset_in_transmit_time_from_time_of_request_command:_0x0_=_transmit_immediately,_0xFFFF_=_Do_not_change_offset.
     *
     * Range: 0..65532 (0..655.32 sec)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t trans_interval_offset;

    /**
     * Numeric_count,_event_counter,_sequence_counter
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nmbr_of_prs_of_rq_parameters_to_follow;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t field_number_of_first_rqed_parameter;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vrbl_nmbr_of_flds_fld_nmber6_repeated;
};

/**
 * Signals in message MooredBuoyStationData.
 *
 * Moored_buoy_measurement_data_including_station_location_and_numeric_identifier
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_moored_buoy_station_data_t {
    /**
     * Range_Residual_used_in_position_calculation_or_range_residuals_were_calculated_after_the_position.___0=range_residuals_were_used_to_calculate_dat
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mode;

    /**
     * Days_since_January_1,_1970,___Date_is_relative_to_UTC_Time.
     *
     * Range: 0..65532 (0..65532 day)
     * Scale: 1
     * Offset: 0
     */
    uint16_t measurement_date;

    /**
     * 24_hour_clock,_0_=__midnight,__time_is_in_UTC
     *
     * Range: 0..864010000 (0..86401 sec)
     * Scale: 0.0001
     * Offset: 0
     */
    uint32_t measurement_time;

    /**
     * Range: -90..90 (-90..90 deg)
     * Scale: 1
     * Offset: 0
     */
    int32_t station_location_latitude;

    /**
     * Range: -180..180 (-180..180 deg)
     * Scale: 1
     * Offset: 0
     */
    int32_t station_location_longitude;

    /**
     * Range: 0..65532 (0..655.32 m/s)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t wind_speed;

    /**
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t wind_direction;

    /**
     * 0x00_=_True_(referenced_to_North)_0x01_=_Magnetic_0x02_=_Apparent_0x03_=_True_(boat_referenced)_0x04_=_Reserved_0x05_=_Reserved_0x06_=_Error_0x07_=_Null
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t wind_reference;

    /**
     * Peak_wind_gust_speed.__Sustained_wind_over_an_interval_of_5_seconds.
     *
     * Range: 0..65532 (0..655.32 m/s)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t wind_gusts;

    /**
     * Wave_height_is_calculated_as_highest_one-third_of_all_of_wave_heights_during_a_20-minute_sampling_period.Note:Accelerometers_inclinometers_on_board_buoys_measure_heave_acceleration_vertical_displacement_of_buoy_hull_during_wave_acquisition_time.A_Fast_Fou
     *
     * Range: 0..65532 (0..655.32 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t wave_height;

    /**
     * Average_wave_period_of_all_waves_during_a_20-minute_period._Dominant_wave_period_is_the_period_with_the_maximum_wave_energy.__Note:_See_DD50_note.
     *
     * Range: 0..65532 (0..655.32 sec)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t dominate_wave_period;

    /**
     * Range: 0..65532 (0..6553200 Pa)
     * Scale: 100
     * Offset: 0
     */
    uint16_t atmospheric_press;

    /**
     * Positive_value_indicates_Rising,_Negative_value_indicates_Falling.
     *
     * Range: -32764..32764 (-327640..327640 Pa/hr)
     * Scale: 10
     * Offset: 0
     */
    int16_t press_tendency_rate;

    /**
     * Range: 0..65532 (0..655.32 K)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t air_temp;

    /**
     * Range: 0..65532 (0..655.32 K)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t water_temp;

    /**
     * Name_of_place,_route,_waypoint,_destination,_vessel,_vehicle,_etc.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint16_t station_id_string;
};

/**
 * Signals in message MeteorologicalStationData.
 *
 * Meteorological_station_measurement_data_including_station_location,_numeric_identifier,_and_name
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_meteorological_station_data_t {
    /**
     * Range_Residual_used_in_position_calculation_or_range_residuals_were_calculated_after_the_position.___0=range_residuals_were_used_to_calculate_dat
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mode;

    /**
     * Days_since_January_1,_1970,___Date_is_relative_to_UTC_Time.
     *
     * Range: 0..65532 (0..65532 day)
     * Scale: 1
     * Offset: 0
     */
    uint16_t measurement_date;

    /**
     * 24_hour_clock,_0_=__midnight,__time_is_in_UTC
     *
     * Range: 0..864010000 (0..86401 sec)
     * Scale: 0.0001
     * Offset: 0
     */
    uint32_t measurement_time;

    /**
     * Range: -90..90 (-90..90 deg)
     * Scale: 1
     * Offset: 0
     */
    int32_t station_location_latitude;

    /**
     * Range: -180..180 (-180..180 deg)
     * Scale: 1
     * Offset: 0
     */
    int32_t station_location_longitude;

    /**
     * Range: 0..65532 (0..655.32 m/s)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t wind_speed;

    /**
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t wind_direction;

    /**
     * 0x00_=_True_(referenced_to_North)_0x01_=_Magnetic_0x02_=_Apparent_0x03_=_True_(boat_referenced)_0x04_=_Reserved_0x05_=_Reserved_0x06_=_Error_0x07_=_Null
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t wind_reference;

    /**
     * Peak_wind_gust_speed.__Sustained_wind_over_an_interval_of_5_seconds.
     *
     * Range: 0..65532 (0..655.32 m/s)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t wind_gusts;

    /**
     * Range: 0..65532 (0..6553200 Pa)
     * Scale: 100
     * Offset: 0
     */
    uint16_t atmospheric_press;

    /**
     * Range: 0..65532 (0..655.32 K)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t air_temp;

    /**
     * Name_of_place,_route,_waypoint,_destination,_vessel,_vehicle,_etc.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint16_t station_id_string;

    /**
     * Name_of_place,_route,_waypoint,_destination,_vessel,_vehicle,_etc.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint16_t station_name_string;
};

/**
 * Signals in message MagneticVariation.
 *
 * Msg_for_transmitting_variationMsg_contains_a_sequence_number_to_allow_synchronization_of_other_Msgs_such_as_Heading_Course_over_Groundquality_of_service_and_age_of_service_are_provided_to_enable_recipients_to_determine_an_appropriate_level_of_service_if
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_magnetic_variation_t {
    /**
     * An_upward_counting_number_used_to_tie_related_information_together_between_different_PGNs.For_example,SID_would_be_used_to_tie_together_COG,SOG_and_RAIM_values_to_a_given_Pos.255=no_valid_Pos_fix_to_tie_it_to.Range_0_to_250_for_valid_Pos_fixes.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sequence_id_;

    /**
     * 0x00_=_Manual_Entry,_0x01_=_Automatic-Chart,_0x02_=_Automatic_Table,_0x03_=_Automatic_Calculation,_0x04_=_WMM_2000,_0x05_=_WMM_2005,_0x06_=_WMM_2010,_0x07_=_WMM_2015,_0x08_=_WMM_2020,_0x09_=_Reserve,_thru_0x3E_=_Reserve,_0x3F_=_Data_Not_Avail
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t variation_source;

    /**
     * Days_since_January_1,_1970,___Date_is_relative_to_UTC_Time.
     *
     * Range: 0..65532 (0..65532 day)
     * Scale: 1
     * Offset: 0
     */
    uint16_t age_of_service;

    /**
     * Positive_values_are_Easterly_and_negative_values_are_Westerly.
     *
     * Range: -31416..31416 (-3.14159..3.14159 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t variation;
};

/**
 * Signals in message LoranCTDData.
 *
 * This_provides_Time_DifferenceTDlines_of_Pos_of_Loran-C_signals_relative_to_a_single_Group_Repetition_Interval_Field_1,Group_Repetition_IntervalGRI,is_identified_as_a_Rq_parameter_for_this_Parameter_GroupAll_providers_of_this_PGN_shall_accept_and
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_loran_ctd_data_t {
    /**
     * Group_Repetition_Interval_(GRI)_in_nano-sec.__Often_cited_in_units_of_10_micro-sec._(i.e.,_9960_=_99,600,000_ns)
     *
     * Range: -2..2 (-2.14..2.14 sec)
     * Scale: 1
     * Offset: 0
     */
    int32_t group_repetition_interval;

    /**
     * The_actual_propagation_time_of_a_Loran-C_signal_from_the_station_to_a_receiver_in_nano-sec.
     *
     * Range: -2..2 (-2.14..2.14 sec)
     * Scale: 1
     * Offset: 0
     */
    int32_t master_range;

    /**
     * Loran-C_Time_difference_(TD)_in_nano-sec.__The_arrival_time_of_a_Loran-C_secondary_station_signal_minus_the_arrival_time_of_the_master_station_signal.
     *
     * Range: -2..2 (-2.14..2.14 sec)
     * Scale: 1
     * Offset: 0
     */
    int32_t v_second_td;

    /**
     * Loran-C_Time_difference_(TD)_in_nano-sec.__The_arrival_time_of_a_Loran-C_secondary_station_signal_minus_the_arrival_time_of_the_master_station_signal.
     *
     * Range: -2..2 (-2.14..2.14 sec)
     * Scale: 1
     * Offset: 0
     */
    int32_t w_second_td;

    /**
     * Loran-C_Time_difference_(TD)_in_nano-sec.__The_arrival_time_of_a_Loran-C_secondary_station_signal_minus_the_arrival_time_of_the_master_station_signal.
     *
     * Range: -2..2 (-2.14..2.14 sec)
     * Scale: 1
     * Offset: 0
     */
    int32_t x_second_td;

    /**
     * Loran-C_Time_difference_(TD)_in_nano-sec.__The_arrival_time_of_a_Loran-C_secondary_station_signal_minus_the_arrival_time_of_the_master_station_signal.
     *
     * Range: -2..2 (-2.14..2.14 sec)
     * Scale: 1
     * Offset: 0
     */
    int32_t y_second_td;

    /**
     * Loran-C_Time_difference_(TD)_in_nano-sec.__The_arrival_time_of_a_Loran-C_secondary_station_signal_minus_the_arrival_time_of_the_master_station_signal.
     *
     * Range: -2..2 (-2.14..2.14 sec)
     * Scale: 1
     * Offset: 0
     */
    int32_t z_second_td;

    /**
     * MSB:_to_LSB:_xxx1_=_Station_in_use,_xx1x_=_Low_SNR,_x1xx_=_Cycle_error,_1xxx_=_Blink_where_x_=_don't_care
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t station_status_master;

    /**
     * MSB:_to_LSB:_xxx1_=_Station_in_use,_xx1x_=_Low_SNR,_x1xx_=_Cycle_error,_1xxx_=_Blink_where_x_=_don't_care
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t station_status_v;

    /**
     * MSB:_to_LSB:_xxx1_=_Station_in_use,_xx1x_=_Low_SNR,_x1xx_=_Cycle_error,_1xxx_=_Blink_where_x_=_don't_care
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t station_status_w;

    /**
     * MSB:_to_LSB:_xxx1_=_Station_in_use,_xx1x_=_Low_SNR,_x1xx_=_Cycle_error,_1xxx_=_Blink_where_x_=_don't_care
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t station_status_x;

    /**
     * MSB:_to_LSB:_xxx1_=_Station_in_use,_xx1x_=_Low_SNR,_x1xx_=_Cycle_error,_1xxx_=_Blink_where_x_=_don't_care
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t station_status_y;

    /**
     * MSB:_to_LSB:_xxx1_=_Station_in_use,_xx1x_=_Low_SNR,_x1xx_=_Cycle_error,_1xxx_=_Blink_where_x_=_don't_care
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t station_status_z;

    /**
     * Range_Residual_used_in_position_calculation_or_range_residuals_were_calculated_after_the_position.___0=range_residuals_were_used_to_calculate_dat
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mode;
};

/**
 * Signals in message LoranCSignalData.
 *
 * SNR,ECD,and_ASF_values_of_Loran-C_signals_Field_1,Group_Repetition_IntervalGRI,is_identified_as_a_Rq_parameter_for_this_Parameter_GroupAll_providers_of_this_PGN_shall_accept_and_process_Rqs_based_upon_Rqed_value_of_Field_1A_device_receiving_an_IS
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_loran_c_signal_data_t {
    /**
     * Group_Repetition_Interval_(GRI)_in_nano-sec.__Often_cited_in_units_of_10_micro-sec._(i.e.,_9960_=_99,600,000_ns)
     *
     * Range: -2..2 (-2.14..2.14 sec)
     * Scale: 1
     * Offset: 0
     */
    int32_t group_repetition_interval;

    /**
     * 1-character_code_for_the_Loran-C_station:_M_=_master,_V,_W,_X,_Y,_Z
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint8_t station_identifier;
};

/**
 * Signals in message LoranCRangeData.
 *
 * This_provides_Propagation_timesRangesof_Loran-C_signals_relative_to_a_single_Group_Repetition_Interval_Field_1,Group_Repetition_IntervalGRI,is_identified_as_a_Rq_parameter_for_this_Parameter_GroupAll_providers_of_this_PGN_shall_accept_and_proces
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_loran_c_range_data_t {
    /**
     * Group_Repetition_Interval_(GRI)_in_nano-sec.__Often_cited_in_units_of_10_micro-sec._(i.e.,_9960_=_99,600,000_ns)
     *
     * Range: -2..2 (-2.14..2.14 sec)
     * Scale: 1
     * Offset: 0
     */
    int32_t group_repetition_interval;

    /**
     * The_actual_propagation_time_of_a_Loran-C_signal_from_the_station_to_a_receiver_in_nano-sec.
     *
     * Range: -2..2 (-2.14..2.14 sec)
     * Scale: 1
     * Offset: 0
     */
    int32_t master_range;

    /**
     * The_actual_propagation_time_of_a_Loran-C_signal_from_the_station_to_a_receiver_in_nano-sec.
     *
     * Range: -2..2 (-2.14..2.14 sec)
     * Scale: 1
     * Offset: 0
     */
    int32_t v_second_range;

    /**
     * The_actual_propagation_time_of_a_Loran-C_signal_from_the_station_to_a_receiver_in_nano-sec.
     *
     * Range: -2..2 (-2.14..2.14 sec)
     * Scale: 1
     * Offset: 0
     */
    int32_t w_second_range;

    /**
     * The_actual_propagation_time_of_a_Loran-C_signal_from_the_station_to_a_receiver_in_nano-sec.
     *
     * Range: -2..2 (-2.14..2.14 sec)
     * Scale: 1
     * Offset: 0
     */
    int32_t x_second_range;

    /**
     * The_actual_propagation_time_of_a_Loran-C_signal_from_the_station_to_a_receiver_in_nano-sec.
     *
     * Range: -2..2 (-2.14..2.14 sec)
     * Scale: 1
     * Offset: 0
     */
    int32_t y_second_range;

    /**
     * The_actual_propagation_time_of_a_Loran-C_signal_from_the_station_to_a_receiver_in_nano-sec.
     *
     * Range: -2..2 (-2.14..2.14 sec)
     * Scale: 1
     * Offset: 0
     */
    int32_t z_second_range;

    /**
     * MSB:_to_LSB:_xxx1_=_Station_in_use,_xx1x_=_Low_SNR,_x1xx_=_Cycle_error,_1xxx_=_Blink_where_x_=_don't_care
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t station_status_master;

    /**
     * MSB:_to_LSB:_xxx1_=_Station_in_use,_xx1x_=_Low_SNR,_x1xx_=_Cycle_error,_1xxx_=_Blink_where_x_=_don't_care
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t station_status_v;

    /**
     * MSB:_to_LSB:_xxx1_=_Station_in_use,_xx1x_=_Low_SNR,_x1xx_=_Cycle_error,_1xxx_=_Blink_where_x_=_don't_care
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t station_status_w;

    /**
     * MSB:_to_LSB:_xxx1_=_Station_in_use,_xx1x_=_Low_SNR,_x1xx_=_Cycle_error,_1xxx_=_Blink_where_x_=_don't_care
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t station_status_x;

    /**
     * MSB:_to_LSB:_xxx1_=_Station_in_use,_xx1x_=_Low_SNR,_x1xx_=_Cycle_error,_1xxx_=_Blink_where_x_=_don't_care
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t station_status_y;

    /**
     * MSB:_to_LSB:_xxx1_=_Station_in_use,_xx1x_=_Low_SNR,_x1xx_=_Cycle_error,_1xxx_=_Blink_where_x_=_don't_care
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t station_status_z;

    /**
     * Range_Residual_used_in_position_calculation_or_range_residuals_were_calculated_after_the_position.___0=range_residuals_were_used_to_calculate_dat
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mode;
};

/**
 * Signals in message Heading_TrackCtrl.
 *
 * Sends_Cmds_to,and_receives_data_from,heading_Ctrl_systemsAllows_for_navigationalremoteCtrl_of_a_heading_Ctrl_system_and_direct_rudder_CtrlWhen_used_as_a_Cmd,Cmded_Rudder_Direction_field_and_Cmded_Rudder_Angle_should_never_containder_values_at_same_tim
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_heading_track_ctrl_t {
    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rudder_limit_exceeded;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t off_heading_limit_exceeded;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t off_track_limit_exceeded;

    /**
     * 1_=_Yes,0_=_No.Yes_means_a_temporary_interruption_of_selected_Steer_mode.As_long_as_this_field_is_Yes,Steer_Mode_and_Turn_Mode_shall_be_ignored_by_heading/track_Ctrl_and_its_computing_parts_shall_operate_as_if_manual_Steer_was_selected.
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t override;

    /**
     * MSB/LSB:_000_=_Main_Steer,_001_=_Non-Follow-up_Device,_010_=_Follow-up_Device,_011_=_Heading_Ctrl_Standalone,_100_=_Heading_Ctrl,_101_=_Track_Ctrl._Definitions:Main_Steer/Outside_System__main_Steer_system_is_in_use._Non-Follow-up_Device__system_
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t steer_mode;

    /**
     * MSB/LSB:_000_=_Rudder_Limit_Ctrlled,_001_=_turn_rate_Ctrlled,_010_=_radius_Ctrlled._Definitions:Rudder__An_operator_set_rudder_limit_determines_Max_turning_capability_available,in_which_case_system_outputs_rudderders_up_to_and_limited_by_rudder_limit
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t turn_mode;

    /**
     * 0_=_True,__1_=_Magnetic,_2_=_Error,_3_=_Null
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t heading_reference;

    /**
     * MSB/LSB:__000_=_No_Order,_001_=_Move_to_starboard,_010_=_Move_to_port.
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmded_rudder_direction;

    /**
     * Rudder_angle_where_positive_values_are_starboard_and_negative_values_are_port
     *
     * Range: -31416..31416 (-3.14159..3.14159 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t cmded_rudder_angle;

    /**
     * The_horizontal_direction_in_which_a_vessel_is_steered_or_intended_to_be_steered,_expressed_as_angular_distance_000_north,_clockwise_through_359_degrees.__Not_to_be_confused_with_Course-over-ground,_Track,_or_Heading.
     *
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t heading_to_steer;

    /**
     * intended_desired_horizontal_direction_of_travel_with_respect_to_earth.track_expressed_in_degrees_of_compass_may_differ_from_course_due_to_allowances_made_in_course_for_such_factors_as_sea_and_weather_conditions_inder_to_achieve_desired_track.This_field_re
     *
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t track;

    /**
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t rudder_limit;

    /**
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t off_heading_limit;

    /**
     * A_commanded_distance_like_radius_order,_off-track_limit,_etc.
     *
     * Range: -32764..32764 (-32764..32764 m)
     * Scale: 1
     * Offset: 0
     */
    int16_t radius_of_turnder;

    /**
     * +_=_Bow_turning_to_starboard,_1_deg/min_=_.00029_rad/sec
     *
     * Range: -1..1 (-1..1 rad/s)
     * Scale: 1
     * Offset: 0
     */
    int16_t rate_of_turnder;

    /**
     * A_commanded_distance_like_radius_order,_off-track_limit,_etc.
     *
     * Range: -32764..32764 (-32764..32764 m)
     * Scale: 1
     * Offset: 0
     */
    int16_t off_track_limit;

    /**
     * The_horizontal_direction_in_which_a_ship_actually_points_or_heads_at_any_instant,_expressed_in_angular_units_from_a_reference_direction,_usually_from_000_at_the_reference_direction_clockwise_through_359_degrees.
     *
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t vessel_heading;
};

/**
 * Signals in message GPSAlmanacData.
 *
 * This_PGN_provides_a_single_Trans_that_contains_relevant_almanac_data_for_GPS_productsalmanac_contains_satellite_vehicle_coursebital_parametersThis_information_is_not_considered_precise_and_is_only_valid_for_several_months_at_a_timeGPS_products_receive_
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_gps_almanac_data_t {
    /**
     * 0_=_value_not_used,_1-32_=_GPS,_33-64_=_SBAS,Satellite,Based_Augmentation_System(ie_WAAS)_65-96_=_GLONASS._For_GLONASS,satellites_are_identified_by_64+satellite_slot_number.slot_numbers_are_1_through_24_for_full_GLONASS_constellation_of_24_satellite
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t prn;

    /**
     * GPS_week_number._Starting_on_6_Jan.,_1980.__The_GPS_week_number_roll_over_will_not_affect_this_value,_i.e.,_it_will_continue_to_count_up_1022,_1023,_1024,_1025.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t gps_week_number;

    /**
     * SV_health,_bits_17-24_of_each_almanac_page.__Reference_ICD-GPS-200_paragraph_20.3.3.5.1.3,_Table_20-VII_and_Table_20-VIII
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sv_health_bits;

    /**
     * Eccentricity,_e.__Reference_ICD-GPS-200_Table_20-VI_for_scaling_factors_and_units.
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t eccentricity;

    /**
     * Almanac_reference_time.__Reference_ICD-GPS-200_Table_20-VI_for_scaling_factors_and_units.
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t almanac_reference_time;

    /**
     * Inclination_angle.__Reference_ICD-GPS-200_Table_20-VI_for_scaling_factors_and_units.
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t inclination_angle;

    /**
     * Rate_of_right_ascension,_OMEGADOT.__Reference_ICD-GPS-200_Table_20-VI_for_scaling_factors_and_units.
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t rate_of_right_ascension;

    /**
     * Root_of_semi-major_axis.__Reference_ICD-GPS-200_Table_20-VI_for_scaling_factors_and_units.
     *
     * Range: 0..16777215 (0..16777215 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t root_of_semimajor_axis;

    /**
     * Argument_of_Perigee.__Reference_ICD-GPS-200_Table_20-VI_for_scaling_factors_and_units.
     *
     * Range: 0..16777215 (0..16777215 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t argument_of_perigee;

    /**
     * Longitude_of_ascension_node.__Reference_ICD-GPS-200_Table_20-VI_for_scaling_factors_and_units.
     *
     * Range: 0..16777215 (0..16777215 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t longitude_of_ascension_node;

    /**
     * Mean_anomaly.__Reference_ICD-GPS-200_Table_20-VI_for_scaling_factors_and_units.
     *
     * Range: 0..16777215 (0..16777215 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t mean_anomaly;

    /**
     * Clock_Parameter_1.__Reference_ICD-GPS-200_Table_20-VI_for_scaling_factors_and_units.
     *
     * Range: 0..2047 (0..2047 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t clock_parameter1;

    /**
     * Clock_Parameter_2.__Reference_ICD-GPS-200_Table_20-VI_for_scaling_factors_and_units.
     *
     * Range: 0..2047 (0..2047 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t clock_parameter2;
};

/**
 * Signals in message GNSSSatsInView.
 *
 * GNSS_information_on_current_satellites_in_view_tagged_by_sequence_IDInformation_includes_PRN,elevation,azimuth,and_SNRField_4_defines_number_of_satellitesFields_5_thru_11_define_satellite_number_and_informationThese_fields_sequentially_repeated_for_ea
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_gnss_sats_in_view_t {
    /**
     * An_upward_counting_number_used_to_tie_related_information_together_between_different_PGNs.For_example,SID_would_be_used_to_tie_together_COG,SOG_and_RAIM_values_to_a_given_Pos.255=no_valid_Pos_fix_to_tie_it_to.Range_0_to_250_for_valid_Pos_fixes.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sid;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t range_residual_mode;

    /**
     * Numeric_count,_event_counter,_sequence_counter
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t number_of_s_vs_;

    /**
     * 0_=_value_not_used,_1-32_=_GPS,_33-64_=_SBAS,Satellite,Based_Augmentation_System(ie_WAAS)_65-96_=_GLONASS._For_GLONASS,satellites_are_identified_by_64+satellite_slot_number.slot_numbers_are_1_through_24_for_full_GLONASS_constellation_of_24_satellite
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t prn1;

    /**
     * Angle_above_or_below_the_horizon._-90_to_+90_negative_below_the_horizon
     *
     * Range: -31416..31416 (-3.14159..3.14159 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t elevation1;

    /**
     * Degrees_clockwise_relative_to_True_North.
     *
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t azimuth1;

    /**
     * Range: -32764..32764 (-327.64..327.64 dB)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t snr1;

    /**
     * Range: -2147000000..2147000000 (-21470..21470 m)
     * Scale: 1e-05
     * Offset: 0
     */
    int32_t range_residuals1;

    /**
     * 0___=_Not_Tracked,_1_=_Tracked_but_not_used_in_solution,_2_=_Used_in_solution_without_Diff_corrections,_3_=_Diff_Corrections_available,_4_=_Tracked_with_Diff_Corrections,_5_=_used_with_Diff_Corrections,_6-13_=Reserved,_14_=_E
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t prn_status1;

    /**
     * 0_=_value_not_used,_1-32_=_GPS,_33-64_=_SBAS,Satellite,Based_Augmentation_System(ie_WAAS)_65-96_=_GLONASS._For_GLONASS,satellites_are_identified_by_64+satellite_slot_number.slot_numbers_are_1_through_24_for_full_GLONASS_constellation_of_24_satellite
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t prnn;

    /**
     * Angle_above_or_below_the_horizon._-90_to_+90_negative_below_the_horizon
     *
     * Range: -31416..31416 (-3.14159..3.14159 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t elevation_n;

    /**
     * Degrees_clockwise_relative_to_True_North.
     *
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t azimuth_n;

    /**
     * Range: -32764..32764 (-327.64..327.64 dB)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t snrn;

    /**
     * Range: -2147000000..2147000000 (-21470..21470 m)
     * Scale: 1e-05
     * Offset: 0
     */
    int32_t range_residuals_n;

    /**
     * 0___=_Not_Tracked,_1_=_Tracked_but_not_used_in_solution,_2_=_Used_in_solution_without_Diff_corrections,_3_=_Diff_Corrections_available,_4_=_Tracked_with_Diff_Corrections,_5_=_used_with_Diff_Corrections,_6-13_=Reserved,_14_=_E
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t prn_status_n;
};

/**
 * Signals in message GNSSRAIMSettings.
 *
 * This_PGN_is_used_to_report_the_control_parameters_for_a_GNSS_Receiver_Autonomous_Integrity_Monitoring_RAIM_process__The_Command_Group_Function_PGN_126208_provides_the_means_to_set_these_values_over_the_network
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_gnssraim_settings_t {
    /**
     * Error_distances_expressed_in_meters.
     *
     * Range: 0..65532 (0..655.32 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t radial_pos_error_max_threshold;

    /**
     * Range: -124..124 (-124..124 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t probability_of_false_alarm;

    /**
     * Range: -124..124 (-124..124 %)
     * Scale: 1
     * Offset: 0
     */
    int8_t probability_of_missed_detection;

    /**
     * Range: 0..65532 (0..65532 sec)
     * Scale: 1
     * Offset: 0
     */
    uint16_t psdrng_rsdl_filtering_time_constant;
};

/**
 * Signals in message BringAndDistanceBetweenTwoMarks.
 *
 * Bearing_and_distance_from_the_origin_mark_to_the_destination_mark,_calculated_at_the_origin_mark,_for_any_two_arbitrary_generic_marks_The_calculation_type_Rhumb_Line,_Great_Circle_is_specified,_as_well_as_the_bearing_reference_Mag,_True
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_bring_and_distance_between_two_marks_t {
    /**
     * An_upward_counting_number_used_to_tie_related_information_together_between_different_PGNs.For_example,SID_would_be_used_to_tie_together_COG,SOG_and_RAIM_values_to_a_given_Pos.255=no_valid_Pos_fix_to_tie_it_to.Range_0_to_250_for_valid_Pos_fixes.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sid;

    /**
     * 0_=_True,__1_=_Magnetic,_2_=_Error,_3_=_Null
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bearing_ref;

    /**
     * 0_=_Great_Circle_calculations,__1_=_Rhumb_Line_calculations,_2_=_Error,_3_=_Null
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t calculation_type;

    /**
     * The_horizontal_direction_of_one_terrestrial_point_from_another,_expressed_as_the_angular_distance_from_a_reference_direction,_measured_from_000_at_the_reference_direction_clockwise_through_359_degrees.
     *
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t bearingigin_to_destination;

    /**
     * Range: -2147000000..2147000000 (-21470000..21470000 m)
     * Scale: 0.01
     * Offset: 0
     */
    int32_t distance;

    /**
     * 0___=_Collision,__1_=_Turning_Point,_2_=_Reference_(general),_3_=_Wheelover,_4_=_Waypoint,_5-13_=_Reserved,_14_=_Error,_15_=_Null
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t origin_mark_type;

    /**
     * 0___=_Collision,__1_=_Turning_Point,_2_=_Reference_(general),_3_=_Wheelover,_4_=_Waypoint,_5-13_=_Reserved,_14_=_Error,_15_=_Null
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t destination_mark_type;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t origin_mark_id;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t destination_mark_id;
};

/**
 * Signals in message BinarySwitchBankStatus.
 *
 * Universal_status_report_for_multiple_banks_of_two-state_indicators
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_binary_switch_bank_status_t {
    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t indicator_bank_instance;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t indic1;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t indic2;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t indic3;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t indic4;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t indic5;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t indic6;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t indic7;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t indic8;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t indic9;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t indic10;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t indic11;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t indic12;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t indic13;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t indic14;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t indic15;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t indic16;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t indic17;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t indic18;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t indic19;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t indic20;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t indic21;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t indic22;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t indic23;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t indic24;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t indic25;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t indic26;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t indic27;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t indic28;
};

/**
 * Signals in message BatteryStatus.
 *
 * Provides_parametric_data_for_a_specific_battery,_indicated_by_the_battery_instance_field_Used_primarily_by_display_or_instrumentation_devices,_but_may_also_be_used_by_battery_management_controls
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_battery_status_t {
    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t battery_instance;

    /**
     * Range: -32764..32764 (-327.64..327.64 V)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t battery_potential;

    /**
     * +_=_current_consumed,_-_=_current_supplied
     *
     * Range: -32764..32764 (-3276.4..3276.4 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t battery_current;

    /**
     * Range: 0..65532 (0..655.32 K)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t battery_case_temp;

    /**
     * An_upward_counting_number_used_to_tie_related_information_together_between_different_PGNs.For_example,SID_would_be_used_to_tie_together_COG,SOG_and_RAIM_values_to_a_given_Pos.255=no_valid_Pos_fix_to_tie_it_to.Range_0_to_250_for_valid_Pos_fixes.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sid;
};

/**
 * Signals in message Attitude.
 *
 * This_PGN_provides_a_single_Trans_that_describes_Pos_of_a_vessel_relative_to_both_horizontal_and_vertical_planesThis_would_typically_be_used_for_vessel_stabilization,vessel_Ctrl_and_onboard_platform_stabilization_Products_that_directly_interface_to_pi
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_attitude_t {
    /**
     * An_upward_counting_number_used_to_tie_related_information_together_between_different_PGNs.For_example,SID_would_be_used_to_tie_together_COG,SOG_and_RAIM_values_to_a_given_Pos.255=no_valid_Pos_fix_to_tie_it_to.Range_0_to_250_for_valid_Pos_fixes.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sid;

    /**
     * Oscillation_of_ship_about_it's_vertical_axis.__Bow_moving_to_starboard_is_positive.
     *
     * Range: -31416..31416 (-3.14159..3.14159 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t yaw;

    /**
     * Oscillation_of_ship_about_it's_latitudinal_axis.__Bow_moving_up_is_positive.
     *
     * Range: -31416..31416 (-3.14159..3.14159 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t pitch_;

    /**
     * Oscillation_of_ship_about_it's_longitudinal_axis.__Roll_to_the_starboard_is_positive.
     *
     * Range: -31416..31416 (-3.14159..3.14159 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t roll;
};

/**
 * Signals in message AlttdDltHghPrecisionRapidUpdate.
 *
 * TheAltitude_Delta,High_Precision_Rapid_UpdateParameter_Group_is_intended_for_Apps_where_very_high_precision_and_very_fast_update_rates_are_needed_for_altitude_and_course_over_ground_dataThis_PG_can_provide_delta_altitude_changes_down_to_1_millimeter,a_
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_alttd_dlt_hgh_precision_rapid_update_t {
    /**
     * An_upward_counting_number_used_to_tie_related_information_together_between_different_PGNs.For_example,SID_would_be_used_to_tie_together_COG,SOG_and_RAIM_values_to_a_given_Pos.255=no_valid_Pos_fix_to_tie_it_to.Range_0_to_250_for_valid_Pos_fixes.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sequence_id_;

    /**
     * Range: 0..252 (0..1.26 sec)
     * Scale: 0.005
     * Offset: 0
     */
    uint8_t time_delta;

    /**
     * 0_=_no_GPS,_1_=_GNSS_fix,_2_=_DGNSS_fix,_3_=_Precise_GNSS*,_4_=_RTK_Fixed_Integer,_5_=_RTK_Float,_6_=_Est(DR)mode,_7_=_Manual_Input,_8_=_Simulate_mode,_9-13_=_Reserved,_14_=_Error,_15_=_Null.*Precise_GNSS_means_no_deliberate_degradation(such_as
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t gnss_quality;

    /**
     * 0_=_True,__1_=_Magnetic,_2_=_Error,_3_=_Null
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t direction;

    /**
     * The_direction_of_the_path_over_ground_actually_followed_by_a_vessel.
     *
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t course_over_ground;

    /**
     * Range: -8388000..8388000 (-8388..8388 m)
     * Scale: 0.001
     * Offset: 0
     */
    int32_t altitude_delta;
};

/**
 * Signals in message AISUTC_DateInquiry.
 *
 * This_parameter_group_provides_data_associated_with_ITU-R_M1371_Msg_10_UTC_and_Date_Inquiry_Msg_used_to_Rq_current_UTC_and_dateAn_AIS_device_may_generate_this_parameter_group_either_upon_receiving_a_VHF_data_link_Msg_10,or_upon_receipt_of_an_ISO_NMEA_Rq_
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_aisutc_date_inquiry_t {
    /**
     * Message_Identifier_(range_of_0_to_63)._See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t msg_id;

    /**
     * Used_by_the_repeater_to_indicate_how_many_times_a_message_has_been_repeated_(range_of_0_to_3)._0_=_Default_1_=_First_retransmission_2_=_Second_retransmission_3_=_Final_retransmission_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t repeat_indicator;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t source_id;

    /**
     * 0_=_Channel_A_VDL_reception,_1_=_Channel_B_VDL_reception,_2_=_Channel_A_VDL_transmission,_3_=_Channel_B_VDL_transmission,_4_=_Own_information_not_broadcast,_5-31_=_Reserved.
     *
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ais_transceiver_information;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t destination_id;
};

/**
 * Signals in message AISUTCAndDateReport.
 *
 * This_parameter_group_provides_data_from_ITU-R_M1371_Msg_4_Base_Station_Report_providing_Pos,time,date,and_current_slot_number_of_a_base_station,and_11_UTC_and_date_Resp_Msg_providing_current_UTC_and_date_if_availableAn_AIS_device_may_generate_this_param
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_aisutc_and_date_report_t {
    /**
     * Message_Identifier_(range_of_0_to_63)._See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t msg_id;

    /**
     * Used_by_the_repeater_to_indicate_how_many_times_a_message_has_been_repeated_(range_of_0_to_3)._0_=_Default_1_=_First_retransmission_2_=_Second_retransmission_3_=_Final_retransmission_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t repeat_indicator;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t user_id;

    /**
     * Range: -180..180 (-180..180 deg)
     * Scale: 1
     * Offset: 0
     */
    int32_t longitude_;

    /**
     * Range: -90..90 (-90..90 deg)
     * Scale: 1
     * Offset: 0
     */
    int32_t latitude_;

    /**
     * 0=low_accuracy>10m_such_as_nondifferential_GNSS_(default),__1=high_accuracy_<10m_such_as_DGNSS_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pos_accuracy;

    /**
     * 0_=_RAIM_not_in_use_(default),_1_=_RAIM_in_use_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rai_mflag;

    /**
     * 24_hour_clock,_0_=__midnight,__time_is_in_UTC
     *
     * Range: 0..864010000 (0..86401 sec)
     * Scale: 0.0001
     * Offset: 0
     */
    uint32_t pos_time;

    /**
     * The_Communication_State_contains_information_used_by_the_various_TDMA_slot_allocation_algorithms_and_synchronization_information_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..524287 (0..524287 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t communication_state;

    /**
     * 0_=_Channel_A_VDL_reception,_1_=_Channel_B_VDL_reception,_2_=_Channel_A_VDL_transmission,_3_=_Channel_B_VDL_transmission,_4_=_Own_information_not_broadcast,_5-31_=_Reserved.
     *
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ais_transceiver_information;

    /**
     * Days_since_January_1,_1970,___Date_is_relative_to_UTC_Time.
     *
     * Range: 0..65532 (0..65532 day)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_date;

    /**
     * 0=Undefined_(default),__1=GPS,_2=GLONASS,_3=Combined_GPS/GLONASS,_4=Loran-C,_5=Chayka,_6=Integrated_Navigation_System,_7=Surveyed_(Base_Station),_8-15=Reserve_for_future_use._See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t type_of_electronic_posing_device;
};

/**
 * Signals in message AISSafetyRelatedBroadcastMsg.
 *
 * This_parameter_group_provides_data_associated_with_ITU-R_M1371_Msg_14_Safety_Related_Broadcast_Msg_supporting_broadcast_communication_of_safety_related_dataAn_AIS_device_may_generate_this_parameter_group_either_upon_receiving_a_VHF_data_link_Msg_14,or_u
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_ais_safety_related_broadcast_msg_t {
    /**
     * Message_Identifier_(range_of_0_to_63)._See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t msg_id;

    /**
     * Used_by_the_repeater_to_indicate_how_many_times_a_message_has_been_repeated_(range_of_0_to_3)._0_=_Default_1_=_First_retransmission_2_=_Second_retransmission_3_=_Final_retransmission_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t repeat_indicator;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t source_id;

    /**
     * 0_=_Channel_A_VDL_reception,_1_=_Channel_B_VDL_reception,_2_=_Channel_A_VDL_transmission,_3_=_Channel_B_VDL_transmission,_4_=_Own_information_not_broadcast,_5-31_=_Reserved.
     *
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ais_transceiver_information;

    /**
     * Name_of_place,_route,_waypoint,_destination,_vessel,_vehicle,_etc.
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t safety_related_text;
};

/**
 * Signals in message AISSARAircraftPosReport.
 *
 * This_parameter_group_provides_data_associated_with_ITU-R_M1371_Msg_9_SAR_Aircraft_Pos_Report_Msg_for_Airborne_AIS_units_conducting_Search_and_Rescue_operationsAn_AIS_device_may_generate_this_parameter_group_either_upon_receiving_a_VHF_data_link_Msg_9,or
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_aissar_aircraft_pos_report_t {
    /**
     * Message_Identifier_(range_of_0_to_63)._See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t msg_id;

    /**
     * Used_by_the_repeater_to_indicate_how_many_times_a_message_has_been_repeated_(range_of_0_to_3)._0_=_Default_1_=_First_retransmission_2_=_Second_retransmission_3_=_Final_retransmission_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t repeat_indicator;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t user_id;

    /**
     * Range: -180..180 (-180..180 deg)
     * Scale: 1
     * Offset: 0
     */
    int32_t longitude_;

    /**
     * Range: -90..90 (-90..90 deg)
     * Scale: 1
     * Offset: 0
     */
    int32_t latitude_;

    /**
     * 0=low_accuracy>10m_such_as_nondifferential_GNSS_(default),__1=high_accuracy_<10m_such_as_DGNSS_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pos_accuracy;

    /**
     * 0_=_RAIM_not_in_use_(default),_1_=_RAIM_in_use_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t raim_flag;

    /**
     * 0-59=UTC_second_when_report_was_generated,_60=time_stamp_not_available(default),_61=Posing_system_is_in_manual_input_mode,_62=Electronic_Pos_fixing_system_operates_in_Est(dead_reckoning)mode,_63=Posing_system_is_inoperative_See_ITU-R_M.1371-1_for_m
     *
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t time_stamp;

    /**
     * The_direction_of_the_path_over_ground_actually_followed_by_a_vessel.
     *
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t cog;

    /**
     * Range: 0..65532 (0..655.32 m/s)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t sog;

    /**
     * The_Communication_State_contains_information_used_by_the_various_TDMA_slot_allocation_algorithms_and_synchronization_information_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..524287 (0..524287 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t communication_state;

    /**
     * 0_=_Channel_A_VDL_reception,_1_=_Channel_B_VDL_reception,_2_=_Channel_A_VDL_transmission,_3_=_Channel_B_VDL_transmission,_4_=_Own_information_not_broadcast,_5-31_=_Reserved.
     *
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ais_transceiver_information;

    /**
     * Range: -2147000000..2147000000 (-21470000..21470000 m)
     * Scale: 0.01
     * Offset: 0
     */
    int32_t altitude_;

    /**
     * 0=Available,_1=not_available._See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_terminal_equipment;
};

/**
 * Signals in message AISInterrogation.
 *
 * This_parameter_group_provides_data_associated_with_ITU-R_M1371_Msg_15_Interrogation_Msg_used_to_Rq_a_specific_ITU-R_M1371_Msg_resulting_in_Resps_from_one_more_AIS_mobile_unitsAn_AIS_device_may_generate_this_parameter_group_either_upon_receiving_a_VHF_d
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_ais_interrogation_t {
    /**
     * Message_Identifier_(range_of_0_to_63)._See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t msg_id;

    /**
     * Used_by_the_repeater_to_indicate_how_many_times_a_message_has_been_repeated_(range_of_0_to_3)._0_=_Default_1_=_First_retransmission_2_=_Second_retransmission_3_=_Final_retransmission_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t repeat_indicator;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t source_id;

    /**
     * 0_=_Channel_A_VDL_reception,_1_=_Channel_B_VDL_reception,_2_=_Channel_A_VDL_transmission,_3_=_Channel_B_VDL_transmission,_4_=_Own_information_not_broadcast,_5-31_=_Reserved.
     *
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ais_transceiver_information;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t destination_id1;

    /**
     * Message_Identifier_(range_of_0_to_63)._See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t msg_id11;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t slot_offset11;

    /**
     * Message_Identifier_(range_of_0_to_63)._See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t msg_id12;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t slot_offset12;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t destination_id2;

    /**
     * Message_Identifier_(range_of_0_to_63)._See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t msg_id21;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t slot_offset21;
};

/**
 * Signals in message AISDataLinkManagementMsg.
 *
 * This_parameter_group_provides_data_associated_with_ITU-R_M1371_Msg_20_Data_Link_Management_Msg_for_reserving_slots_for_base_stationsAn_AIS_device_may_generate_this_parameter_group_either_upon_receiving_a_VHF_data_link_Msg_20,or_upon_receipt_of_an_ISO_NM
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_ais_data_link_management_msg_t {
    /**
     * Message_Identifier_(range_of_0_to_63)._See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t msg_id;

    /**
     * Used_by_the_repeater_to_indicate_how_many_times_a_message_has_been_repeated_(range_of_0_to_3)._0_=_Default_1_=_First_retransmission_2_=_Second_retransmission_3_=_Final_retransmission_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t repeat_indicator;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t source_station_id;

    /**
     * 0_=_Channel_A_VDL_reception,_1_=_Channel_B_VDL_reception,_2_=_Channel_A_VDL_transmission,_3_=_Channel_B_VDL_transmission,_4_=_Own_information_not_broadcast,_5-31_=_Reserved.
     *
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ais_transceiver_information;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t offset_number1;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t number_of_slots1;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t time_out1;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t increment1;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t offset_number2;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t number_of_slots2;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t time_out2;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t increment2;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t offset_number3;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t number_of_slots3;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t time_out3;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t increment3;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t offset_number4;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t number_of_slots4;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t time_out4;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t increment4;
};

/**
 * Signals in message AISDGNSSBroadcastBinaryMsg.
 *
 * This_parameter_group_provides_data_associated_with_ITU-R_M1371_Msg_17_GNSS_Broadcast_Binary_Msg_containing_DGNSS_corrections_from_a_base_stationAn_AIS_device_may_generate_this_parameter_group_either_upon_receiving_a_VHF_data_link_Msg_17,or_upon_receipt_
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_aisdgnss_broadcast_binary_msg_t {
    /**
     * Message_Identifier_(range_of_0_to_63)._See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t msg_id;

    /**
     * Used_by_the_repeater_to_indicate_how_many_times_a_message_has_been_repeated_(range_of_0_to_3)._0_=_Default_1_=_First_retransmission_2_=_Second_retransmission_3_=_Final_retransmission_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t repeat_indicator;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t source_id;

    /**
     * 0_=_Channel_A_VDL_reception,_1_=_Channel_B_VDL_reception,_2_=_Channel_A_VDL_transmission,_3_=_Channel_B_VDL_transmission,_4_=_Own_information_not_broadcast,_5-31_=_Reserved.
     *
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ais_transceiver_information;

    /**
     * Range: -180..180 (-180..180 deg)
     * Scale: 1
     * Offset: 0
     */
    int32_t longitude_;

    /**
     * Range: -90..90 (-90..90 deg)
     * Scale: 1
     * Offset: 0
     */
    int32_t latitude_;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t number_of_bits_in_binary_data_field;
};

/**
 * Signals in message AISClssASttcAndVyageRelatedData.
 *
 * This_parameter_group_provides_data_associated_with_ITU-R_M1371_Msg_5_Ship_Static_and_Voyage_Related_Data_MsgAn_AIS_device_may_generate_this_parameter_group_either_upon_receiving_a_VHF_data_link_Msg_5,or_upon_receipt_of_an_ISO_NMEA_Rq_PGNCmd_Group_Funct
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_ais_clss_a_sttc_and_vyage_related_data_t {
    /**
     * Message_Identifier_(range_of_0_to_63)._See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t msg_id;

    /**
     * Used_by_the_repeater_to_indicate_how_many_times_a_message_has_been_repeated_(range_of_0_to_3)._0_=_Default_1_=_First_retransmission_2_=_Second_retransmission_3_=_Final_retransmission_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t repeat_indicator;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t user_id;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t imo;

    /**
     * Length_specified_by_PGN_field_definition.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint64_t call_sign;

    /**
     * Name_of_place,_route,_waypoint,_destination,_vessel,_vehicle,_etc.
     *
     * Range: 0..65535 (0..65535 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint64_t name;

    /**
     * Length_specified_by_PGN_field_definition.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint64_t destination;
};

/**
 * Signals in message AISClassBPosReport.
 *
 * This_parameter_group_provides_data_associated_with_ITU-R_M1371_Msg_18_Standard_Class_B_Equipment_Pos_ReportAn_AIS_device_may_generate_this_parameter_group_either_upon_receiving_a_VHF_data_link_Msg_18,or_upon_receipt_of_an_ISO_NMEA_Rq_PGNsee_ITU-R_M137
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_ais_class_b_pos_report_t {
    /**
     * Message_Identifier_(range_of_0_to_63)._See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t msg_id;

    /**
     * Used_by_the_repeater_to_indicate_how_many_times_a_message_has_been_repeated_(range_of_0_to_3)._0_=_Default_1_=_First_retransmission_2_=_Second_retransmission_3_=_Final_retransmission_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t repeat_indicator;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t user_id;

    /**
     * Range: -180..180 (-180..180 deg)
     * Scale: 1
     * Offset: 0
     */
    int32_t longitude_;

    /**
     * Range: -90..90 (-90..90 deg)
     * Scale: 1
     * Offset: 0
     */
    int32_t latitude_;

    /**
     * 0=low_accuracy>10m_such_as_nondifferential_GNSS_(default),__1=high_accuracy_<10m_such_as_DGNSS_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pos_accuracy;

    /**
     * 0_=_RAIM_not_in_use_(default),_1_=_RAIM_in_use_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rai_mflag;

    /**
     * 0-59=UTC_second_when_report_was_generated,_60=time_stamp_not_available(default),_61=Posing_system_is_in_manual_input_mode,_62=Electronic_Pos_fixing_system_operates_in_Est(dead_reckoning)mode,_63=Posing_system_is_inoperative_See_ITU-R_M.1371-1_for_m
     *
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t time_stamp;

    /**
     * The_direction_of_the_path_over_ground_actually_followed_by_a_vessel.
     *
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t cog;

    /**
     * Range: 0..65532 (0..655.32 m/s)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t sog;

    /**
     * The_Communication_State_contains_information_used_by_the_various_TDMA_slot_allocation_algorithms_and_synchronization_information_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..524287 (0..524287 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t communication_state;

    /**
     * 0_=_Channel_A_VDL_reception,_1_=_Channel_B_VDL_reception,_2_=_Channel_A_VDL_transmission,_3_=_Channel_B_VDL_transmission,_4_=_Own_information_not_broadcast,_5-31_=_Reserved.
     *
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ais_transceiver_information;

    /**
     * Degrees_clockwise_relative_to_True_North.
     *
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t true_heading;

    /**
     * 0=SOTDMA_communication_state,_1=ITDMA_communication_state_follows._See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t comminication_state_selector_flag;
};

/**
 * Signals in message AISClassBExPosReport.
 *
 * This_parameter_group_provides_data_associated_with_ITU-R_M1371_Msg_19_Ex_Class_B_Equipment_Pos_Report_containing_Pos_and_static_informationAn_AIS_device_may_generate_this_parameter_group_either_upon_receiving_a_VHF_data_link_Msg_19,or_upon_receipt_of_an
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_ais_class_b_ex_pos_report_t {
    /**
     * Message_Identifier_(range_of_0_to_63)._See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t msg_id;

    /**
     * Used_by_the_repeater_to_indicate_how_many_times_a_message_has_been_repeated_(range_of_0_to_3)._0_=_Default_1_=_First_retransmission_2_=_Second_retransmission_3_=_Final_retransmission_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t repeat_indicator;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t user_id;

    /**
     * Range: -180..180 (-180..180 deg)
     * Scale: 1
     * Offset: 0
     */
    int32_t longitude_;

    /**
     * Range: -90..90 (-90..90 deg)
     * Scale: 1
     * Offset: 0
     */
    int32_t latitude_;

    /**
     * 0=low_accuracy>10m_such_as_nondifferential_GNSS_(default),__1=high_accuracy_<10m_such_as_DGNSS_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pos_accuracy;

    /**
     * 0_=_RAIM_not_in_use_(default),_1_=_RAIM_in_use_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rai_mflag;

    /**
     * 0-59=UTC_second_when_report_was_generated,_60=time_stamp_not_available(default),_61=Posing_system_is_in_manual_input_mode,_62=Electronic_Pos_fixing_system_operates_in_Est(dead_reckoning)mode,_63=Posing_system_is_inoperative_See_ITU-R_M.1371-1_for_m
     *
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t time_stamp;

    /**
     * The_direction_of_the_path_over_ground_actually_followed_by_a_vessel.
     *
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t cog;

    /**
     * Range: 0..65532 (0..655.32 m/s)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t sog;

    /**
     * 0=Not_Available_or_no_ship_(default),__1-99=_(See_ITU-R_M.1371-1_Section_3.3.8.2.3.2_Table_18),_100-199=Reserved_for_Regional_(See_ITU-R_M.1371-1),_200-255=Reserved_for_future_(See_ITU-R_M.1371-1).
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ship_cargo_type;

    /**
     * Degrees_clockwise_relative_to_True_North.
     *
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t true_heading;

    /**
     * 0=Undefined_(default),__1=GPS,_2=GLONASS,_3=Combined_GPS/GLONASS,_4=Loran-C,_5=Chayka,_6=Integrated_Navigation_System,_7=Surveyed_(Base_Station),_8-15=Reserve_for_future_use._See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t type_of_electronic_posing_device;

    /**
     * Dependent_upon_PG_Field_definition.
     *
     * Range: 0..65532 (0..6553.2 m)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t ship_length;

    /**
     * Dependent_upon_PG_Field_definition.
     *
     * Range: 0..65532 (0..6553.2 m)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t ship_beam;

    /**
     * Dependent_upon_PG_Field_definition.
     *
     * Range: 0..65532 (0..6553.2 m)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t pos_reference_point_from_starboard;

    /**
     * Dependent_upon_PG_Field_definition.
     *
     * Range: 0..65532 (0..6553.2 m)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t pos_reference_point_aft_of_ships_bow;

    /**
     * Name_of_place,_route,_waypoint,_destination,_vessel,_vehicle,_etc.
     *
     * Range: 0..65535 (0..65535 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint64_t name;
};

/**
 * Signals in message CA.
 *
 * Commanded_Address
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_ca_t {
    /**
     * Range: 0..2097152 (0..2097152 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t identity_number;

    /**
     * Assigned_by_NMEA_2000_Committee
     *
     * Range: 0..2047 (0..2047 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t manufacturer_code;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecu_instance;

    /**
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t function_instance;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t function;

    /**
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vehicle_system;

    /**
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vehicle_system5;

    /**
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vehicle_system4;

    /**
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vehicle_system3;

    /**
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vehicle_system2;

    /**
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vehicle_system1;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vehicle_system_instance;

    /**
     * 0_=_Global_
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t industry_group;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t arbitrary_address_capable;

    /**
     * The_source_address_that_is_to_be_assigned_to_the_CA_that_has_the_NAME_corresponding_to_the_one_conveyed_in_the_first_eight_bytes_of_this_Commanded_Address_message.
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t address_assignment;
};

/**
 * Signals in message ACL.
 *
 * Address_Claimed
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_acl_t {
    /**
     * Range: 0..2097152 (0..2097152 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t identity_number;

    /**
     * Assigned_by_NMEA_2000_Committee
     *
     * Range: 0..2047 (0..2047 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t manufacturer_code;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecu_instance;

    /**
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t function_instance;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t function;

    /**
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vehicle_system;

    /**
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vehicle_system5;

    /**
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vehicle_system4;

    /**
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vehicle_system3;

    /**
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vehicle_system2;

    /**
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vehicle_system1;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vehicle_system_instance;

    /**
     * 0_=_Global_
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t industry_group;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t arbitrary_address_capable;
};

/**
 * Signals in message TPDT.
 *
 * Transport_Protocol_-_Data_Transfer
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_tpdt_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sequence_number;
};

/**
 * Signals in message TPCM.
 *
 * Transport_Protocol_-_Connection_Management
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_tpcm_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t control_byte;

    /**
     * Total_message_size_(in_bytes)_for_BAM_message.Total_message_size_(in_bytes)_for_RTS/CTS_message.Total_message_size_(in_bytes)_for_RTS/CTS_message.
     *
     * Range: 0..64255 (0..64255 counts)
     * Scale: 1
     * Offset: 0
     */
    uint16_t total_message_size_eo_ma;

    /**
     * Total_message_size_(in_bytes)_for_BAM_message.Total_message_size_(in_bytes)_for_RTS/CTS_message.Total_message_size_(in_bytes)_for_RTS/CTS_message.
     *
     * Range: 0..64255 (0..64255 counts)
     * Scale: 1
     * Offset: 0
     */
    uint16_t total_message_size_bam;

    /**
     * Reason_for_connection_abort_message.
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t connection_abort_reason;

    /**
     * Number_of_Packets_that_can_be_sent_(TP.CM_CTS)
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t number_of_packets_that_can_be_sent;

    /**
     * Total_message_size_(in_bytes)_for_BAM_message.Total_message_size_(in_bytes)_for_RTS/CTS_message.Total_message_size_(in_bytes)_for_RTS/CTS_message.
     *
     * Range: 0..64255 (0..64255 counts)
     * Scale: 1
     * Offset: 0
     */
    uint16_t total_message_size;

    /**
     * Next_Packet_Number_to_be_sent_(TP.CM_CTS)
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t next_packet_number_to_be_sent;

    /**
     * Total_number_of_packets_for_BAM_message.Total_number_of_packets_received_for_RTS/CTS_message.Total_number_of_packets_for_RTS/CTS_message.
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t total_number_of_packets_eo_ma;

    /**
     * Total_number_of_packets_for_BAM_message.Total_number_of_packets_received_for_RTS/CTS_message.Total_number_of_packets_for_RTS/CTS_message.
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t total_number_of_packets_bam;

    /**
     * Total_number_of_packets_for_BAM_message.Total_number_of_packets_received_for_RTS/CTS_message.Total_number_of_packets_for_RTS/CTS_message.
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t total_number_of_packets;

    /**
     * Maximum_number_of_packets_for_RTS/CTS_message.
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t maximum_number_of_packets;

    /**
     * Range: 0..16777200 (0..16777200 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t pg_number;
};

/**
 * Signals in message RQST.
 *
 * Request
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_rqst_t {
    /**
     * PGN_which_is_requested_by_Request2_message
     *
     * Range: 0..16777215 (0..16777215 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t parameter_group_number;
};

/**
 * Signals in message WindData.
 *
 * Direction_and_speed_of_WindTrue_wind_can_be_referenced_to_vessel_to_groundApparent_Wind_is_what_is_felt_standing_on_themovingship,Ie,wind_measured_by_typical_mast_head_instruments_boat_referenced_true_wind_is_given_by_vector_sum_of_Apparent_wind_a
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_wind_data_t {
    /**
     * An_upward_counting_number_used_to_tie_related_information_together_between_different_PGNs.For_example,SID_would_be_used_to_tie_together_COG,SOG_and_RAIM_values_to_a_given_Pos.255=no_valid_Pos_fix_to_tie_it_to.Range_0_to_250_for_valid_Pos_fixes.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sequence_id_;

    /**
     * Range: 0..65532 (0..655.32 m/s)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t wind_speed;

    /**
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t wind_direction;

    /**
     * 0x00_=_True_(referenced_to_North)_0x01_=_Magnetic_0x02_=_Apparent_0x03_=_True_(boat_referenced)_0x04_=_Reserved_0x05_=_Reserved_0x06_=_Error_0x07_=_Null
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t wind_reference;
};

/**
 * Signals in message WaterDepth.
 *
 * Water_depth_relative_to_transducer_and_offset_of_measuring_transducerPositive_offset_numbers_provide_distance_from_transducer_to_waterlineNegative_offset_numbers_provide_distance_from_transducer_to_part_of_keel_of_interest
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_water_depth_t {
    /**
     * An_upward_counting_number_used_to_tie_related_information_together_between_different_PGNs.For_example,SID_would_be_used_to_tie_together_COG,SOG_and_RAIM_values_to_a_given_Pos.255=no_valid_Pos_fix_to_tie_it_to.Range_0_to_250_for_valid_Pos_fixes.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sid;

    /**
     * Depth_relative_to_the_transducer_location.__Range_of_value_specified_in_'Maximum_Range'_field.
     *
     * Range: 0..4295000000 (0..42950000 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint32_t water_depth_transducer;

    /**
     * Positive_values_represent_distance_from_transducer_to_water_line_and_negative_values_represent_distance_from_the_transducer_to_the_keel.
     *
     * Range: -32764..32764 (-32.764..32.764 m)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t offset;
};

/**
 * Signals in message VesselSpeedComponents.
 *
 * This_PGN_provides_a_single_Trans_that_accurately_describes_speed_of_a_vessel_by_component_vectors_This_information_is_relevant_for_large_vessels_and_would_typically_be_provided_by_a_product_that_interfaces_to_sensors_such_as_dual_axis_logsProducts_th
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_vessel_speed_components_t {
    /**
     * Positive_values_represent_ahead_or_starboard_transverse_speed_and_negative_values_represent_astern_or_port_transverse_speed.
     *
     * Range: -32764..32764 (-32.764..32.764 m/s)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t lngitudinal_speed_waterreferenced;

    /**
     * Positive_values_represent_ahead_or_starboard_transverse_speed_and_negative_values_represent_astern_or_port_transverse_speed.
     *
     * Range: -32764..32764 (-32.764..32.764 m/s)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t transverse_speed_waterreferenced;

    /**
     * Positive_values_represent_ahead_or_starboard_transverse_speed_and_negative_values_represent_astern_or_port_transverse_speed.
     *
     * Range: -32764..32764 (-32.764..32.764 m/s)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t lngtudinal_speed_groundreferenced;

    /**
     * Positive_values_represent_ahead_or_starboard_transverse_speed_and_negative_values_represent_astern_or_port_transverse_speed.
     *
     * Range: -32764..32764 (-32.764..32.764 m/s)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t transverse_speed_groundreferenced;

    /**
     * Positive_values_represent_ahead_or_starboard_transverse_speed_and_negative_values_represent_astern_or_port_transverse_speed.
     *
     * Range: -32764..32764 (-32.764..32.764 m/s)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t stern_speed_waterreferenced;

    /**
     * Positive_values_represent_ahead_or_starboard_transverse_speed_and_negative_values_represent_astern_or_port_transverse_speed.
     *
     * Range: -32764..32764 (-32.764..32.764 m/s)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t stern_speed_groundreferenced;
};

/**
 * Signals in message VesselHeading.
 *
 * Heading_sensor_value_with_a_flag_for_True_MagneticIf_sensor_value_is_Magnetic,deviation_field_can_be_used_to_produce_a_Magnetic_heading,and_variation_field_can_be_used_to_correct_Magnetic_heading_to_produce_a_True_heading_To_obtain_Magnetic_Heading_f
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_vessel_heading_t {
    /**
     * An_upward_counting_number_used_to_tie_related_information_together_between_different_PGNs.For_example,SID_would_be_used_to_tie_together_COG,SOG_and_RAIM_values_to_a_given_Pos.255=no_valid_Pos_fix_to_tie_it_to.Range_0_to_250_for_valid_Pos_fixes.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sid;

    /**
     * Primary_output_of_heading_as_indicated_by_the_heading_sensor.
     *
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t heading_sensor_reading;

    /**
     * Positive_values_are_Easterly_and_negative_values_are_Westerly.
     *
     * Range: -31416..31416 (-3.14159..3.14159 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t deviation;

    /**
     * Positive_values_are_Easterly_and_negative_values_are_Westerly.
     *
     * Range: -31416..31416 (-3.14159..3.14159 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t variation;

    /**
     * 0_=_True,__1_=_Magnetic,_2_=_Error,_3_=_Null
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t heading_sensor_reference;
};

/**
 * Signals in message UserDatumSettings.
 *
 * Transformation_parameters_for_converting_from_WGS-84_to_other_Datums
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_user_datum_settings_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message TripParametersVessel.
 *
 * Trip_parameters_relative_to_Vessel
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_trip_parameters_vessel_t {
    /**
     * Range: 0..4295000000 (0..4295000 sec)
     * Scale: 0.001
     * Offset: 0
     */
    uint32_t time_to_empty;

    /**
     * Range: 0..4295000000 (0..42950000 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint32_t distance_to_empty;

    /**
     * Range: 0..65532 (0..65.532 cu_m)
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t est_fuel_remaining;

    /**
     * Range: 0..4295000000 (0..4295000 sec)
     * Scale: 0.001
     * Offset: 0
     */
    uint32_t trip_run_time;
};

/**
 * Signals in message TripParametersEng.
 *
 * Engine_related_trip_information
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_trip_parameters_eng_t {
    /**
     * For_Engs:_0_=_Instance_
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_instance;

    /**
     * Range: 0..65532 (0..65.532 cu_m)
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t trip_fuel_used;

    /**
     * Range: -32764..32764 (-3.2764..3.2764 cu_m/hr)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t fuel_rate_average;

    /**
     * Range: -32764..32764 (-3.2764..3.2764 cu_m/hr)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t fuel_rate_economy;

    /**
     * Range: -32764..32764 (-3.2764..3.2764 cu_m/hr)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t instantaneous_fuel_economy;
};

/**
 * Signals in message TransParametersDynamic.
 *
 * Used_to_provide_operational_state_and_internal_operating_parameters_of_a_specific_Trans,indicated_by_Trans_instance_fieldThis_Msg_would_normally_be_broadcasted_periodically_to_provide_information_for_instrumentation_Ctrl_functions
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_trans_parameters_dynamic_t {
    /**
     * For_Engs:_0_=_Instance_
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t trans_instance;

    /**
     * 0_=_Forward._1_=_Neutral,_2_=_Reverse,_3_=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t trans_gear;

    /**
     * Range: 0..65532 (0..6553200 Pa)
     * Scale: 100
     * Offset: 0
     */
    uint16_t trans_oil_press_;

    /**
     * Range: 0..65532 (0..6553.2 K)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t trans_oil_temp_;

    /**
     * xxxx_xxx1_=_Check_Tranmission,_xxxx_xx1x_=_Over_Temp,_xxxx_x1xx_=_Low_Oil_Press,_xxxx_1xxx_=_Low_Oil_Level,_xxx1_xxxx_=_Sail_Drive,_xx1x_xxxx_=_reserved,_x1xx_xxxx_=_reserved,_1xxx_xxxx_=_reserved,_where_x_=_don't_care
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t trans_discrete_status;
};

/**
 * Signals in message TrackedTargetData.
 *
 * Message_for_reporting_status_and_target_data_from_tracking_radar_external_devices__The_reporting_interval_will_vary_by_the_values_for_target_status_and_quantity_of_track_data_files
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_tracked_target_data_t {
    /**
     * An_upward_counting_number_used_to_tie_related_information_together_between_different_PGNs.For_example,SID_would_be_used_to_tie_together_COG,SOG_and_RAIM_values_to_a_given_Pos.255=no_valid_Pos_fix_to_tie_it_to.Range_0_to_250_for_valid_Pos_fixes.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sequence_id_;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t target_id;

    /**
     * xx00_=_Cancelled_Not_Available,_xx01_=_Initial_Acquisition_Target,_xx10_=_Tracking_Target,_xx11_=_Lost_Target,_x0xx_=_Reported_Target_No,_x1xx_=_Reported_Target_Yes,_0xxx_=_Acquision_Manual,_1xxx_=_Acquision_Auto,_where_x_=_don
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t track_status;

    /**
     * 0_=_True,__1_=_Magnetic,_2_=_Error,_3_=_Releative
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bearing_reference;

    /**
     * Degrees_clockwise_relative_to_True_North.
     *
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t bearing;

    /**
     * Range: -2147000000..2147000000 (-21470000..21470000 m)
     * Scale: 0.01
     * Offset: 0
     */
    int32_t distance;

    /**
     * Degrees_clockwise_relative_to_True_North.
     *
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t course;

    /**
     * Range: 0..65532 (0..655.32 m/s)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t speed;

    /**
     * Range: -2147000000..2147000000 (-21470000..21470000 m)
     * Scale: 0.01
     * Offset: 0
     */
    int32_t cpa;

    /**
     * Time_interval_in_milli-sec.__'-'__=_time_elapsed_since_event,_'+'_=_time_to_go_before_event.
     *
     * Range: -2148000000..2148000000 (-2148000..2148000 sec)
     * Scale: 0.001
     * Offset: 0
     */
    int32_t tcpa;

    /**
     * 24_hour_clock,_0_=__midnight,__time_is_in_UTC
     *
     * Range: 0..864010000 (0..86401 sec)
     * Scale: 0.0001
     * Offset: 0
     */
    uint32_t utc_of_fix;

    /**
     * Name_of_place,_route,_waypoint,_destination,_vessel,_vehicle,_etc.
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t name;
};

/**
 * Signals in message RouteAndWPServiceWPListWPNamePos.
 *
 * Complex_Rq_of_this_PGN_should_return_Waypoints_of_a_WP-List_WARNING:Route_Track_may_not_be_defined_by_Waypoint_Poss_only:Navigation_MethodGC/RLand_Radius_of_Turn_at_each_Waypoint_are_optional_additional_parameters_defining_Track_PGN_130066_field_
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_route_and_wp_service_wp_list_wp_name_pos_t {
    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t start_wpid;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_items;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t number_of_valid_w_ps_in_wp_list;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t database_id;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t reserved;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t wpid;

    /**
     * Name_of_place,_route,_waypoint,_destination,_vessel,_vehicle,_etc.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint16_t wp_name;
};

/**
 * Signals in message RouteAndWPServiceDatabaseComment.
 *
 * Complex_Rq_of_this_PGN_should_return_supplementary_Comments_attached_to_Databases_in_navigation_Device_Databases_without_a_Comment_shall_not_be_included_in_this_PGN_reply_should_use_same_transfer_Protcl_as_Rq_ISO_Rq_for_this_PGN_shall_return_059
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_route_and_wp_service_database_comment_t {
    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t start_database_id;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_items;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t number_of_databases_with_comments;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t database_id;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t comment_text;
};

/**
 * Signals in message Rudder.
 *
 * Rudderder_Cmd_in_direction_angle_with_current_rudder_angle_readingDirectionder_field_is_for_non-follow-up_rudderders_and_Angleder_field_is_for_follow-up_rudderdersWhen_used_as_a_Cmd,Directionder_field_and_Angleder_field_shall_never_containder_values_at_
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_rudder_t {
    /**
     * For_Engs:_0_=_Instance_
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rudder_instance;

    /**
     * MSB/LSB:__000_=_No_Order,_001_=_Move_to_starboard,_010_=_Move_to_port.
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t directionder;

    /**
     * Rudder_angle_where_positive_values_are_starboard_and_negative_values_are_port
     *
     * Range: -31416..31416 (-3.14159..3.14159 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t angleder;

    /**
     * Rudder_angle_where_positive_values_are_starboard_and_negative_values_are_port
     *
     * Range: -31416..31416 (-3.14159..3.14159 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t pos;
};

/**
 * Signals in message RtAndWPSrvcXTELmtNvgationMethod.
 *
 * Complex_Rq_of_this_PGN_will_return_XTE_Limit_and/or_Navigation_Method_specific_to_individual_legs_of_a_Route_Database_ID_and_Route_ID_shall_be_specified_in_Rq/reply_parameters_apply_to_one_leg_after_Waypoint_identified_with_RPS_in_Forward_Directi
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_t {
    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t start_rps;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_items;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t nmbr_of_wypnts_wth_a_spcfc_xte_lmt_nv_mth;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t database_id;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t route_id;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t rps;

    /**
     * A_commanded_distance_like_radius_order,_off-track_limit,_etc.
     *
     * Range: -32764..32764 (-32764..32764 m)
     * Scale: 1
     * Offset: 0
     */
    int16_t xte_limit_in_leg_after_wp;

    /**
     * 0_=_Great_Circle_calculations,__1_=_Rhumb_Line_calculations,_2_=_Error,_3_=_Null
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nav_method_in_leg_after_wp;
};

/**
 * Signals in message RtAndWPSrvcRte_WPListAttributes.
 *
 * Complex_Rq_for_this_PGN_should_return_attributes_of_a_Route_WP-List_WARNING:Route_Track_may_not_be_defined_by_Waypoint_Poss_only:Navigation_MethodGC/RLand_Radius_of_Turn_at_each_Waypoint_are_optional_additional_parameters_defining_Track_PGN_130066
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_rt_and_wp_srvc_rte_wp_list_attributes_t {
    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t database_id;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t route_id;

    /**
     * Name_of_place,_route,_waypoint,_destination,_vessel,_vehicle,_etc.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint16_t route_wp_list_name;
};

/**
 * Signals in message RouteAndWPServiceWPComment.
 *
 * Complex_Rq_of_this_PGN_should_return_supplementary_Comments_attached_to_Waypoints_in_a_Route_a_WP-List_Waypoints_without_a_Commment_shall_not_be_included_in_this_PGN_If_Route_ID_is_set_to_65535NA,Comments_will_be_for_Waypoints_in_WP-List_Datab
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_route_and_wp_service_wp_comment_t {
    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t start_id;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_items;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t number_of_w_ps_with_comments;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t database_id;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t route_id;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t wpid_rps;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t comment;
};

/**
 * Signals in message GNSSRAIMOutput.
 *
 * This_PGN_is_used_to_provide_the_output_from_a_GNSS_Receivers_Receiver_Autonomous_Integrity_Monitoring_RAIM_process__The_Integrity_field_value_is_based_upon_the_parameters_set_in_PGN_130059_GNS_RAIM_Settings
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_gnssraim_output_t {
    /**
     * An_upward_counting_number_used_to_tie_related_information_together_between_different_PGNs.For_example,SID_would_be_used_to_tie_together_COG,SOG_and_RAIM_values_to_a_given_Pos.255=no_valid_Pos_fix_to_tie_it_to.Range_0_to_250_for_valid_Pos_fixes.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sequence_id_;

    /**
     * 0_=_No_Integrity_checking,*_1_=_Safe,_2_=_Caution,_3_=_Unsafe_*_means_the_receiver_does_not_have_this_capability
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t integrity_flag;

    /**
     * Range: -32764..32764 (-327.64..327.64 m)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t latitude_expected_error;

    /**
     * Range: -32764..32764 (-327.64..327.64 m)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t longitude_expected_error;

    /**
     * Range: -32764..32764 (-327.64..327.64 m)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t altitude_expected_error;

    /**
     * 0_=_value_not_used,_1-32_=_GPS,_33-64_=_SBAS,Satellite,Based_Augmentation_System(ie_WAAS)_65-96_=_GLONASS._For_GLONASS,satellites_are_identified_by_64+satellite_slot_number.slot_numbers_are_1_through_24_for_full_GLONASS_constellation_of_24_satellite
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t svid_of_most_likely_failed_sat;

    /**
     * Range: -124..124 (-124..124 %)
     * Scale: 1
     * Offset: 0
     */
    int8_t probability_of_missed_detection;

    /**
     * Range: -32764..32764 (-327.64..327.64 m)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t estimate_of_pseudorange_bias;

    /**
     * Range: -32764..32764 (-327.64..327.64 m)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t std_deviation_of_bias;
};

/**
 * Signals in message GNSSPseudorangeNoiseStatistics.
 *
 * GNSS_pseudorange_measurement_noise_statistics_can_be_translated_in_the_position_domain_in_order_to_give_statistical_measures_of_the_quality_of_the_position_solution_Intended_for_use_with_a_Receiver_Autonomous_Integrity_Monitoring_RAIM_application
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_gnss_pseudorange_noise_statistics_t {
    /**
     * An_upward_counting_number_used_to_tie_related_information_together_between_different_PGNs.For_example,SID_would_be_used_to_tie_together_COG,SOG_and_RAIM_values_to_a_given_Pos.255=no_valid_Pos_fix_to_tie_it_to.Range_0_to_250_for_valid_Pos_fixes.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sid;

    /**
     * Error_distances_expressed_in_meters.
     *
     * Range: 0..65532 (0..655.32 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t rms_of_pos_uncertainty;

    /**
     * Error_distances_expressed_in_meters.
     *
     * Range: 0..65532 (0..655.32 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t std_of_major_axis;

    /**
     * Error_distances_expressed_in_meters.
     *
     * Range: 0..65532 (0..655.32 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t std_of_minor_axis;

    /**
     * Degrees_clockwise_relative_to_True_North.
     *
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t orientation_of_major_axis;

    /**
     * Error_distances_expressed_in_meters.
     *
     * Range: 0..65532 (0..655.32 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t std_of_lat_error;

    /**
     * Error_distances_expressed_in_meters.
     *
     * Range: 0..65532 (0..655.32 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t std_of_lon_error;

    /**
     * Error_distances_expressed_in_meters.
     *
     * Range: 0..65532 (0..655.32 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t std_of_alt_error;
};

/**
 * Signals in message GNSSPseudorangeErrorStatistics.
 *
 * This_parameter_group_is_used_to_support_Receiver_Autononmous_Integrity_Monitoring_RAIM__Pseudorange_measurement_error_statistics_can_be_translated_in_the_position_domain_in_order_to_give_statistical_measures_of_the_quality_of_the_position_solution
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_gnss_pseudorange_error_statistics_t {
    /**
     * An_upward_counting_number_used_to_tie_related_information_together_between_different_PGNs.For_example,SID_would_be_used_to_tie_together_COG,SOG_and_RAIM_values_to_a_given_Pos.255=no_valid_Pos_fix_to_tie_it_to.Range_0_to_250_for_valid_Pos_fixes.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sequence_id_;

    /**
     * Range: 0..65532 (0..655.32 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t rms_std_dev_of_range_inputs;

    /**
     * Range: 0..65532 (0..655.32 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t std_dev_major_error_ellipse;

    /**
     * Range: 0..65532 (0..655.32 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t std_dev_minor_error_ellipse;

    /**
     * Degrees_clockwise_relative_to_True_North.
     *
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t orientation_of_error_ellipse;

    /**
     * Range: 0..65532 (0..655.32 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t std_dev_latitude_error;

    /**
     * Range: 0..65532 (0..655.32 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t std_dev_longitude_error;

    /**
     * Range: 0..65532 (0..655.32 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t std_dev_altitude_error;
};

/**
 * Signals in message GNSSPosData.
 *
 * This_PGN_conveys_a_comprehensive_set_of_Global_Navigation_Satellite_System_GNSS_parameters,_including_position_information__Equipment_transmitting_this_PGN_would_typically_also_transmit_PGN_129025_Position__Rapid_Update
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_gnss_pos_data_t {
    /**
     * An_upward_counting_number_used_to_tie_related_information_together_between_different_PGNs.For_example,SID_would_be_used_to_tie_together_COG,SOG_and_RAIM_values_to_a_given_Pos.255=no_valid_Pos_fix_to_tie_it_to.Range_0_to_250_for_valid_Pos_fixes.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sid;

    /**
     * Days_since_January_1,_1970,___Date_is_relative_to_UTC_Time.
     *
     * Range: 0..65532 (0..65532 day)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_date;

    /**
     * 24_hour_clock,_0_=__midnight,__time_is_in_UTC
     *
     * Range: 0..864010000 (0..86401 sec)
     * Scale: 0.0001
     * Offset: 0
     */
    uint32_t pos_time;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t latitude_low;

    /**
     * Range: -90..90 (-90..90 deg)
     * Scale: 1
     * Offset: 0
     */
    int32_t latitude_high;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t longitude_low;

    /**
     * Range: -180..180 (-180..180 deg)
     * Scale: 1
     * Offset: 0
     */
    int32_t longitude_high;

    /**
     * Range: 0..4294967295 (0..4294.9673 m)
     * Scale: 1e-06
     * Offset: 0
     */
    uint32_t altitude_low;

    /**
     * Range: -2147397026..2147397026 (-9223000000000..9223000000000 m)
     * Scale: 4294.967296
     * Offset: 0
     */
    int32_t altitude_high;

    /**
     * 0x00_=_GPS_0x01_=_GLONASS_0x02_=_GPS+GLONASS_0x03_=_GPS+SBAS(WAAS)_0x04_=_GPS+SBAS+GLONASS_0x05_-_0x15_=_Reserved_for_future_combinations
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t type_of_system_;

    /**
     * 0_=_no_GPS,_1_=_GNSS_fix,_2_=_DGNSS_fix,_3_=_Precise_GNSS*,_4_=_RTK_Fixed_Integer,_5_=_RTK_Float,_6_=_Est(DR)mode,_7_=_Manual_Input,_8_=_Simulate_mode,_9-13_=_Reserved,_14_=_Error,_15_=_Null.*Precise_GNSS_means_no_deliberate_degradation(such_as
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t method_gnss;

    /**
     * 0_=_No_Integrity_checking,*_1_=_Safe,_2_=_Caution,_3_=_Unsafe_*_means_the_receiver_does_not_have_this_capability
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t integrity;

    /**
     * Numeric_count,_event_counter,_sequence_counter
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t number_of_s_vs_;

    /**
     * Dilution_of_Precision(DOP)indicates_contribution_of_satellite_Config_geometry_to_Posing_error.A_lower_DOP_value_is_preferred_because_less_error_is_being_introduced.Reported_as_components:HDOP(Horizontal),VDOP(Vertical),TDOP(Time).Min_DOP_value_is_1.0(no_e
     *
     * Range: -32764..32764 (-327.64..327.64 -)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t hdop_;

    /**
     * Dilution_of_Precision(DOP)indicates_contribution_of_satellite_Config_geometry_to_Posing_error.A_lower_DOP_value_is_preferred_because_less_error_is_being_introduced.Reported_as_components:HDOP(Horizontal),VDOP(Vertical),TDOP(Time).Min_DOP_value_is_1.0(no_e
     *
     * Range: -32764..32764 (-327.64..327.64 -)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t pdop_;

    /**
     * The_difference_between_the_earth_ellipsoid_and_mean-sea-level_(geoid)_defined_by_the_reference_datum_used_in_the_position_solution,_'-'_=_mean-sea-level_below_ellipsoid.__Reference_datum_is_defined_in_this_packet.
     *
     * Range: -2147000000..2147000000 (-21470000..21470000 m)
     * Scale: 0.01
     * Offset: 0
     */
    int32_t geoidal_separation_;

    /**
     * Numeric_count,_event_counter,_sequence_counter
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t number_of_reference_stations_;

    /**
     * Reference_Station_Type.__0x0=GP
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t reference_station_type1;

    /**
     * Reference_Station_ID.__Reference_Station_number_as_provided_by_the_Service_Provider.[Reference_document_required]
     *
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t reference_station_id1_;

    /**
     * Age_of_Differential_corrections
     *
     * Range: 0..65532 (0..655.32 sec)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t age_of_dgnss_corrections1_;

    /**
     * Reference_Station_Type.__0x0=GP
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t reference_station_type_n;

    /**
     * Reference_Station_ID.__Reference_Station_number_as_provided_by_the_Service_Provider.[Reference_document_required]
     *
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t reference_station_idn;

    /**
     * Age_of_Differential_corrections
     *
     * Range: 0..65532 (0..655.32 sec)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t age_of_dgnss_reference_station_n;
};

/**
 * Signals in message GNSSDffCrrctonReceiverInterface.
 *
 * GNSS_common_differential_correction_receiver_parameter_status
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_gnss_dff_crrcton_receiver_interface_t {
    /**
     * The_channel_number_of_the_correction_receiver.__If_the_receiver_only_has_one_beacon_input_channel,_this_value_shall_be_1_0_is_undefined.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t channel;

    /**
     * This_is_the_input_frequency_of_the_correction_receiver.
     *
     * Range: 0..32704 (0..327040 Hz)
     * Scale: 10
     * Offset: 0
     */
    uint32_t frequency;

    /**
     * This_is_bit_rate_of_correction_receiver._0_=_25bps,_1_=_50bps,_2_=_100bps,_3_=_200bps,_4_=_300bps,_5_=_500bps,_6_=_1200bps,_7_=_2400bps,_8_=_4800bps,_9_=_9600bps_10_=_19200bps,_11_=_38400bps,_12_=_57600bps,_13-29_=_Reserved,_30_=_
     *
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t serial_interface_bit_rate;

    /**
     * This_is_the_mode_of_operation_for_the_correction_receiver.___0_=_Auto_bit_rate_set,_1_=_Manual_bit_rate_set,_2-5_=_Reserved_6_=_Error,_7_=_Null.
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t serial_interface_detection_mode;

    /**
     * 0__=_Auto_Select,_1_=_Loran_Communications_2_=_MSK_Beacon,_3_=_FM_Subcarrier,_4_=_AIS(Automatic_Identification_System),_5_=_Other_Ground-based_Radio,_6_=_SBAS(Satellite_Based_Augmentation_System,_7_=_Other_Satellite,_8-13_=_Re
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t diff_source;

    /**
     * 0__=_Manual,__1_=_Auto_Power,_2_=_Auto_Range,_3-13_=_Reserved,_14_=_Error,_15_=_No_Selection
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t diff_operation_mode;
};

/**
 * Signals in message GNSSDffCorrectionReceiverSignal.
 *
 * GNSS_differential_correction_receiver_status_tagged_by_sequence_ID_Status_information_includes_frequency,_SNR,_and_use_as_a_correction_source
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_gnss_dff_correction_receiver_signal_t {
    /**
     * An_upward_counting_number_used_to_tie_related_information_together_between_different_PGNs.For_example,SID_would_be_used_to_tie_together_COG,SOG_and_RAIM_values_to_a_given_Pos.255=no_valid_Pos_fix_to_tie_it_to.Range_0_to_250_for_valid_Pos_fixes.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sid;

    /**
     * The_channel_number_of_the_correction_receiver.__If_the_receiver_only_has_one_beacon_input_channel,_this_value_shall_be_1_0_is_undefined.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t channel;

    /**
     * This_is_the_signal_strength_expressed_in_dB_with_respect_to_1uV/m.
     *
     * Range: -32764..32764 (-327.64..327.64 dB_re_uV/m)
     * Scale: 0.01
     * Offset: 0
     */
    int32_t signal_strength;

    /**
     * Range: -32764..32764 (-327.64..327.64 dB)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t signal_snr;

    /**
     * This_is_the_input_frequency_of_the_correction_receiver.
     *
     * Range: 0..32704 (0..327040 Hz)
     * Scale: 10
     * Offset: 0
     */
    uint32_t frequency;

    /**
     * Reference_Station_Type.__0x0=GP
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t station_type;

    /**
     * Reference_Station_ID.__Reference_Station_number_as_provided_by_the_Service_Provider.[Reference_document_required]
     *
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t station_id;

    /**
     * This_is_bit_rate_of_correction_receiver._0_=_25bps,_1_=_50bps,_2_=_100bps,_3_=_200bps,_4_=_300bps,_5_=_500bps,_6_=_1200bps,_7_=_2400bps,_8_=_4800bps,_9_=_9600bps_10_=_19200bps,_11_=_38400bps,_12_=_57600bps,_13-29_=_Reserved,_30_=_
     *
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t diff_signal_bit_rate;

    /**
     * This_is_the_mode_of_operation_for_the_correction_receiver.___0_=_Auto_bit_rate_set,_1_=_Manual_bit_rate_set,_2-5_=_Reserved_6_=_Error,_7_=_Null.
     *
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t diff_signal_detection_mode;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t used_as_correction_source;

    /**
     * 0__=_Auto_Select,_1_=_Loran_Communications_2_=_MSK_Beacon,_3_=_FM_Subcarrier,_4_=_AIS(Automatic_Identification_System),_5_=_Other_Ground-based_Radio,_6_=_SBAS(Satellite_Based_Augmentation_System,_7_=_Other_Satellite,_8-13_=_Re
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t diff_source;

    /**
     * Age_of_Differential_corrections
     *
     * Range: 0..65532 (0..655.32 sec)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t time_since_last_sat_diff_sync;

    /**
     * Satellite_Service_ID_number_as_provided_by_the_Service_Provider.[Reference_document_required]
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t satellite_service_id_no;
};

/**
 * Signals in message GNSSDOPs.
 *
 * This_PGN_provides_a_single_Trans_containing_GNSS_status_and_dilution_of_precision_componentsDOPthat_indicate_contribution_of_satellite_geometry_to_overall_Posing_errorThere_are_three_DOP_parameters_reported,horizontalHDOP,VerticalVDOPand_timeTDOP
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_gnssdo_ps_t {
    /**
     * An_upward_counting_number_used_to_tie_related_information_together_between_different_PGNs.For_example,SID_would_be_used_to_tie_together_COG,SOG_and_RAIM_values_to_a_given_Pos.255=no_valid_Pos_fix_to_tie_it_to.Range_0_to_250_for_valid_Pos_fixes.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sid;

    /**
     * 0_=_1D,__1_=_2D,_2_=_3D,_3_=_Auto,_4-5_=_Reserved,_6_=_Error,_7_=_Null
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t set_mode;

    /**
     * 0_=_1D,__1_=_2D,_2_=_3D,_3_=_Auto,_4-5_=_Reserved,_6_=_Error,_7_=_Null
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t op_mode;

    /**
     * Dilution_of_Precision(DOP)indicates_contribution_of_satellite_Config_geometry_to_Posing_error.A_lower_DOP_value_is_preferred_because_less_error_is_being_introduced.Reported_as_components:HDOP(Horizontal),VDOP(Vertical),TDOP(Time).Min_DOP_value_is_1.0(no_e
     *
     * Range: -32764..32764 (-327.64..327.64 -)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t hdop_;

    /**
     * Dilution_of_Precision(DOP)indicates_contribution_of_satellite_Config_geometry_to_Posing_error.A_lower_DOP_value_is_preferred_because_less_error_is_being_introduced.Reported_as_components:HDOP(Horizontal),VDOP(Vertical),TDOP(Time).Min_DOP_value_is_1.0(no_e
     *
     * Range: -32764..32764 (-327.64..327.64 -)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t vdop;

    /**
     * Dilution_of_Precision(DOP)indicates_contribution_of_satellite_Config_geometry_to_Posing_error.A_lower_DOP_value_is_preferred_because_less_error_is_being_introduced.Reported_as_components:HDOP(Horizontal),VDOP(Vertical),TDOP(Time).Min_DOP_value_is_1.0(no_e
     *
     * Range: -32764..32764 (-327.64..327.64 -)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t tdop;
};

/**
 * Signals in message GNSSCtrlStatus.
 *
 * GNSS_common_satellite_receiver_parameter_status
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_gnss_ctrl_status_t {
    /**
     * Angle_above_or_below_the_horizon._-90_to_+90_negative_below_the_horizon
     *
     * Range: -31416..31416 (-3.14159..3.14159 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t sv_elevation_mask;

    /**
     * Dilution_of_Precision(DOP)indicates_contribution_of_satellite_Config_geometry_to_Posing_error.A_lower_DOP_value_is_preferred_because_less_error_is_being_introduced.Reported_as_components:HDOP(Horizontal),VDOP(Vertical),TDOP(Time).Min_DOP_value_is_1.0(no_e
     *
     * Range: -32764..32764 (-327.64..327.64 -)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t pdop_mask;

    /**
     * Dilution_of_Precision(DOP)indicates_contribution_of_satellite_Config_geometry_to_Posing_error.A_lower_DOP_value_is_preferred_because_less_error_is_being_introduced.Reported_as_components:HDOP(Horizontal),VDOP(Vertical),TDOP(Time).Min_DOP_value_is_1.0(no_e
     *
     * Range: -32764..32764 (-327.64..327.64 -)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t pdop_switch;

    /**
     * Range: -32764..32764 (-327.64..327.64 dB)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t snr_mask;

    /**
     * 0_=_1D,__1_=_2D,_2_=_3D,_3_=_Auto,_4-5_=_Reserved,_6_=_Error,_7_=_Null
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t gnss_mode;

    /**
     * 0_=_Off,_1_=_Auto,_2_=_RTCM_SC104_Pseudorange_Corrections,_3_=_RTCA_SC159_Network_Corrections,_4_=_RTK_Differential_Corrections,_5_=_Reserved,_6_=_Erro
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dgnss_mode;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pos_velocity_filter;

    /**
     * Age_of_Differential_corrections
     *
     * Range: 0..65532 (0..655.32 sec)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t max_correction_age;

    /**
     * Range: -2147000000..2147000000 (-21470000..21470000 m)
     * Scale: 0.01
     * Offset: 0
     */
    int32_t antenna_altitude_for2_d_mode;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t use_antenna_altitude_for2_d_mode;
};

/**
 * Signals in message GLONASSAlmanacData.
 *
 * This_PGN_provides_a_single_Trans_that_contains_relevant_almanac_data_for_Glonass_productsalmanac_contains_satellite_vehicle_coursebital_parametersThis_information_is_not_considered_precise_and_is_only_valid_for_several_months_at_a_timeGlonass_products_
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_glonass_almanac_data_t {
    /**
     * 0_=_value_not_used,_1-32_=_GPS,_33-64_=_SBAS,Satellite,Based_Augmentation_System(ie_WAAS)_65-96_=_GLONASS._For_GLONASS,satellites_are_identified_by_64+satellite_slot_number.slot_numbers_are_1_through_24_for_full_GLONASS_constellation_of_24_satellite
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t prn;

    /**
     * Calendar_day_count_within_the_four_year_period_beginning_with_the_previous_leap_year
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t na;

    /**
     * Generalized_health_of_the_Satellite,_reference_GLONASS_ICD.
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cn_a;

    /**
     * Carrier_frequency_number_respectively,_reference_GLONASS_ICD.
     *
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t hn_a;

    /**
     * Calendar_day_count_within_the_four_year_period_beginning_with_the_previous_leap_year
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_a;

    /**
     * Rate_of_change_of_the_draconitic_circling_time,_reference_GLONASS_ICD_Section_4.5_Table_4.3_(fill_unused_bits_with_zeros).
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dot;

    /**
     * Argument_of_Perigee,_reference_GLONASS_ICD_Section_4.5_Table_4.3_(fill_unused_bits_with_zeros).
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_a2;

    /**
     * Correction_to_the_average_value_of_the_draconitic_circling_time,_reference_GLONASS_ICD_Section_4.5_Table_4.3_(fill_unused_bits_with_zeros).
     *
     * Range: 0..16777215 (0..16777215 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t tn_a;

    /**
     * Correction_to_the_average_value_of_the_draconitic_circling_time,_reference_GLONASS_ICD_Section_4.5_Table_4.3_(fill_unused_bits_with_zeros).
     *
     * Range: 0..16777215 (0..16777215 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t tn_a;

    /**
     * Greenwich_longitude_of_the_ascension_node,_reference_GLONASS_ICD_Section_4.5_Table_4.3_(fill_unused_bits_with_zeros).
     *
     * Range: 0..16777215 (0..16777215 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t n_a3;

    /**
     * Correction_to_the_average_value_of_the_inclination_angle,_reference_GLONASS_ICD_Section_4.5_Table_4.3_(fill_unused_bits_with_zeros).
     *
     * Range: 0..16777215 (0..16777215 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t in_a;

    /**
     * System_time_scale_correction,_reference_GLONASS_ICD_Section_4.5_Table_4.3_(fill_unused_bits_with_zeros).
     *
     * Range: 0..268435455 (0..268435455 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t tc_a;

    /**
     * Course_value_of_the_time_scale_shift,_reference_GLONASS_ICD_Section_4.5_Table_4.3_(fill_unused_bits_with_zeros).
     *
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t tn_a2;
};

/**
 * Signals in message FluidLevel.
 *
 * Fluid_Level_contains_an_instance_number,_type_of_fluid,_level_of_fluid,_and_tank_capacity__For_example_the_fluid_instance_may_be_the_level_of_fuel_in_a_tank_or_the_level_of_water_in_the_bilge__Used_primarily_by_display_or_instrumentation_devices
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_fluid_level_t {
    /**
     * 0x0_to_0xF_=_Instance_number_0_to_15
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fluid_instance;

    /**
     * 0x00_=_Fuel,_0x01_=_Fresh_Water,_0x02_=_Waste_Water,_0x03_=_Live_Well,_0x04_=_Oil,_0x05_=_Black_Water_(Sewage)_0x06_=_Reserved,_thru_0x0D_=_Reserved,_0x0E_=_Error,_0x0F_=_Data_not_available
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fluid_type;

    /**
     * Range: -124..124 (-124..124 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t fluid_level;

    /**
     * Range: 0..4296000000 (0..429600 cu_m)
     * Scale: 0.0001
     * Offset: 0
     */
    uint32_t tank_capacity;
};

/**
 * Signals in message EnvironmentalParameters.
 *
 * Local_atmospheric_environmental_conditions
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_environmental_parameters_t {
    /**
     * An_upward_counting_number_used_to_tie_related_information_together_between_different_PGNs.For_example,SID_would_be_used_to_tie_together_COG,SOG_and_RAIM_values_to_a_given_Pos.255=no_valid_Pos_fix_to_tie_it_to.Range_0_to_250_for_valid_Pos_fixes.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sequence_id_;

    /**
     * Range: 0..65532 (0..655.32 K)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t water_temp;

    /**
     * Range: 0..65532 (0..655.32 K)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t outside_ambient_air_temp;

    /**
     * Range: 0..65532 (0..6553200 Pa)
     * Scale: 100
     * Offset: 0
     */
    uint16_t atmospheric_press;
};

/**
 * Signals in message EngParametersStatic.
 *
 * Provides_identification_information_and_rated_engine_speed_for_the_engine_indicated_by_the_engine_instance_field_Used_primarily_by_display_devices
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_eng_parameters_static_t {
    /**
     * For_Engs:_0_=_Instance_
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_instance;

    /**
     * Range: 0..16383 (0..16383 rpm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t rated_eng_speed;

    /**
     * Name_of_place,_route,_waypoint,_destination,_vessel,_vehicle,_etc.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint16_t vin;

    /**
     * Name_of_place,_route,_waypoint,_destination,_vessel,_vehicle,_etc.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint16_t software_id;
};

/**
 * Signals in message EngParametersRapidUpdate.
 *
 * Provides_data_with_a_high_update_rate_for_a_specific_engine_in_a_single_frame_message__The_first_field_provides_information_as_to_which_engine__This_PGN_if__used_with_PGN_127489_will_provide_most_Engine_data
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_eng_parameters_rapid_update_t {
    /**
     * For_Engs:_0_=_Instance_
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_instance;

    /**
     * Range: 0..16383 (0..16383 rpm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t eng_speed_;

    /**
     * Range: 0..65532 (0..6553200 Pa)
     * Scale: 100
     * Offset: 0
     */
    uint16_t eng_boost_press;

    /**
     * Range: -124..124 (-124..124 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t eng_tilt_trim;
};

/**
 * Signals in message EngParametersDynamic.
 *
 * Used_to_provide_real-time_operational_data_and_status_relevant_to_a_specific_engine,__indicated_by_the_engine_instance_field__This_message_would_normally_be_broadcasted_periodically_to_provide_information_for_instrumentation_or_control_functions
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_eng_parameters_dynamic_t {
    /**
     * For_Engs:_0_=_Instance_
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_instance;

    /**
     * Range: 0..65532 (0..6553200 Pa)
     * Scale: 100
     * Offset: 0
     */
    uint16_t eng_oil_press_;

    /**
     * Range: 0..65532 (0..6553.2 K)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t eng_oil_temp;

    /**
     * Range: 0..65532 (0..655.32 K)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t eng_temp;

    /**
     * Range: -32764..32764 (-327.64..327.64 V)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t alt_potential;

    /**
     * Range: -32764..32764 (-3.2764..3.2764 cu_m/hr)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t fuel_rate;

    /**
     * Range: 0..32704 (0..32704 sec)
     * Scale: 1
     * Offset: 0
     */
    uint32_t total_eng_hours;

    /**
     * Range: 0..65532 (0..6553200 Pa)
     * Scale: 100
     * Offset: 0
     */
    uint16_t eng_coolant_press_;

    /**
     * Range: 0..65532 (0..65532000 Pa)
     * Scale: 1000
     * Offset: 0
     */
    uint16_t fuel_press;

    /**
     * xxxx_xxxx__xxxx_xxx1_=_Check_Eng,_xxxx_xxxx_xxxx_xx1x_=_Over_Temp,_xxxx_xxxx_xxxx_x1xx_=_Low_Oil_Press,_xxxx_xxxx_xxxx_1xxx_=_Low_Oil_Level,_xxxx_xxxx_xxx1_xxxx_=_Low_Fuel_Press,_xxxx_xxxx_xx1x_xxxx_=_Low_System_Voltage,_xxxx_xxxx_x1xx_xxxx_=_
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t eng_discrete_status1;

    /**
     * xxxx_xxxx_xxxx_xxx1_=_Warning_Level_1,_xxxx_xxxx_xxxx_xx1x_=_Warning_Level_2,_xxxx_xxxx_xxxx_x1xx_=_Power_Reduction,_xxxx_xxxx_xxxx_1xxx_=_Maintenance_Needed,_xxxx_xxxx_xxx1_xxxx_=_Eng_Comm_Error,_xxxx_xxxx_xx1x_xxxx_=_Sub_Second_Throttle,_xxxx_xxxx
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t eng_discrete_status2;

    /**
     * Range: -124..124 (-124..124 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t percent_eng_load;

    /**
     * Range: -124..124 (-124..124 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t percent_eng_torque;
};

/**
 * Signals in message DistanceLog.
 *
 * This_PGN_provides_cumulative_voyage_distance_traveled_since_last_resetdistance_is_tagged_with_time_and_date_of_distance_measurementdistances_through_water_are_accumulated_and_values_stored_during_power_down_and_resume_counting_after_power_up_-Tota
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_distance_log_t {
    /**
     * Days_since_January_1,_1970,___Date_is_relative_to_UTC_Time.
     *
     * Range: 0..65532 (0..65532 day)
     * Scale: 1
     * Offset: 0
     */
    uint16_t measurement_date;

    /**
     * 24_hour_clock,_0_=__midnight,__time_is_in_UTC
     *
     * Range: 0..864010000 (0..86401 sec)
     * Scale: 0.0001
     * Offset: 0
     */
    uint32_t measurement_time;

    /**
     * Range: 0..32704 (0..32704 m)
     * Scale: 1
     * Offset: 0
     */
    uint32_t total_cumulative_distance;

    /**
     * Range: 0..32704 (0..32704 m)
     * Scale: 1
     * Offset: 0
     */
    uint32_t distance_since_last_reset;
};

/**
 * Signals in message AISClassAPosReport.
 *
 * This_parameter_group_provides_data_associated_with_ITU-R_M1371_Msgs_1,2,and_3_Pos_Reports,autonomous,assigned,and_Resp_to_interrogation,respectivelyAn_AIS_device_may_generate_this_parameter_group_either_upon_receiving_a_VHF_data_link_Msg_1,2_3,or_upon_r
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_ais_class_a_pos_report_t {
    /**
     * Message_Identifier_(range_of_0_to_63)._See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t msg_id;

    /**
     * Used_by_the_repeater_to_indicate_how_many_times_a_message_has_been_repeated_(range_of_0_to_3)._0_=_Default_1_=_First_retransmission_2_=_Second_retransmission_3_=_Final_retransmission_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t repeat_indicator;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t user_id;

    /**
     * Range: -180..180 (-180..180 deg)
     * Scale: 1
     * Offset: 0
     */
    int32_t longitude_;

    /**
     * Range: -90..90 (-90..90 deg)
     * Scale: 1
     * Offset: 0
     */
    int32_t latitude_;

    /**
     * 0=low_accuracy>10m_such_as_nondifferential_GNSS_(default),__1=high_accuracy_<10m_such_as_DGNSS_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pos_accuracy;

    /**
     * 0_=_RAIM_not_in_use_(default),_1_=_RAIM_in_use_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rai_mflag;

    /**
     * 0-59=UTC_second_when_report_was_generated,_60=time_stamp_not_available(default),_61=Posing_system_is_in_manual_input_mode,_62=Electronic_Pos_fixing_system_operates_in_Est(dead_reckoning)mode,_63=Posing_system_is_inoperative_See_ITU-R_M.1371-1_for_m
     *
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t time_stamp;

    /**
     * The_direction_of_the_path_over_ground_actually_followed_by_a_vessel.
     *
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t cog;

    /**
     * Range: 0..65532 (0..655.32 m/s)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t sog;

    /**
     * The_Communication_State_contains_information_used_by_the_various_TDMA_slot_allocation_algorithms_and_synchronization_information_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..524287 (0..524287 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t communication_state;

    /**
     * 0_=_Channel_A_VDL_reception,_1_=_Channel_B_VDL_reception,_2_=_Channel_A_VDL_transmission,_3_=_Channel_B_VDL_transmission,_4_=_Own_information_not_broadcast,_5-31_=_Reserved.
     *
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ais_transceiver_information;

    /**
     * Degrees_clockwise_relative_to_True_North.
     *
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t true_heading;

    /**
     * +_=_Bow_turning_to_starboard,_1_deg/min_=_.00029_rad/sec
     *
     * Range: -32768..32767 (-32768..32767 rad/s)
     * Scale: 1
     * Offset: 0
     */
    int16_t rate_of_turn;

    /**
     * 0_=_under_way_using_Eng,_1_=_at_anchor,_2_=_not_under_Cmd,_3_=_restricted_manoeuvrability,_4_=_constrained_by_her_draught,_5_=_moored,_6_=_aground,_7_=_engaged_in_fishing,_8_=_under_way_sailing,_9_=_reserved_for_future_amendment_of_navigational_s
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t navigational_status;
};

/**
 * Signals in message AISBinaryBroadcastMsg.
 *
 * This_parameter_group_provides_data_associated_with_ITU-R_M1371_Msg_8_Binary_Broadcast_Msg_supporting_broadcast_communication_of_binary_dataAn_AIS_device_may_generate_this_parameter_group_either_upon_receiving_a_VHF_data_link_Msg_8,or_upon_receipt_of_an_
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_ais_binary_broadcast_msg_t {
    /**
     * Message_Identifier_(range_of_0_to_63)._See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t msg_id;

    /**
     * Used_by_the_repeater_to_indicate_how_many_times_a_message_has_been_repeated_(range_of_0_to_3)._0_=_Default_1_=_First_retransmission_2_=_Second_retransmission_3_=_Final_retransmission_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t repeat_indicator;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t source_id;

    /**
     * 0_=_Channel_A_VDL_reception,_1_=_Channel_B_VDL_reception,_2_=_Channel_A_VDL_transmission,_3_=_Channel_B_VDL_transmission,_4_=_Own_information_not_broadcast,_5-31_=_Reserved.
     *
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ais_transceiver_information;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t number_of_bits_in_binary_data_field;
};

/**
 * Signals in message AISAssignmentModeCmd.
 *
 * This_parameter_group_provides_data_associated_with_ITU-R_M1371_Msg_16_Assigned_Mode_Cmd_Msg_for_assigning_specific_behavior_by_a_competent_authorityAn_AIS_device_may_generate_this_parameter_group_either_upon_receiving_a_VHF_data_link_Msg_16,or_upon_rece
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_ais_assignment_mode_cmd_t {
    /**
     * Message_Identifier_(range_of_0_to_63)._See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t msg_id;

    /**
     * Used_by_the_repeater_to_indicate_how_many_times_a_message_has_been_repeated_(range_of_0_to_3)._0_=_Default_1_=_First_retransmission_2_=_Second_retransmission_3_=_Final_retransmission_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t repeat_indicator;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t source_id;

    /**
     * 0_=_Channel_A_VDL_reception,_1_=_Channel_B_VDL_reception,_2_=_Channel_A_VDL_transmission,_3_=_Channel_B_VDL_transmission,_4_=_Own_information_not_broadcast,_5-31_=_Reserved.
     *
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ais_transceiver_information;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t destination_ida;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t offset_a;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t increment_a;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t destination_idb;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t offset_b;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t increment_b;
};

/**
 * Signals in message ACKM.
 *
 * Acknowledgment_Message
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_ackm_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t control_byte;

    /**
     * Group_Function_of_PGN_being_acknowledged._This_field_identifies_for_a_device_the_specific_group_function_of_a_PGN_being_acknowledged_or_declined.__This_field_is_not_used_if_the_PGN_being_acknowledged_or_declined_is_not_a_group_function_PGN.
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t group_function_value;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t address_busy;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t address_access_denied;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t address_negative_acknowledgement;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t address_acknowledged;

    /**
     * PGN_which_is_requested_by_Request2_message
     *
     * Range: 0..16777215 (0..16777215 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t parameter_group_number;
};

/**
 * Signals in message DirectionData.
 *
 * purpose_of_this_PGN_is_to_group_three_fundamental_vectors_related_to_vessel_motion,_-Speed_and_heading_referenced_to_water_-Speed_and_course_referenced_to_ground_-Current_speed_and_flow_direction_Products_that_are_primary_form_of_navigation_would_
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_direction_data_t {
    /**
     * 0x0_=_Autonomous_mode,__0x1_=_Differential,_enhanced_mode,_0x2_=_Estimated_mode,_0x3_=_Simulator_mode,_0x4_=_Manual_mode,_0xE_=_Error,_0xF_=_Data_not_available
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_mode;

    /**
     * 0_=_True,__1_=_Magnetic,_2_=_Error,_3_=_Null
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t set_cog_heading_ref;

    /**
     * An_upward_counting_number_used_to_tie_related_information_together_between_different_PGNs.For_example,SID_would_be_used_to_tie_together_COG,SOG_and_RAIM_values_to_a_given_Pos.255=no_valid_Pos_fix_to_tie_it_to.Range_0_to_250_for_valid_Pos_fixes.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sid;

    /**
     * The_direction_of_the_path_over_ground_actually_followed_by_a_vessel.
     *
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t course_over_ground;

    /**
     * Range: 0..65532 (0..655.32 m/s)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t speed_over_ground;

    /**
     * The_horizontal_direction_in_which_a_ship_actually_points_or_heads_at_any_instant,_expressed_in_angular_units_from_a_reference_direction,_usually_from_000_at_the_reference_direction_clockwise_through_359_degrees.
     *
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t heading;

    /**
     * Range: 0..65532 (0..655.32 m/s)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t speed_through_water;

    /**
     * Direction_towards_which_current_flows.__Degrees_relative_to_True_North.
     *
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t set;

    /**
     * Range: 0..65532 (0..655.32 m/s)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t drift;
};

/**
 * Signals in message Datum.
 *
 * Local_geodetic_datum_and_datum_offsets_from_a_reference_datum_This_PGN_is_used_to_define_the_datum_to_which_a_position_location_output_by_the_same_device_in_other_PGNs_is_referenced
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_datum_t {
    /**
     * 4-character_code_for_datum_currently_being_output_for_Pos_solution.datum's_are_defined_in_IHO_Publication_S-60,Appendices_B_and_C.first_three_chars_are_datum_ID_as_per_IHO_tables.fourth_char_is_local_datum_subdivision_code.A_null_char_indicates_datum_subd
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint32_t local_datum;

    /**
     * Length_specified_by_PGN_field_definition.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint32_t reference_datum;
};

/**
 * Signals in message DSCCallInformation.
 *
 * This_PGN_provides_Digital_Selective_CallingDSCdata_according_to_ITU_M493-9_with_optional_expansion_according_to_ITU_M821-1_DSC_is_a_paging_system_that_is_used_to_automate_distress_alerts_sent_over_terrestrial_communication_systems_such_as_VHF,MF_and
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_dsc_call_information_t {
    /**
     * Integer_numbers_within_the_range_000_to_127_representing_DSC_Symbols_defined_by_ITU-R_M.493_Table_3_for:_Phasing_and_Unique_Functions_Format_Specifier_Category_Nature_of_Distress_First_Telecommand_Second_Telecommand
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dsc_format_symbol;

    /**
     * Integer_numbers_within_the_range_000_to_127_representing_DSC_Symbols_defined_by_ITU-R_M.493_Table_3_for:_Phasing_and_Unique_Functions_Format_Specifier_Category_Nature_of_Distress_First_Telecommand_Second_Telecommand
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dsc_category_symbol;

    /**
     * Individual_characters_having_only_decimal_values_in_range_0_to_127_for_DSC_symbols_defined_by_ITU-R_M.493_are_used_to_code_address_geographic_area_as_defined_in_ITU-R_M.493-9_Section_5.This_may_represent_an_individual_MMSI,a_group_MMSI,or_a_geographic_are
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint64_t dsc_msg_address;

    /**
     * Length_specified_by_PGN_field_definition.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint64_t proposed_rx_frequency_channel;

    /**
     * Length_specified_by_PGN_field_definition.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint64_t proposed_tx_frequency_channel;

    /**
     * Name_of_place,_route,_waypoint,_destination,_vessel,_vehicle,_etc.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint16_t telephone_number;

    /**
     * Length_specified_by_PGN_field_definition.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint64_t mmsi_of_ship_in_distress;

    /**
     * Length_specified_by_PGN_field_definition.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint64_t calling_rx_frequency_channel;

    /**
     * Length_specified_by_PGN_field_definition.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint64_t calling_tx_frequency_channel;

    /**
     * Name_of_place,_route,_waypoint,_destination,_vessel,_vehicle,_etc.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dsc_expansion_field_data;

    /**
     * Name_of_place,_route,_waypoint,_destination,_vessel,_vehicle,_etc.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint16_t var_nbr_of_flds_fld22_rep_exp_fld_data;
};

/**
 * Signals in message DGNSSCorrections.
 *
 * This_PGN_provides_a_means_to_pass_Diff_GNSS_corrections_between_NMEA_2000_devicesPassing_DGNSS_data_this_way_allows_for_more_flexibility_than_traditional_methodsOne_Diff_correction_receiver_could_supply_multiple_GNSS_receiversMultiple_Diff_correction_r
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_dgnss_corrections_t {
    /**
     * An_upward_counting_number_used_to_tie_related_information_together_between_different_PGNs.For_example,SID_would_be_used_to_tie_together_COG,SOG_and_RAIM_values_to_a_given_Pos.255=no_valid_Pos_fix_to_tie_it_to.Range_0_to_250_for_valid_Pos_fixes.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sequence_id_;

    /**
     * Reference_Station_ID.__Reference_Station_number_as_provided_by_the_Service_Provider.[Reference_document_required]
     *
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t reference_station_id;

    /**
     * Reference_Station_Type.__0x0=GP
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t reference_station_type;

    /**
     * Range: 0..6553 (0..6553.2 sec)
     * Scale: 1
     * Offset: 0
     */
    uint16_t time_of_corrections;

    /**
     * 0x00_=_Not_Working,_0x01_=_Unmonitored,_0x02_=_Healthy_&_Operational,_0x03_=_Healthy_&_in_Test_Mode,_0x04_=_In_Test_Mode_-_DO_NOT_USE,_0x05_-_0x15_=_Reserved
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t station_health;

    /**
     * 0_=_value_not_used,_1-32_=_GPS,_33-64_=_SBAS,Satellite,Based_Augmentation_System(ie_WAAS)_65-96_=_GLONASS._For_GLONASS,satellites_are_identified_by_64+satellite_slot_number.slot_numbers_are_1_through_24_for_full_GLONASS_constellation_of_24_satellite
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t satellite_id;

    /**
     * Range: -2147000000..2147000000 (-214700..214700 m)
     * Scale: 0.0001
     * Offset: 0
     */
    int32_t prc;

    /**
     * Range: -32764..32764 (-3.2764..3.2764 m/s)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t rrc;

    /**
     * Dependent_upon_PG_Field_definition.
     *
     * Range: 0..65532 (0..655.32 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t udre;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t iod;
};

/**
 * Signals in message CurrentStationData.
 *
 * Current_station_measurement_data_including_station_location,_numeric_identifier,_and_name
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_current_station_data_t {
    /**
     * Range_Residual_used_in_position_calculation_or_range_residuals_were_calculated_after_the_position.___0=range_residuals_were_used_to_calculate_dat
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mode;

    /**
     * 000_=_Flood,__001_=_Slack,_010_=_Ebb,_011_=_Reserved,_100_=_Reserved,_101_=_Reserved,_110_=_Error,_111_=_Unavailable,_Unknown
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t state;

    /**
     * Days_since_January_1,_1970,___Date_is_relative_to_UTC_Time.
     *
     * Range: 0..65532 (0..65532 day)
     * Scale: 1
     * Offset: 0
     */
    uint16_t measurement_date;

    /**
     * 24_hour_clock,_0_=__midnight,__time_is_in_UTC
     *
     * Range: 0..864010000 (0..86401 sec)
     * Scale: 0.0001
     * Offset: 0
     */
    uint32_t measurement_time;

    /**
     * Range: -90..90 (-90..90 deg)
     * Scale: 1
     * Offset: 0
     */
    int32_t station_location_latitude;

    /**
     * Range: -180..180 (-180..180 deg)
     * Scale: 1
     * Offset: 0
     */
    int32_t station_location_longitude;

    /**
     * Water_depth_measured_from_the_water_surface
     *
     * Range: 0..4295000000 (0..42950000 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint32_t measurement_depth;

    /**
     * Range: 0..65532 (0..655.32 m/s)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t current_speed;

    /**
     * Direction_towards_which_current_flows.__Degrees_relative_to_True_North.
     *
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t current_flow_direction;

    /**
     * Range: 0..65532 (0..655.32 K)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t water_temp;

    /**
     * Name_of_place,_route,_waypoint,_destination,_vessel,_vehicle,_etc.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint16_t station_id_string;

    /**
     * Name_of_place,_route,_waypoint,_destination,_vessel,_vehicle,_etc.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint16_t station_name_string;
};

/**
 * Signals in message CrossTrackError.
 *
 * This_PGN_provides_the_magnitude_of_position_error_perpendicular_to_the_desired_course
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_cross_track_error_t {
    /**
     * An_upward_counting_number_used_to_tie_related_information_together_between_different_PGNs.For_example,SID_would_be_used_to_tie_together_COG,SOG_and_RAIM_values_to_a_given_Pos.255=no_valid_Pos_fix_to_tie_it_to.Range_0_to_250_for_valid_Pos_fixes.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sid;

    /**
     * 0x0_=_Autonomous_mode,__0x1_=_Differential,_enhanced_mode,_0x2_=_Estimated_mode,_0x3_=_Simulator_mode,_0x4_=_Manual_mode,_0xE_=_Error,_0xF_=_Data_not_available
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t xte_mode;

    /**
     * MSB/LSB:__00_=_[No,_Off,_Disabled,_Reset,_'0'],_01_=_[Yes,_On,_Enabled,_Set,_'1'],_10_=_Error,_11=_[Unavailable,_Unknown]
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t navigation_terminated;

    /**
     * Cross-track-error_of_a_route.__'-'_=_Left_of_track,_need_to_steer_right
     *
     * Range: -2147000000..2147000000 (-21470000..21470000 m)
     * Scale: 0.01
     * Offset: 0
     */
    int32_t xte;
};

/**
 * Signals in message COGSOGRapidUpdate.
 *
 * This_PGN_is_a_single_frame_PGN_that_provides_Course_Over_GroundCOGand_Speed_Over_GroundSOG_Being_a_single_frame_Msg,as_opposed_to_other_PGNs_that_include_COG_and_SOG_and_are_defined_as_multi-packet,this_PGN_lends_itself_to_being_transmitted_more_f
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_cogsog_rapid_update_t {
    /**
     * An_upward_counting_number_used_to_tie_related_information_together_between_different_PGNs.For_example,SID_would_be_used_to_tie_together_COG,SOG_and_RAIM_values_to_a_given_Pos.255=no_valid_Pos_fix_to_tie_it_to.Range_0_to_250_for_valid_Pos_fixes.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sid;

    /**
     * 0_=_True,__1_=_Magnetic,_2_=_Error,_3_=_Null
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cog_reference;

    /**
     * The_direction_of_the_path_over_ground_actually_followed_by_a_vessel.
     *
     * Range: 0..62832 (0..6.28318 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t course_over_ground;

    /**
     * Range: 0..65532 (0..655.32 m/s)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t speed_over_ground;
};

/**
 * Signals in message AISAddressedSafetyRelatedMsg.
 *
 * This_parameter_group_provides_data_associated_with_ITU-R_M1371_Msg_12_Addressed_Safety_Related_Msg_supporting_addressed_communication_of_safety_related_dataAn_AIS_device_may_generate_this_parameter_group_either_upon_receiving_a_VHF_data_link_Msg_12,or_u
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_ais_addressed_safety_related_msg_t {
    /**
     * Message_Identifier_(range_of_0_to_63)._See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t msg_id;

    /**
     * Used_by_the_repeater_to_indicate_how_many_times_a_message_has_been_repeated_(range_of_0_to_3)._0_=_Default_1_=_First_retransmission_2_=_Second_retransmission_3_=_Final_retransmission_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t repeat_indicator;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t source_id;

    /**
     * 0_=_Channel_A_VDL_reception,_1_=_Channel_B_VDL_reception,_2_=_Channel_A_VDL_transmission,_3_=_Channel_B_VDL_transmission,_4_=_Own_information_not_broadcast,_5-31_=_Reserved.
     *
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ais_transceiver_information;

    /**
     * Range_0-3_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sequence_number_;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t destination_id;

    /**
     * 0=No_retransmission,_1=retransmitted._See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t retransmit_flag;

    /**
     * Name_of_place,_route,_waypoint,_destination,_vessel,_vehicle,_etc.
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t safety_related_text;
};

/**
 * Signals in message AISAddressedBinaryMsg.
 *
 * This_parameter_group_provides_data_associated_with_ITU-R_M1371_Msg_6_Addressed_Binary_Msg_supporting_address_communication_of_binary_dataAn_AIS_device_may_generate_this_parameter_group_either_upon_receiving_a_VHF_data_link_Msg_6,or_upon_receipt_of_an_IS
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_ais_addressed_binary_msg_t {
    /**
     * Message_Identifier_(range_of_0_to_63)._See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t msg_id;

    /**
     * Used_by_the_repeater_to_indicate_how_many_times_a_message_has_been_repeated_(range_of_0_to_3)._0_=_Default_1_=_First_retransmission_2_=_Second_retransmission_3_=_Final_retransmission_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t repeat_indicator;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t source_id;

    /**
     * 0_=_Channel_A_VDL_reception,_1_=_Channel_B_VDL_reception,_2_=_Channel_A_VDL_transmission,_3_=_Channel_B_VDL_transmission,_4_=_Own_information_not_broadcast,_5-31_=_Reserved.
     *
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ais_transceiver_information;

    /**
     * Range_0-3_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sequence_number_;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t destination_id;

    /**
     * 0=No_retransmission,_1=retransmitted._See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t retransmit_flag;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t number_of_bits_in_binary_data_field;
};

/**
 * Signals in message AISAcknowledge.
 *
 * This_parameter_group_provides_data_associated_with_ITU-R_M1371_Msgs_7_Binary_Acknowledge_Msg_and_13_Safety_Related_Acknowledge_MsgMsg_7_acknowledges_receipt_of_Msg_6_while_Msg_13_acknowledges_receipt_of_Msg_14An_AIS_device_may_generate_this_parameter_g
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_ais_acknowledge_t {
    /**
     * Message_Identifier_(range_of_0_to_63)._See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t msg_id;

    /**
     * Used_by_the_repeater_to_indicate_how_many_times_a_message_has_been_repeated_(range_of_0_to_3)._0_=_Default_1_=_First_retransmission_2_=_Second_retransmission_3_=_Final_retransmission_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t repeat_indicator;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t source_id;

    /**
     * 0_=_Channel_A_VDL_reception,_1_=_Channel_B_VDL_reception,_2_=_Channel_A_VDL_transmission,_3_=_Channel_B_VDL_transmission,_4_=_Own_information_not_broadcast,_5-31_=_Reserved.
     *
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ais_transceiver_information;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t destination_id1;

    /**
     * Range_0-3_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sequence_number_for_id1;

    /**
     * Range_0-3_See_ITU-R_M.1371-1_for_more_information.
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sequence_number_for_i_dn;
};

/**
 * Signals in message AC_Input_Status.
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_ac_input_status_t {
    /**
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ac_instance;

    /**
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t number_of_lines;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t line;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acceptability;

    /**
     * Range: -65532..65532 (-655.32..655.32 V)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t voltage;

    /**
     * Range: 0..65532 (0..6553.2 A)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t current;

    /**
     * Range: 0..65532 (0..655.32 Hz)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t frequency;

    /**
     * Range: 0..65532 (0..6553.2 A)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t breaker_size;

    /**
     * Range: 0..4294967292 (0..4294967292 W)
     * Scale: 1
     * Offset: 0
     */
    uint32_t real_power;

    /**
     * Range: 0..4294967292 (0..4294967292 VAR)
     * Scale: 1
     * Offset: 0
     */
    uint32_t reactive_power;

    /**
     * Range: -100..100 (-1..1 -)
     * Scale: 0.01
     * Offset: 0
     */
    int8_t power_factor;
};

/**
 * Signals in message AC_Output_Status.
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_ac_output_status_t {
    /**
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ac_instance;

    /**
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t number_of_lines;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t line;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t waveform;

    /**
     * Range: -65532..65532 (-655.32..655.32 V)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t voltage;

    /**
     * Range: 0..65532 (0..6553.2 A)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t current;

    /**
     * Range: 0..65532 (0..655.32 Hz)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t frequency;

    /**
     * Range: 0..65532 (0..6553.2 A)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t breaker_size;

    /**
     * Range: 0..4294967292 (0..4294967292 W)
     * Scale: 1
     * Offset: 0
     */
    uint32_t real_power;

    /**
     * Range: 0..4294967292 (0..4294967292 VAR)
     * Scale: 1
     * Offset: 0
     */
    uint32_t reactive_power;

    /**
     * Range: -100..100 (-1..1 -)
     * Scale: 0.01
     * Offset: 0
     */
    int8_t power_factor;
};

/**
 * Signals in message DC_Detailed_Status.
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_dc_detailed_status_t {
    /**
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sid;

    /**
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_instance;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_type;

    /**
     * Range: 0..252 (0..252 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t state_of_charge;

    /**
     * Range: 0..252 (0..252 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t state_of_health;

    /**
     * Range: 0..65532 (0..65532 minute)
     * Scale: 1
     * Offset: 0
     */
    uint16_t time_remaining;

    /**
     * Range: 0..65 (0..65 V)
     * Scale: 1
     * Offset: 0
     */
    uint16_t ripple_voltage;
};

/**
 * Signals in message Charger_Status.
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_charger_status_t {
    /**
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t charger_instance;

    /**
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t battery_instance;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t operating_state;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t charge_mode;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t charger_enable_disable;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t equalization_pending;

    /**
     * Range: 0..65532 (0..65532 minute)
     * Scale: 1
     * Offset: 0
     */
    uint16_t equalization_time_remaining;
};

/**
 * Signals in message Inverter_Status.
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_inverter_status_t {
    /**
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t inverter_instance;

    /**
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ac_instance;

    /**
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_instance;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t operating_state;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t inverter_enable_disable;
};

/**
 * Signals in message Charger_Configuration_Status.
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_charger_configuration_status_t {
    /**
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t charger_instance;

    /**
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t battery_instance;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t charger_enable_disable;

    /**
     * Range: 0..252 (0..252 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t charge_current_limit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t charging_algorithm;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t charger_mode;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t estimated_battery_temp_when_no_sensor;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t equalize_one_time_enable_disable;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t over_charge_enable_disable;

    /**
     * Range: 0..65532 (0..65532 minute)
     * Scale: 1
     * Offset: 0
     */
    uint16_t equalize_time;
};

/**
 * Signals in message Inverter_Configuration_Status.
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_inverter_configuration_status_t {
    /**
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t inverter_instance;

    /**
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ac_instance;

    /**
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_instance;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t inverter_enable_disable;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t inverter_mode;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t load_sense_enable_disable;

    /**
     * Range: 0..65532 (0..65532 W)
     * Scale: 1
     * Offset: 0
     */
    uint16_t load_sense_power_threshold;

    /**
     * Range: 0..65532 (0..655.32 s)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t load_sense_interval;
};

/**
 * Signals in message AGS_Configuration_Status.
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_ags_configuration_status_t {
    /**
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ags_instance;

    /**
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t generator_instance;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ags_mode;
};

/**
 * Signals in message Battery_Configuration_Status.
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_battery_configuration_status_t {
    /**
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t battery_instance;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t battery_type;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t support_equalization;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nominal_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t battery_chemistry;

    /**
     * Range: 0..65532 (0..235915200 C)
     * Scale: 3600
     * Offset: 0
     */
    uint16_t battery_capacity;

    /**
     * Range: -124..124 (-124..124 %)
     * Scale: 1
     * Offset: 0
     */
    int8_t battery_temperature_coefficient;

    /**
     * Range: 500..750 (1..1.5 -)
     * Scale: 0.002
     * Offset: 0
     */
    uint8_t peukert_exponent;

    /**
     * Range: -124..124 (-124..124 %)
     * Scale: 1
     * Offset: 0
     */
    int8_t charge_efficiency_factor;
};

/**
 * Signals in message AGS_Status.
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_ags_status_t {
    /**
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ags_instance;

    /**
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t generator_instance;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ags_operating_state;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t generator_state;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t generator_on_reason;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t generator_off_reason;
};

/**
 * Signals in message AIS_Channel_Management.
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_ais_channel_management_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t message_id;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t repeat_indicator;

    /**
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t station_id;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ais_transceiver_information;

    /**
     * Range: 0..66 (0..65.532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t channel_a;

    /**
     * Range: 0..66 (0..65.532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t channel_b;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t power;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tx_rx_mode;

    /**
     * Range: -1800000000..1800000000 (-180..180 deg)
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t north_east_longitude_corner_1;

    /**
     * Range: -900000000..900000000 (-90..90 deg)
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t north_east_latitude_corner_1;

    /**
     * Range: -1800000000..1800000000 (-180..180 deg)
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t south_west_longitude_corner_2;

    /**
     * Range: -900000000..900000000 (-90..90 deg)
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t south_west_latitude_corner_2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t addressed_or_broadcast_message_indicator;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t channel_a_bandwidth;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t channel_b_bandwidth;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t transitional_zone_site;
};

/**
 * Signals in message AIS_Class_B_Group_Assignment.
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_ais_class_b_group_assignment_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t message_id;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t repeat_indicator;

    /**
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t source_id;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tx_rx_mode;

    /**
     * Range: -1800000000..1800000000 (-180..180 deg)
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t north_east_longitude_corner_1;

    /**
     * Range: -900000000..900000000 (-90..90 deg)
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t north_east_latitude_corner_1;

    /**
     * Range: -1800000000..1800000000 (-180..180 deg)
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t south_west_longitude_corner_2;

    /**
     * Range: -900000000..900000000 (-90..90 deg)
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t south_west_latitude_corner_2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t station_type;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ship_and_cargo_filter;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t reporting_interval;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t quiet_time;
};

/**
 * Signals in message AIS_Class_B_CS_Static_Data_Report_Part_A.
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_ais_class_b_cs_static_data_report_part_a_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t message_id;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t repeat_indicator;

    /**
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t user_id;

    /**
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint64_t name;
};

/**
 * Signals in message AIS_Class_B_CS_Static_Data_Report_Part_B.
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t message_id;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t repeat_indicator;

    /**
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t user_id;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t type_of_ship_and_cargo;

    /**
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint64_t vendor_id;

    /**
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint64_t call_sign;

    /**
     * Range: 0..65532 (0..6553.2 m)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t ship_length;

    /**
     * Range: 0..65532 (0..6553.2 m)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t ship_beam;

    /**
     * Range: 0..65532 (0..6553.2 m)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t reference_point_position_from_starboard;

    /**
     * Range: 0..65532 (0..6553.2 m)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t reference_point_position_aft_of_bow;

    /**
     * Range: 0..4294967292 (0..4294967292 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t mother_ship_mmsi;
};

/**
 * Signals in message Temperature.
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_temperature_t {
    /**
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sid;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t temperature_instance;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t temperature_source;

    /**
     * Range: 0..65532 (0..655.32 degK)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t actual_temperature;

    /**
     * Range: 0..65532 (0..655.32 degK)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t set_temperature;
};

/**
 * Signals in message Humidity.
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_humidity_t {
    /**
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sid;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t humidity_instance;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t humidity_source;

    /**
     * Range: -32768..32764 (-131.072..131.056 %)
     * Scale: 0.004
     * Offset: 0
     */
    int16_t actual_humidity;

    /**
     * Range: -32768..32764 (-131.072..131.056 %)
     * Scale: 0.004
     * Offset: 0
     */
    uint16_t set_humidity;
};

/**
 * Signals in message Actual_Pressure.
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_actual_pressure_t {
    /**
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sid;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pressure_instance;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pressure_source;

    /**
     * Range: -2100000000..2100000000 (-210000000..210000000 Pa)
     * Scale: 0.1
     * Offset: 0
     */
    int32_t pressure;
};

/**
 * Signals in message Set_Pressure.
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_set_pressure_t {
    /**
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sid;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pressure_instance;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pressure_source;

    /**
     * Range: -2100000000..2100000000 (-210000000..210000000 Pa)
     * Scale: 0.1
     * Offset: 0
     */
    int32_t pressure;
};

/**
 * Signals in message EnvironmentalParameters2.
 *
 * Environmental_Conditions_contains_Temperature,_Humidity,_and_Atmospheric_Pressure__This_PGN_is_a_rework_of_PGN_130310_and_is_to_be_used_for_new_designs
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_environmental_parameters2_t {
    /**
     * An_upward_counting_number_used_to_tie_related_information_together_between_different_PGNs.For_example,SID_would_be_used_to_tie_together_COG,SOG_and_RAIM_values_to_a_given_Pos.255=no_valid_Pos_fix_to_tie_it_to.Range_0_to_250_for_valid_Pos_fixes.
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sequence_id_;

    /**
     * 0x00_=_Sea_Temperature,_0x01_=_Outside_Temperature,_0x02_=_Inside_Temperature,_0x03_=_Engine_Room_Temperature,_0x04_=_Main_Cabin_Temperature,_0x05_=_Reserve,_thru_0x3E_=_Reserve,_0x3F_=_Data_Not_Available
     *
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t temp_instance;

    /**
     * 0x00_=_Inside_Humidity,_0x01_=_Outside_Humidity,_0x02_=_reserved,_0x03_=_Data_Not_Available
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t humidity_instance;

    /**
     * Range: 0..65532 (0..655.32 K)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t temp;

    /**
     * Range: -32768..32764 (-131.072..131.056 %)
     * Scale: 0.004
     * Offset: 0
     */
    int16_t humidity;

    /**
     * Range: 0..65532 (0..6553200 Pa)
     * Scale: 100
     * Offset: 0
     */
    uint16_t atmospheric_press;
};

/**
 * Signals in message ProductInformation.
 *
 * Provides_product_information_onto_network_that_could_be_important_for_determining_quality_of_data_coming_from_this_productEach_field_must_be_provided_if_data_is_typically_available_from_such_a_productAt_Min_NMEA_2000_Version,NMEA_Manufacturers_Product_
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_product_information_t {
    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t nmea2000_database_version;

    /**
     * Number_of_route,_waypoint,_event,_mark,_etc.
     *
     * Range: 0..65532 (0..65532 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t nmea_manufacturers_product_code;

    /**
     * Length_specified_by_PGN_field_definition.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint64_t manufacturers_model_id;

    /**
     * Length_specified_by_PGN_field_definition.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint64_t manufacturers_software_version_code;

    /**
     * Length_specified_by_PGN_field_definition.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint64_t manufacturers_model_version;

    /**
     * Length_specified_by_PGN_field_definition.
     *
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint64_t manufacturers_model_serial_code;
};

/**
 * Signals in message ConfigInformation.
 *
 * Free-form_alphanumeric_fields_describing_the_installation__eg,_starboard_engine_room_location_of_the_device_and_installation_notes_eg,_calibration_data
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_config_information_t {
    /**
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint64_t installation_description_field1;

    /**
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint64_t installation_description_field2;

    /**
     * Range: 0..255 (0..255 ASCII)
     * Scale: 1
     * Offset: 0
     */
    uint64_t manufacturer_information_field3;
};

/**
 * Signals in message PGNLstTransmitPGNsGroupFunction.
 *
 * Transmit/Receive_PGN_List_Group_type_of_function_is_defined_by_first_fieldMsg_will_be_a_Transmit_Receive_PGN_List_group_functionThese_are_defined_as_follows:_Transmit_PGN_List_group_function:This_Msg_contains_a_list_of_Transmitted_PGNs_that_are_suppo
 *
 * All signal values are as on the CAN bus.
 */
struct nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_t {
    /**
     * 0_=_Transmit_PGN_List_Message,__1_=_Receive_PGN_List_Message
     *
     * Range: 0..252 (0..252 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t grp_fnctn_trnsmt_and_receive_pgn_list;

    /**
     * 24-bit_Parameter_Group_Number_(PGN)_expressed_in_binary,_LSB_is_transmitted_first
     *
     * Range: 0..16777215 (0..16777215 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t first_pgn_supported2;

    /**
     * 24-bit_Parameter_Group_Number_(PGN)_expressed_in_binary,_LSB_is_transmitted_first
     *
     * Range: 0..16777215 (0..16777215 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t first_pgn_supported;

    /**
     * 24-bit_Parameter_Group_Number_(PGN)_expressed_in_binary,_LSB_is_transmitted_first
     *
     * Range: 0..16777215 (0..16777215 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t vrbl_nmbr_of_flds_fld_nmber2_repeated2;

    /**
     * 24-bit_Parameter_Group_Number_(PGN)_expressed_in_binary,_LSB_is_transmitted_first
     *
     * Range: 0..16777215 (0..16777215 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t vrbl_nmbr_of_flds_fld_nmber2_repeated;

    /**
     * Range: 0..16777215 (0..16777215 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t pgn_supported3;

    /**
     * Range: 0..16777215 (0..16777215 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t pgn_supported3_2;

    /**
     * Range: 0..16777215 (0..16777215 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t pgn_supported4;

    /**
     * Range: 0..16777215 (0..16777215 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t pgn_supported4_2;

    /**
     * Range: 0..16777215 (0..16777215 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t pgn_supported5;

    /**
     * Range: 0..16777215 (0..16777215 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t pgn_supported5_2;
};

/**
 * Pack message Time_Date.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_time_date_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_time_date_t *src_p,
    size_t size);

/**
 * Unpack message Time_Date.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_time_date_unpack(
    struct nmea2000_exxo_time_date_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Time_Date.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_time_date_init(struct nmea2000_exxo_time_date_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_time_date_date_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_time_date_date_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_time_date_date_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_time_date_time_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_time_date_time_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_time_date_time_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_time_date_local_offset_minutes_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_time_date_local_offset_minutes_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_time_date_local_offset_minutes_is_in_range(int16_t value);

/**
 * Pack message TimeTo_FromMark.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_time_to_from_mark_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_time_to_from_mark_t *src_p,
    size_t size);

/**
 * Unpack message TimeTo_FromMark.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_time_to_from_mark_unpack(
    struct nmea2000_exxo_time_to_from_mark_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TimeTo_FromMark.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_time_to_from_mark_init(struct nmea2000_exxo_time_to_from_mark_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_time_to_from_mark_sid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_time_to_from_mark_sid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_time_to_from_mark_sid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_time_to_from_mark_time_elapsed_togo_to_mark_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_time_to_from_mark_time_elapsed_togo_to_mark_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_time_to_from_mark_time_elapsed_togo_to_mark_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_time_to_from_mark_mark_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_time_to_from_mark_mark_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_time_to_from_mark_mark_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_time_to_from_mark_mark_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_time_to_from_mark_mark_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_time_to_from_mark_mark_id_is_in_range(uint32_t value);

/**
 * Pack message TideStationData.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_tide_station_data_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_tide_station_data_t *src_p,
    size_t size);

/**
 * Unpack message TideStationData.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_tide_station_data_unpack(
    struct nmea2000_exxo_tide_station_data_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TideStationData.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_tide_station_data_init(struct nmea2000_exxo_tide_station_data_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_tide_station_data_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tide_station_data_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tide_station_data_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_tide_station_data_tide_tendency_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tide_station_data_tide_tendency_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tide_station_data_tide_tendency_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_tide_station_data_measurement_date_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tide_station_data_measurement_date_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tide_station_data_measurement_date_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_tide_station_data_measurement_time_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tide_station_data_measurement_time_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tide_station_data_measurement_time_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_tide_station_data_station_location_latitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tide_station_data_station_location_latitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tide_station_data_station_location_latitude_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_tide_station_data_station_location_longitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tide_station_data_station_location_longitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tide_station_data_station_location_longitude_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_tide_station_data_tide_level_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tide_station_data_tide_level_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tide_station_data_tide_level_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_tide_station_data_tide_level_standard_deviation_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tide_station_data_tide_level_standard_deviation_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tide_station_data_tide_level_standard_deviation_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_tide_station_data_station_id_string_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tide_station_data_station_id_string_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tide_station_data_station_id_string_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_tide_station_data_station_name_string_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tide_station_data_station_name_string_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tide_station_data_station_name_string_is_in_range(uint16_t value);

/**
 * Pack message SystemTime.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_system_time_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_system_time_t *src_p,
    size_t size);

/**
 * Unpack message SystemTime.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_system_time_unpack(
    struct nmea2000_exxo_system_time_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SystemTime.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_system_time_init(struct nmea2000_exxo_system_time_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_system_time_sid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_system_time_sid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_system_time_sid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_system_time_source_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_system_time_source_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_system_time_source_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_system_time_date_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_system_time_date_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_system_time_date_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_system_time_time_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_system_time_time_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_system_time_time_is_in_range(uint32_t value);

/**
 * Pack message SwitchBankCtrl.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_switch_bank_ctrl_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_switch_bank_ctrl_t *src_p,
    size_t size);

/**
 * Unpack message SwitchBankCtrl.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_switch_bank_ctrl_unpack(
    struct nmea2000_exxo_switch_bank_ctrl_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SwitchBankCtrl.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_switch_bank_ctrl_init(struct nmea2000_exxo_switch_bank_ctrl_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_switch_bank_ctrl_switch_bank_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_switch_bank_ctrl_switch_bank_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_switch_bank_ctrl_switch_bank_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_switch_bank_ctrl_switch1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_switch_bank_ctrl_switch1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_switch_bank_ctrl_switch1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_switch_bank_ctrl_switch2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_switch_bank_ctrl_switch2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_switch_bank_ctrl_switch2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_switch_bank_ctrl_switch3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_switch_bank_ctrl_switch3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_switch_bank_ctrl_switch3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_switch_bank_ctrl_switch4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_switch_bank_ctrl_switch4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_switch_bank_ctrl_switch4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_switch_bank_ctrl_switch5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_switch_bank_ctrl_switch5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_switch_bank_ctrl_switch5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_switch_bank_ctrl_switch6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_switch_bank_ctrl_switch6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_switch_bank_ctrl_switch6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_switch_bank_ctrl_switch7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_switch_bank_ctrl_switch7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_switch_bank_ctrl_switch7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_switch_bank_ctrl_switch8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_switch_bank_ctrl_switch8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_switch_bank_ctrl_switch8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_switch_bank_ctrl_switch9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_switch_bank_ctrl_switch9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_switch_bank_ctrl_switch9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_switch_bank_ctrl_switch10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_switch_bank_ctrl_switch10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_switch_bank_ctrl_switch10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_switch_bank_ctrl_switch11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_switch_bank_ctrl_switch11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_switch_bank_ctrl_switch11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_switch_bank_ctrl_switch12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_switch_bank_ctrl_switch12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_switch_bank_ctrl_switch12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_switch_bank_ctrl_switch13_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_switch_bank_ctrl_switch13_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_switch_bank_ctrl_switch13_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_switch_bank_ctrl_switch14_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_switch_bank_ctrl_switch14_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_switch_bank_ctrl_switch14_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_switch_bank_ctrl_switch15_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_switch_bank_ctrl_switch15_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_switch_bank_ctrl_switch15_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_switch_bank_ctrl_switch16_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_switch_bank_ctrl_switch16_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_switch_bank_ctrl_switch16_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_switch_bank_ctrl_switch17_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_switch_bank_ctrl_switch17_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_switch_bank_ctrl_switch17_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_switch_bank_ctrl_switch18_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_switch_bank_ctrl_switch18_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_switch_bank_ctrl_switch18_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_switch_bank_ctrl_switch19_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_switch_bank_ctrl_switch19_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_switch_bank_ctrl_switch19_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_switch_bank_ctrl_switch20_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_switch_bank_ctrl_switch20_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_switch_bank_ctrl_switch20_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_switch_bank_ctrl_switch21_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_switch_bank_ctrl_switch21_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_switch_bank_ctrl_switch21_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_switch_bank_ctrl_switch22_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_switch_bank_ctrl_switch22_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_switch_bank_ctrl_switch22_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_switch_bank_ctrl_switch23_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_switch_bank_ctrl_switch23_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_switch_bank_ctrl_switch23_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_switch_bank_ctrl_switch24_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_switch_bank_ctrl_switch24_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_switch_bank_ctrl_switch24_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_switch_bank_ctrl_switch25_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_switch_bank_ctrl_switch25_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_switch_bank_ctrl_switch25_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_switch_bank_ctrl_switch26_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_switch_bank_ctrl_switch26_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_switch_bank_ctrl_switch26_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_switch_bank_ctrl_switch27_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_switch_bank_ctrl_switch27_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_switch_bank_ctrl_switch27_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_switch_bank_ctrl_switch28_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_switch_bank_ctrl_switch28_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_switch_bank_ctrl_switch28_is_in_range(uint8_t value);

/**
 * Pack message SpeedWaterReferenced.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_speed_water_referenced_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_speed_water_referenced_t *src_p,
    size_t size);

/**
 * Unpack message SpeedWaterReferenced.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_speed_water_referenced_unpack(
    struct nmea2000_exxo_speed_water_referenced_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SpeedWaterReferenced.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_speed_water_referenced_init(struct nmea2000_exxo_speed_water_referenced_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_speed_water_referenced_sequence_id__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_speed_water_referenced_sequence_id__decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_speed_water_referenced_sequence_id__is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_speed_water_referenced_speed_water_referenced_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_speed_water_referenced_speed_water_referenced_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_speed_water_referenced_speed_water_referenced_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_speed_water_referenced_speed_ground_referenced_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_speed_water_referenced_speed_ground_referenced_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_speed_water_referenced_speed_ground_referenced_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_speed_water_referenced_speed_water_referenced_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_speed_water_referenced_speed_water_referenced_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_speed_water_referenced_speed_water_referenced_type_is_in_range(uint8_t value);

/**
 * Pack message SmallCraftStatus.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_small_craft_status_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_small_craft_status_t *src_p,
    size_t size);

/**
 * Unpack message SmallCraftStatus.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_small_craft_status_unpack(
    struct nmea2000_exxo_small_craft_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SmallCraftStatus.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_small_craft_status_init(struct nmea2000_exxo_small_craft_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t nmea2000_exxo_small_craft_status_port_trim_tab_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_small_craft_status_port_trim_tab_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_small_craft_status_port_trim_tab_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t nmea2000_exxo_small_craft_status_starboard_trim_tab_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_small_craft_status_starboard_trim_tab_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_small_craft_status_starboard_trim_tab_is_in_range(int8_t value);

/**
 * Pack message SetDriftRapidUpdate.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_set_drift_rapid_update_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_set_drift_rapid_update_t *src_p,
    size_t size);

/**
 * Unpack message SetDriftRapidUpdate.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_set_drift_rapid_update_unpack(
    struct nmea2000_exxo_set_drift_rapid_update_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SetDriftRapidUpdate.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_set_drift_rapid_update_init(struct nmea2000_exxo_set_drift_rapid_update_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_set_drift_rapid_update_sid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_set_drift_rapid_update_sid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_set_drift_rapid_update_sid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_set_drift_rapid_update_set_reference_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_set_drift_rapid_update_set_reference_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_set_drift_rapid_update_set_reference_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_set_drift_rapid_update_set_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_set_drift_rapid_update_set_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_set_drift_rapid_update_set_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_set_drift_rapid_update_drift_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_set_drift_rapid_update_drift_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_set_drift_rapid_update_drift_is_in_range(uint16_t value);

/**
 * Pack message SalinityStationData.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_salinity_station_data_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_salinity_station_data_t *src_p,
    size_t size);

/**
 * Unpack message SalinityStationData.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_salinity_station_data_unpack(
    struct nmea2000_exxo_salinity_station_data_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SalinityStationData.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_salinity_station_data_init(struct nmea2000_exxo_salinity_station_data_t *msg_p);

/**
 * Pack message RouteAndWPServiceRouteWPNamePos.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_route_and_wp_service_route_wp_name_pos_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_route_and_wp_service_route_wp_name_pos_t *src_p,
    size_t size);

/**
 * Unpack message RouteAndWPServiceRouteWPNamePos.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_route_and_wp_service_route_wp_name_pos_unpack(
    struct nmea2000_exxo_route_and_wp_service_route_wp_name_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RouteAndWPServiceRouteWPNamePos.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_route_and_wp_service_route_wp_name_pos_init(struct nmea2000_exxo_route_and_wp_service_route_wp_name_pos_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_route_wp_name_pos_start_rps_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_route_wp_name_pos_start_rps_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_route_wp_name_pos_start_rps_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_route_wp_name_pos_n_items_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_route_wp_name_pos_n_items_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_route_wp_name_pos_n_items_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_route_wp_name_pos_number_of_w_ps_in_route_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_route_wp_name_pos_number_of_w_ps_in_route_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_route_wp_name_pos_number_of_w_ps_in_route_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_route_wp_name_pos_database_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_route_wp_name_pos_database_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_route_wp_name_pos_database_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_route_wp_name_pos_route_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_route_wp_name_pos_route_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_route_wp_name_pos_route_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_route_wp_name_pos_wpid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_route_wp_name_pos_wpid_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_route_wp_name_pos_wpid_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_route_wp_name_pos_wp_name_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_route_wp_name_pos_wp_name_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_route_wp_name_pos_wp_name_is_in_range(uint16_t value);

/**
 * Pack message RouteAndWPServiceRouteWPName.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_route_and_wp_service_route_wp_name_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_route_and_wp_service_route_wp_name_t *src_p,
    size_t size);

/**
 * Unpack message RouteAndWPServiceRouteWPName.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_route_and_wp_service_route_wp_name_unpack(
    struct nmea2000_exxo_route_and_wp_service_route_wp_name_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RouteAndWPServiceRouteWPName.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_route_and_wp_service_route_wp_name_init(struct nmea2000_exxo_route_and_wp_service_route_wp_name_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_route_wp_name_start_rps_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_route_wp_name_start_rps_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_route_wp_name_start_rps_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_route_wp_name_n_items_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_route_wp_name_n_items_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_route_wp_name_n_items_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_route_wp_name_number_of_w_ps_in_route_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_route_wp_name_number_of_w_ps_in_route_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_route_wp_name_number_of_w_ps_in_route_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_route_wp_name_database_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_route_wp_name_database_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_route_wp_name_database_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_route_wp_name_route_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_route_wp_name_route_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_route_wp_name_route_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_route_wp_name_wpid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_route_wp_name_wpid_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_route_wp_name_wpid_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_route_wp_name_wp_name_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_route_wp_name_wp_name_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_route_wp_name_wp_name_is_in_range(uint16_t value);

/**
 * Pack message RouteAndWPServiceRouteList.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_route_and_wp_service_route_list_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_route_and_wp_service_route_list_t *src_p,
    size_t size);

/**
 * Unpack message RouteAndWPServiceRouteList.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_route_and_wp_service_route_list_unpack(
    struct nmea2000_exxo_route_and_wp_service_route_list_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RouteAndWPServiceRouteList.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_route_and_wp_service_route_list_init(struct nmea2000_exxo_route_and_wp_service_route_list_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_route_list_start_route_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_route_list_start_route_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_route_list_start_route_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_route_list_n_items_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_route_list_n_items_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_route_list_n_items_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_route_list_nmbr_of_routes_available_in_database_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_route_list_nmbr_of_routes_available_in_database_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_route_list_nmbr_of_routes_available_in_database_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_route_list_database_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_route_list_database_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_route_list_database_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_route_list_route_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_route_list_route_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_route_list_route_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_route_list_route_name_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_route_list_route_name_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_route_list_route_name_is_in_range(uint16_t value);

/**
 * Pack message RouteAndWPServiceRouteComment.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_route_and_wp_service_route_comment_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_route_and_wp_service_route_comment_t *src_p,
    size_t size);

/**
 * Unpack message RouteAndWPServiceRouteComment.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_route_and_wp_service_route_comment_unpack(
    struct nmea2000_exxo_route_and_wp_service_route_comment_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RouteAndWPServiceRouteComment.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_route_and_wp_service_route_comment_init(struct nmea2000_exxo_route_and_wp_service_route_comment_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_route_comment_start_route_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_route_comment_start_route_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_route_comment_start_route_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_route_comment_n_items_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_route_comment_n_items_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_route_comment_n_items_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_route_comment_number_of_routes_with_comments_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_route_comment_number_of_routes_with_comments_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_route_comment_number_of_routes_with_comments_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_route_comment_database_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_route_comment_database_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_route_comment_database_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_route_comment_route_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_route_comment_route_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_route_comment_route_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_route_and_wp_service_route_comment_comment_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_route_comment_comment_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_route_comment_comment_is_in_range(uint32_t value);

/**
 * Pack message RouteAndWPServiceRadiusOfTurn.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_route_and_wp_service_radius_of_turn_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_route_and_wp_service_radius_of_turn_t *src_p,
    size_t size);

/**
 * Unpack message RouteAndWPServiceRadiusOfTurn.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_route_and_wp_service_radius_of_turn_unpack(
    struct nmea2000_exxo_route_and_wp_service_radius_of_turn_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RouteAndWPServiceRadiusOfTurn.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_route_and_wp_service_radius_of_turn_init(struct nmea2000_exxo_route_and_wp_service_radius_of_turn_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_radius_of_turn_start_rps_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_radius_of_turn_start_rps_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_radius_of_turn_start_rps_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_radius_of_turn_n_items_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_radius_of_turn_n_items_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_radius_of_turn_n_items_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_radius_of_turn_nmbr_of_wypnts_wth_a_spcfc_rdus_of_turn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_radius_of_turn_nmbr_of_wypnts_wth_a_spcfc_rdus_of_turn_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_radius_of_turn_nmbr_of_wypnts_wth_a_spcfc_rdus_of_turn_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_radius_of_turn_database_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_radius_of_turn_database_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_radius_of_turn_database_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_radius_of_turn_route_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_radius_of_turn_route_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_radius_of_turn_route_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_radius_of_turn_rps_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_radius_of_turn_rps_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_radius_of_turn_rps_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_route_and_wp_service_radius_of_turn_radius_of_turn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_radius_of_turn_radius_of_turn_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_radius_of_turn_radius_of_turn_is_in_range(int16_t value);

/**
 * Pack message RouteAndWPServiceDatabaseList.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_route_and_wp_service_database_list_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_route_and_wp_service_database_list_t *src_p,
    size_t size);

/**
 * Unpack message RouteAndWPServiceDatabaseList.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_route_and_wp_service_database_list_unpack(
    struct nmea2000_exxo_route_and_wp_service_database_list_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RouteAndWPServiceDatabaseList.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_route_and_wp_service_database_list_init(struct nmea2000_exxo_route_and_wp_service_database_list_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_database_list_start_database_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_database_list_start_database_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_database_list_start_database_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_database_list_n_items_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_database_list_n_items_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_database_list_n_items_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_database_list_number_of_databases_available_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_database_list_number_of_databases_available_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_database_list_number_of_databases_available_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_database_list_database_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_database_list_database_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_database_list_database_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_database_list_database_name_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_database_list_database_name_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_database_list_database_name_is_in_range(uint16_t value);

/**
 * Pack message RateOfTurn.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_rate_of_turn_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_rate_of_turn_t *src_p,
    size_t size);

/**
 * Unpack message RateOfTurn.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_rate_of_turn_unpack(
    struct nmea2000_exxo_rate_of_turn_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RateOfTurn.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_rate_of_turn_init(struct nmea2000_exxo_rate_of_turn_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_rate_of_turn_sequence_id__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_rate_of_turn_sequence_id__decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_rate_of_turn_sequence_id__is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_rate_of_turn_rate_of_turn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_rate_of_turn_rate_of_turn_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_rate_of_turn_rate_of_turn_is_in_range(int16_t value);

/**
 * Pack message RadioFrequency_Mode_Power.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_radio_frequency_mode_power_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_radio_frequency_mode_power_t *src_p,
    size_t size);

/**
 * Unpack message RadioFrequency_Mode_Power.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_radio_frequency_mode_power_unpack(
    struct nmea2000_exxo_radio_frequency_mode_power_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RadioFrequency_Mode_Power.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_radio_frequency_mode_power_init(struct nmea2000_exxo_radio_frequency_mode_power_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_radio_frequency_mode_power_rx_frequency_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_radio_frequency_mode_power_rx_frequency_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_radio_frequency_mode_power_rx_frequency_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_radio_frequency_mode_power_tx_frequency_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_radio_frequency_mode_power_tx_frequency_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_radio_frequency_mode_power_tx_frequency_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t nmea2000_exxo_radio_frequency_mode_power_radio_channel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_radio_frequency_mode_power_radio_channel_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_radio_frequency_mode_power_radio_channel_is_in_range(uint64_t value);

/**
 * Pack message PsDeltaHighPrecisionRapidUpdate.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_ps_delta_high_precision_rapid_update_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_ps_delta_high_precision_rapid_update_t *src_p,
    size_t size);

/**
 * Unpack message PsDeltaHighPrecisionRapidUpdate.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_ps_delta_high_precision_rapid_update_unpack(
    struct nmea2000_exxo_ps_delta_high_precision_rapid_update_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PsDeltaHighPrecisionRapidUpdate.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_ps_delta_high_precision_rapid_update_init(struct nmea2000_exxo_ps_delta_high_precision_rapid_update_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ps_delta_high_precision_rapid_update_sequence_id__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ps_delta_high_precision_rapid_update_sequence_id__decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ps_delta_high_precision_rapid_update_sequence_id__is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ps_delta_high_precision_rapid_update_time_delta_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ps_delta_high_precision_rapid_update_time_delta_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ps_delta_high_precision_rapid_update_time_delta_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_ps_delta_high_precision_rapid_update_latitude_delta_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ps_delta_high_precision_rapid_update_latitude_delta_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ps_delta_high_precision_rapid_update_latitude_delta_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_ps_delta_high_precision_rapid_update_longitude_delta_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ps_delta_high_precision_rapid_update_longitude_delta_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ps_delta_high_precision_rapid_update_longitude_delta_is_in_range(int32_t value);

/**
 * Pack message PosRapidUpdate.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_pos_rapid_update_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_pos_rapid_update_t *src_p,
    size_t size);

/**
 * Unpack message PosRapidUpdate.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_pos_rapid_update_unpack(
    struct nmea2000_exxo_pos_rapid_update_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PosRapidUpdate.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_pos_rapid_update_init(struct nmea2000_exxo_pos_rapid_update_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_pos_rapid_update_latitude__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_pos_rapid_update_latitude__decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_pos_rapid_update_latitude__is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_pos_rapid_update_longitude__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_pos_rapid_update_longitude__decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_pos_rapid_update_longitude__is_in_range(int32_t value);

/**
 * Pack message NavigationRoute_WPInformation.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_navigation_route_wp_information_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_navigation_route_wp_information_t *src_p,
    size_t size);

/**
 * Unpack message NavigationRoute_WPInformation.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_navigation_route_wp_information_unpack(
    struct nmea2000_exxo_navigation_route_wp_information_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NavigationRoute_WPInformation.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_navigation_route_wp_information_init(struct nmea2000_exxo_navigation_route_wp_information_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_navigation_route_wp_information_start_rps_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_navigation_route_wp_information_start_rps_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_navigation_route_wp_information_start_rps_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_navigation_route_wp_information_n_items_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_navigation_route_wp_information_n_items_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_navigation_route_wp_information_n_items_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_navigation_route_wp_information_database_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_navigation_route_wp_information_database_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_navigation_route_wp_information_database_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_navigation_route_wp_information_route_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_navigation_route_wp_information_route_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_navigation_route_wp_information_route_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_navigation_route_wp_information_navigation_direction_in_route_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_navigation_route_wp_information_navigation_direction_in_route_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_navigation_route_wp_information_navigation_direction_in_route_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_navigation_route_wp_information_spplmntary_route_wp_data_available_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_navigation_route_wp_information_spplmntary_route_wp_data_available_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_navigation_route_wp_information_spplmntary_route_wp_data_available_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_navigation_route_wp_information_route_name_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_navigation_route_wp_information_route_name_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_navigation_route_wp_information_route_name_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_navigation_route_wp_information_wp_name_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_navigation_route_wp_information_wp_name_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_navigation_route_wp_information_wp_name_is_in_range(uint16_t value);

/**
 * Pack message NavigationData.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_navigation_data_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_navigation_data_t *src_p,
    size_t size);

/**
 * Unpack message NavigationData.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_navigation_data_unpack(
    struct nmea2000_exxo_navigation_data_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NavigationData.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_navigation_data_init(struct nmea2000_exxo_navigation_data_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_navigation_data_sid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_navigation_data_sid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_navigation_data_sid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_navigation_data_distance_to_destination_waypoint_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_navigation_data_distance_to_destination_waypoint_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_navigation_data_distance_to_destination_waypoint_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_navigation_data_course_bearing_ref_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_navigation_data_course_bearing_ref_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_navigation_data_course_bearing_ref_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_navigation_data_perpendicular_crossed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_navigation_data_perpendicular_crossed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_navigation_data_perpendicular_crossed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_navigation_data_arrival_circle_entered_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_navigation_data_arrival_circle_entered_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_navigation_data_arrival_circle_entered_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_navigation_data_calculation_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_navigation_data_calculation_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_navigation_data_calculation_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_navigation_data_eta_time_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_navigation_data_eta_time_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_navigation_data_eta_time_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_navigation_data_eta_date_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_navigation_data_eta_date_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_navigation_data_eta_date_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_navigation_data_baringigin_to_destination_waypoint_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_navigation_data_baringigin_to_destination_waypoint_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_navigation_data_baringigin_to_destination_waypoint_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_navigation_data_bearing_pos_to_destination_waypoint_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_navigation_data_bearing_pos_to_destination_waypoint_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_navigation_data_bearing_pos_to_destination_waypoint_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_navigation_data_origin_waypoint_number_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_navigation_data_origin_waypoint_number_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_navigation_data_origin_waypoint_number_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_navigation_data_destination_waypoint_number_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_navigation_data_destination_waypoint_number_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_navigation_data_destination_waypoint_number_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_navigation_data_destination_wpt_latitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_navigation_data_destination_wpt_latitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_navigation_data_destination_wpt_latitude_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_navigation_data_destination_wpt_longitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_navigation_data_destination_wpt_longitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_navigation_data_destination_wpt_longitude_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_navigation_data_waypoint_closing_velocity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_navigation_data_waypoint_closing_velocity_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_navigation_data_waypoint_closing_velocity_is_in_range(int16_t value);

/**
 * Pack message NMEARqGroupFunction.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_nmea_rq_group_function_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_nmea_rq_group_function_t *src_p,
    size_t size);

/**
 * Unpack message NMEARqGroupFunction.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_nmea_rq_group_function_unpack(
    struct nmea2000_exxo_nmea_rq_group_function_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NMEARqGroupFunction.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_nmea_rq_group_function_init(struct nmea2000_exxo_nmea_rq_group_function_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_nmea_rq_group_function_group_function_rq_cmd_acknowledge_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_nmea_rq_group_function_group_function_rq_cmd_acknowledge_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_nmea_rq_group_function_group_function_rq_cmd_acknowledge_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_nmea_rq_group_function_pgn_error_code_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_nmea_rq_group_function_pgn_error_code_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_nmea_rq_group_function_pgn_error_code_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_nmea_rq_group_function_cmded_pgn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_nmea_rq_group_function_cmded_pgn_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_nmea_rq_group_function_cmded_pgn_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_nmea_rq_group_function_rqed_pgn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_nmea_rq_group_function_rqed_pgn_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_nmea_rq_group_function_rqed_pgn_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_nmea_rq_group_function_rqed_cmded_pgn_being_acknowledged_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_nmea_rq_group_function_rqed_cmded_pgn_being_acknowledged_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_nmea_rq_group_function_rqed_cmded_pgn_being_acknowledged_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_nmea_rq_group_function_priority_setting_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_nmea_rq_group_function_priority_setting_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_nmea_rq_group_function_priority_setting_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_nmea_rq_group_function_trans_interval_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_nmea_rq_group_function_trans_interval_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_nmea_rq_group_function_trans_interval_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_nmea_rq_group_function_trans_interval_priority_error_code_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_nmea_rq_group_function_trans_interval_priority_error_code_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_nmea_rq_group_function_trans_interval_priority_error_code_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_nmea_rq_group_function_first_parameter_error_code_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_nmea_rq_group_function_first_parameter_error_code_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_nmea_rq_group_function_first_parameter_error_code_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_nmea_rq_group_function_nmbr_of_prs_of_cmdd_prmeters_to_follow_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_nmea_rq_group_function_nmbr_of_prs_of_cmdd_prmeters_to_follow_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_nmea_rq_group_function_nmbr_of_prs_of_cmdd_prmeters_to_follow_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_nmea_rq_group_function_vrbl_nmbr_of_flds_fld_nmber6_repeated3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_nmea_rq_group_function_vrbl_nmbr_of_flds_fld_nmber6_repeated3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_nmea_rq_group_function_vrbl_nmbr_of_flds_fld_nmber6_repeated3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_nmea_rq_group_function_number_of_rqed_cmded_parameters_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_nmea_rq_group_function_number_of_rqed_cmded_parameters_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_nmea_rq_group_function_number_of_rqed_cmded_parameters_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_nmea_rq_group_function_feld_number_of_first_cmded_parameter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_nmea_rq_group_function_feld_number_of_first_cmded_parameter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_nmea_rq_group_function_feld_number_of_first_cmded_parameter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_nmea_rq_group_function_vrbl_nmbr_of_flds_fld_nmber6_repeated2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_nmea_rq_group_function_vrbl_nmbr_of_flds_fld_nmber6_repeated2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_nmea_rq_group_function_vrbl_nmbr_of_flds_fld_nmber6_repeated2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_nmea_rq_group_function_trans_interval_offset_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_nmea_rq_group_function_trans_interval_offset_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_nmea_rq_group_function_trans_interval_offset_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_nmea_rq_group_function_nmbr_of_prs_of_rq_parameters_to_follow_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_nmea_rq_group_function_nmbr_of_prs_of_rq_parameters_to_follow_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_nmea_rq_group_function_nmbr_of_prs_of_rq_parameters_to_follow_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_nmea_rq_group_function_field_number_of_first_rqed_parameter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_nmea_rq_group_function_field_number_of_first_rqed_parameter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_nmea_rq_group_function_field_number_of_first_rqed_parameter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_nmea_rq_group_function_vrbl_nmbr_of_flds_fld_nmber6_repeated_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_nmea_rq_group_function_vrbl_nmbr_of_flds_fld_nmber6_repeated_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_nmea_rq_group_function_vrbl_nmbr_of_flds_fld_nmber6_repeated_is_in_range(uint8_t value);

/**
 * Pack message MooredBuoyStationData.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_moored_buoy_station_data_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_moored_buoy_station_data_t *src_p,
    size_t size);

/**
 * Unpack message MooredBuoyStationData.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_moored_buoy_station_data_unpack(
    struct nmea2000_exxo_moored_buoy_station_data_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from MooredBuoyStationData.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_moored_buoy_station_data_init(struct nmea2000_exxo_moored_buoy_station_data_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_moored_buoy_station_data_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_moored_buoy_station_data_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_moored_buoy_station_data_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_moored_buoy_station_data_measurement_date_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_moored_buoy_station_data_measurement_date_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_moored_buoy_station_data_measurement_date_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_moored_buoy_station_data_measurement_time_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_moored_buoy_station_data_measurement_time_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_moored_buoy_station_data_measurement_time_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_moored_buoy_station_data_station_location_latitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_moored_buoy_station_data_station_location_latitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_moored_buoy_station_data_station_location_latitude_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_moored_buoy_station_data_station_location_longitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_moored_buoy_station_data_station_location_longitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_moored_buoy_station_data_station_location_longitude_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_moored_buoy_station_data_wind_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_moored_buoy_station_data_wind_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_moored_buoy_station_data_wind_speed_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_moored_buoy_station_data_wind_direction_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_moored_buoy_station_data_wind_direction_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_moored_buoy_station_data_wind_direction_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_moored_buoy_station_data_wind_reference_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_moored_buoy_station_data_wind_reference_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_moored_buoy_station_data_wind_reference_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_moored_buoy_station_data_wind_gusts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_moored_buoy_station_data_wind_gusts_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_moored_buoy_station_data_wind_gusts_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_moored_buoy_station_data_wave_height_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_moored_buoy_station_data_wave_height_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_moored_buoy_station_data_wave_height_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_moored_buoy_station_data_dominate_wave_period_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_moored_buoy_station_data_dominate_wave_period_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_moored_buoy_station_data_dominate_wave_period_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_moored_buoy_station_data_atmospheric_press_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_moored_buoy_station_data_atmospheric_press_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_moored_buoy_station_data_atmospheric_press_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_moored_buoy_station_data_press_tendency_rate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_moored_buoy_station_data_press_tendency_rate_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_moored_buoy_station_data_press_tendency_rate_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_moored_buoy_station_data_air_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_moored_buoy_station_data_air_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_moored_buoy_station_data_air_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_moored_buoy_station_data_water_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_moored_buoy_station_data_water_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_moored_buoy_station_data_water_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_moored_buoy_station_data_station_id_string_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_moored_buoy_station_data_station_id_string_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_moored_buoy_station_data_station_id_string_is_in_range(uint16_t value);

/**
 * Pack message MeteorologicalStationData.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_meteorological_station_data_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_meteorological_station_data_t *src_p,
    size_t size);

/**
 * Unpack message MeteorologicalStationData.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_meteorological_station_data_unpack(
    struct nmea2000_exxo_meteorological_station_data_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from MeteorologicalStationData.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_meteorological_station_data_init(struct nmea2000_exxo_meteorological_station_data_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_meteorological_station_data_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_meteorological_station_data_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_meteorological_station_data_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_meteorological_station_data_measurement_date_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_meteorological_station_data_measurement_date_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_meteorological_station_data_measurement_date_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_meteorological_station_data_measurement_time_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_meteorological_station_data_measurement_time_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_meteorological_station_data_measurement_time_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_meteorological_station_data_station_location_latitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_meteorological_station_data_station_location_latitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_meteorological_station_data_station_location_latitude_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_meteorological_station_data_station_location_longitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_meteorological_station_data_station_location_longitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_meteorological_station_data_station_location_longitude_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_meteorological_station_data_wind_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_meteorological_station_data_wind_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_meteorological_station_data_wind_speed_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_meteorological_station_data_wind_direction_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_meteorological_station_data_wind_direction_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_meteorological_station_data_wind_direction_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_meteorological_station_data_wind_reference_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_meteorological_station_data_wind_reference_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_meteorological_station_data_wind_reference_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_meteorological_station_data_wind_gusts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_meteorological_station_data_wind_gusts_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_meteorological_station_data_wind_gusts_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_meteorological_station_data_atmospheric_press_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_meteorological_station_data_atmospheric_press_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_meteorological_station_data_atmospheric_press_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_meteorological_station_data_air_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_meteorological_station_data_air_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_meteorological_station_data_air_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_meteorological_station_data_station_id_string_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_meteorological_station_data_station_id_string_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_meteorological_station_data_station_id_string_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_meteorological_station_data_station_name_string_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_meteorological_station_data_station_name_string_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_meteorological_station_data_station_name_string_is_in_range(uint16_t value);

/**
 * Pack message MagneticVariation.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_magnetic_variation_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_magnetic_variation_t *src_p,
    size_t size);

/**
 * Unpack message MagneticVariation.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_magnetic_variation_unpack(
    struct nmea2000_exxo_magnetic_variation_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from MagneticVariation.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_magnetic_variation_init(struct nmea2000_exxo_magnetic_variation_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_magnetic_variation_sequence_id__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_magnetic_variation_sequence_id__decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_magnetic_variation_sequence_id__is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_magnetic_variation_variation_source_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_magnetic_variation_variation_source_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_magnetic_variation_variation_source_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_magnetic_variation_age_of_service_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_magnetic_variation_age_of_service_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_magnetic_variation_age_of_service_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_magnetic_variation_variation_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_magnetic_variation_variation_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_magnetic_variation_variation_is_in_range(int16_t value);

/**
 * Pack message LoranCTDData.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_loran_ctd_data_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_loran_ctd_data_t *src_p,
    size_t size);

/**
 * Unpack message LoranCTDData.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_loran_ctd_data_unpack(
    struct nmea2000_exxo_loran_ctd_data_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from LoranCTDData.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_loran_ctd_data_init(struct nmea2000_exxo_loran_ctd_data_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_loran_ctd_data_group_repetition_interval_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_loran_ctd_data_group_repetition_interval_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_loran_ctd_data_group_repetition_interval_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_loran_ctd_data_master_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_loran_ctd_data_master_range_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_loran_ctd_data_master_range_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_loran_ctd_data_v_second_td_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_loran_ctd_data_v_second_td_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_loran_ctd_data_v_second_td_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_loran_ctd_data_w_second_td_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_loran_ctd_data_w_second_td_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_loran_ctd_data_w_second_td_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_loran_ctd_data_x_second_td_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_loran_ctd_data_x_second_td_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_loran_ctd_data_x_second_td_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_loran_ctd_data_y_second_td_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_loran_ctd_data_y_second_td_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_loran_ctd_data_y_second_td_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_loran_ctd_data_z_second_td_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_loran_ctd_data_z_second_td_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_loran_ctd_data_z_second_td_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_loran_ctd_data_station_status_master_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_loran_ctd_data_station_status_master_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_loran_ctd_data_station_status_master_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_loran_ctd_data_station_status_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_loran_ctd_data_station_status_v_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_loran_ctd_data_station_status_v_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_loran_ctd_data_station_status_w_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_loran_ctd_data_station_status_w_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_loran_ctd_data_station_status_w_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_loran_ctd_data_station_status_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_loran_ctd_data_station_status_x_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_loran_ctd_data_station_status_x_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_loran_ctd_data_station_status_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_loran_ctd_data_station_status_y_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_loran_ctd_data_station_status_y_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_loran_ctd_data_station_status_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_loran_ctd_data_station_status_z_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_loran_ctd_data_station_status_z_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_loran_ctd_data_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_loran_ctd_data_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_loran_ctd_data_mode_is_in_range(uint8_t value);

/**
 * Pack message LoranCSignalData.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_loran_c_signal_data_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_loran_c_signal_data_t *src_p,
    size_t size);

/**
 * Unpack message LoranCSignalData.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_loran_c_signal_data_unpack(
    struct nmea2000_exxo_loran_c_signal_data_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from LoranCSignalData.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_loran_c_signal_data_init(struct nmea2000_exxo_loran_c_signal_data_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_loran_c_signal_data_group_repetition_interval_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_loran_c_signal_data_group_repetition_interval_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_loran_c_signal_data_group_repetition_interval_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_loran_c_signal_data_station_identifier_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_loran_c_signal_data_station_identifier_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_loran_c_signal_data_station_identifier_is_in_range(uint8_t value);

/**
 * Pack message LoranCRangeData.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_loran_c_range_data_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_loran_c_range_data_t *src_p,
    size_t size);

/**
 * Unpack message LoranCRangeData.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_loran_c_range_data_unpack(
    struct nmea2000_exxo_loran_c_range_data_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from LoranCRangeData.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_loran_c_range_data_init(struct nmea2000_exxo_loran_c_range_data_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_loran_c_range_data_group_repetition_interval_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_loran_c_range_data_group_repetition_interval_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_loran_c_range_data_group_repetition_interval_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_loran_c_range_data_master_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_loran_c_range_data_master_range_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_loran_c_range_data_master_range_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_loran_c_range_data_v_second_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_loran_c_range_data_v_second_range_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_loran_c_range_data_v_second_range_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_loran_c_range_data_w_second_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_loran_c_range_data_w_second_range_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_loran_c_range_data_w_second_range_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_loran_c_range_data_x_second_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_loran_c_range_data_x_second_range_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_loran_c_range_data_x_second_range_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_loran_c_range_data_y_second_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_loran_c_range_data_y_second_range_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_loran_c_range_data_y_second_range_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_loran_c_range_data_z_second_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_loran_c_range_data_z_second_range_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_loran_c_range_data_z_second_range_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_loran_c_range_data_station_status_master_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_loran_c_range_data_station_status_master_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_loran_c_range_data_station_status_master_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_loran_c_range_data_station_status_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_loran_c_range_data_station_status_v_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_loran_c_range_data_station_status_v_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_loran_c_range_data_station_status_w_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_loran_c_range_data_station_status_w_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_loran_c_range_data_station_status_w_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_loran_c_range_data_station_status_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_loran_c_range_data_station_status_x_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_loran_c_range_data_station_status_x_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_loran_c_range_data_station_status_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_loran_c_range_data_station_status_y_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_loran_c_range_data_station_status_y_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_loran_c_range_data_station_status_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_loran_c_range_data_station_status_z_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_loran_c_range_data_station_status_z_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_loran_c_range_data_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_loran_c_range_data_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_loran_c_range_data_mode_is_in_range(uint8_t value);

/**
 * Pack message Heading_TrackCtrl.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_heading_track_ctrl_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_heading_track_ctrl_t *src_p,
    size_t size);

/**
 * Unpack message Heading_TrackCtrl.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_heading_track_ctrl_unpack(
    struct nmea2000_exxo_heading_track_ctrl_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Heading_TrackCtrl.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_heading_track_ctrl_init(struct nmea2000_exxo_heading_track_ctrl_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_heading_track_ctrl_rudder_limit_exceeded_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_heading_track_ctrl_rudder_limit_exceeded_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_heading_track_ctrl_rudder_limit_exceeded_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_heading_track_ctrl_off_heading_limit_exceeded_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_heading_track_ctrl_off_heading_limit_exceeded_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_heading_track_ctrl_off_heading_limit_exceeded_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_heading_track_ctrl_off_track_limit_exceeded_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_heading_track_ctrl_off_track_limit_exceeded_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_heading_track_ctrl_off_track_limit_exceeded_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_heading_track_ctrl_override_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_heading_track_ctrl_override_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_heading_track_ctrl_override_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_heading_track_ctrl_steer_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_heading_track_ctrl_steer_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_heading_track_ctrl_steer_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_heading_track_ctrl_turn_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_heading_track_ctrl_turn_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_heading_track_ctrl_turn_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_heading_track_ctrl_heading_reference_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_heading_track_ctrl_heading_reference_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_heading_track_ctrl_heading_reference_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_heading_track_ctrl_cmded_rudder_direction_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_heading_track_ctrl_cmded_rudder_direction_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_heading_track_ctrl_cmded_rudder_direction_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_heading_track_ctrl_cmded_rudder_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_heading_track_ctrl_cmded_rudder_angle_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_heading_track_ctrl_cmded_rudder_angle_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_heading_track_ctrl_heading_to_steer_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_heading_track_ctrl_heading_to_steer_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_heading_track_ctrl_heading_to_steer_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_heading_track_ctrl_track_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_heading_track_ctrl_track_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_heading_track_ctrl_track_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_heading_track_ctrl_rudder_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_heading_track_ctrl_rudder_limit_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_heading_track_ctrl_rudder_limit_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_heading_track_ctrl_off_heading_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_heading_track_ctrl_off_heading_limit_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_heading_track_ctrl_off_heading_limit_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_heading_track_ctrl_radius_of_turnder_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_heading_track_ctrl_radius_of_turnder_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_heading_track_ctrl_radius_of_turnder_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_heading_track_ctrl_rate_of_turnder_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_heading_track_ctrl_rate_of_turnder_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_heading_track_ctrl_rate_of_turnder_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_heading_track_ctrl_off_track_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_heading_track_ctrl_off_track_limit_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_heading_track_ctrl_off_track_limit_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_heading_track_ctrl_vessel_heading_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_heading_track_ctrl_vessel_heading_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_heading_track_ctrl_vessel_heading_is_in_range(uint16_t value);

/**
 * Pack message GPSAlmanacData.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_gps_almanac_data_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_gps_almanac_data_t *src_p,
    size_t size);

/**
 * Unpack message GPSAlmanacData.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_gps_almanac_data_unpack(
    struct nmea2000_exxo_gps_almanac_data_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from GPSAlmanacData.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_gps_almanac_data_init(struct nmea2000_exxo_gps_almanac_data_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gps_almanac_data_prn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gps_almanac_data_prn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gps_almanac_data_prn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gps_almanac_data_gps_week_number_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gps_almanac_data_gps_week_number_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gps_almanac_data_gps_week_number_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gps_almanac_data_sv_health_bits_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gps_almanac_data_sv_health_bits_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gps_almanac_data_sv_health_bits_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gps_almanac_data_eccentricity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gps_almanac_data_eccentricity_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gps_almanac_data_eccentricity_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gps_almanac_data_almanac_reference_time_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gps_almanac_data_almanac_reference_time_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gps_almanac_data_almanac_reference_time_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gps_almanac_data_inclination_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gps_almanac_data_inclination_angle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gps_almanac_data_inclination_angle_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gps_almanac_data_rate_of_right_ascension_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gps_almanac_data_rate_of_right_ascension_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gps_almanac_data_rate_of_right_ascension_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_gps_almanac_data_root_of_semimajor_axis_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gps_almanac_data_root_of_semimajor_axis_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gps_almanac_data_root_of_semimajor_axis_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_gps_almanac_data_argument_of_perigee_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gps_almanac_data_argument_of_perigee_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gps_almanac_data_argument_of_perigee_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_gps_almanac_data_longitude_of_ascension_node_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gps_almanac_data_longitude_of_ascension_node_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gps_almanac_data_longitude_of_ascension_node_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_gps_almanac_data_mean_anomaly_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gps_almanac_data_mean_anomaly_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gps_almanac_data_mean_anomaly_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gps_almanac_data_clock_parameter1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gps_almanac_data_clock_parameter1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gps_almanac_data_clock_parameter1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gps_almanac_data_clock_parameter2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gps_almanac_data_clock_parameter2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gps_almanac_data_clock_parameter2_is_in_range(uint16_t value);

/**
 * Pack message GNSSSatsInView.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_gnss_sats_in_view_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_gnss_sats_in_view_t *src_p,
    size_t size);

/**
 * Unpack message GNSSSatsInView.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_gnss_sats_in_view_unpack(
    struct nmea2000_exxo_gnss_sats_in_view_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from GNSSSatsInView.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_gnss_sats_in_view_init(struct nmea2000_exxo_gnss_sats_in_view_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_sats_in_view_sid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_sats_in_view_sid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_sats_in_view_sid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t nmea2000_exxo_gnss_sats_in_view_range_residual_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_sats_in_view_range_residual_mode_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_sats_in_view_range_residual_mode_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_sats_in_view_number_of_s_vs__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_sats_in_view_number_of_s_vs__decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_sats_in_view_number_of_s_vs__is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_sats_in_view_prn1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_sats_in_view_prn1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_sats_in_view_prn1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_gnss_sats_in_view_elevation1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_sats_in_view_elevation1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_sats_in_view_elevation1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gnss_sats_in_view_azimuth1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_sats_in_view_azimuth1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_sats_in_view_azimuth1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_gnss_sats_in_view_snr1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_sats_in_view_snr1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_sats_in_view_snr1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_gnss_sats_in_view_range_residuals1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_sats_in_view_range_residuals1_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_sats_in_view_range_residuals1_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_sats_in_view_prn_status1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_sats_in_view_prn_status1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_sats_in_view_prn_status1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_sats_in_view_prnn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_sats_in_view_prnn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_sats_in_view_prnn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_gnss_sats_in_view_elevation_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_sats_in_view_elevation_n_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_sats_in_view_elevation_n_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gnss_sats_in_view_azimuth_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_sats_in_view_azimuth_n_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_sats_in_view_azimuth_n_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_gnss_sats_in_view_snrn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_sats_in_view_snrn_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_sats_in_view_snrn_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_gnss_sats_in_view_range_residuals_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_sats_in_view_range_residuals_n_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_sats_in_view_range_residuals_n_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_sats_in_view_prn_status_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_sats_in_view_prn_status_n_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_sats_in_view_prn_status_n_is_in_range(uint8_t value);

/**
 * Pack message GNSSRAIMSettings.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_gnssraim_settings_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_gnssraim_settings_t *src_p,
    size_t size);

/**
 * Unpack message GNSSRAIMSettings.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_gnssraim_settings_unpack(
    struct nmea2000_exxo_gnssraim_settings_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from GNSSRAIMSettings.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_gnssraim_settings_init(struct nmea2000_exxo_gnssraim_settings_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gnssraim_settings_radial_pos_error_max_threshold_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnssraim_settings_radial_pos_error_max_threshold_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnssraim_settings_radial_pos_error_max_threshold_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t nmea2000_exxo_gnssraim_settings_probability_of_false_alarm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnssraim_settings_probability_of_false_alarm_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnssraim_settings_probability_of_false_alarm_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t nmea2000_exxo_gnssraim_settings_probability_of_missed_detection_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnssraim_settings_probability_of_missed_detection_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnssraim_settings_probability_of_missed_detection_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gnssraim_settings_psdrng_rsdl_filtering_time_constant_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnssraim_settings_psdrng_rsdl_filtering_time_constant_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnssraim_settings_psdrng_rsdl_filtering_time_constant_is_in_range(uint16_t value);

/**
 * Pack message BringAndDistanceBetweenTwoMarks.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_bring_and_distance_between_two_marks_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_bring_and_distance_between_two_marks_t *src_p,
    size_t size);

/**
 * Unpack message BringAndDistanceBetweenTwoMarks.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_bring_and_distance_between_two_marks_unpack(
    struct nmea2000_exxo_bring_and_distance_between_two_marks_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BringAndDistanceBetweenTwoMarks.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_bring_and_distance_between_two_marks_init(struct nmea2000_exxo_bring_and_distance_between_two_marks_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_bring_and_distance_between_two_marks_sid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_bring_and_distance_between_two_marks_sid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_bring_and_distance_between_two_marks_sid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_bring_and_distance_between_two_marks_bearing_ref_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_bring_and_distance_between_two_marks_bearing_ref_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_bring_and_distance_between_two_marks_bearing_ref_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_bring_and_distance_between_two_marks_calculation_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_bring_and_distance_between_two_marks_calculation_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_bring_and_distance_between_two_marks_calculation_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_bring_and_distance_between_two_marks_bearingigin_to_destination_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_bring_and_distance_between_two_marks_bearingigin_to_destination_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_bring_and_distance_between_two_marks_bearingigin_to_destination_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_bring_and_distance_between_two_marks_distance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_bring_and_distance_between_two_marks_distance_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_bring_and_distance_between_two_marks_distance_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_bring_and_distance_between_two_marks_origin_mark_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_bring_and_distance_between_two_marks_origin_mark_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_bring_and_distance_between_two_marks_origin_mark_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_bring_and_distance_between_two_marks_destination_mark_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_bring_and_distance_between_two_marks_destination_mark_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_bring_and_distance_between_two_marks_destination_mark_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_bring_and_distance_between_two_marks_origin_mark_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_bring_and_distance_between_two_marks_origin_mark_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_bring_and_distance_between_two_marks_origin_mark_id_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_bring_and_distance_between_two_marks_destination_mark_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_bring_and_distance_between_two_marks_destination_mark_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_bring_and_distance_between_two_marks_destination_mark_id_is_in_range(uint32_t value);

/**
 * Pack message BinarySwitchBankStatus.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_binary_switch_bank_status_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_binary_switch_bank_status_t *src_p,
    size_t size);

/**
 * Unpack message BinarySwitchBankStatus.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_binary_switch_bank_status_unpack(
    struct nmea2000_exxo_binary_switch_bank_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BinarySwitchBankStatus.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_binary_switch_bank_status_init(struct nmea2000_exxo_binary_switch_bank_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_binary_switch_bank_status_indicator_bank_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_binary_switch_bank_status_indicator_bank_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_binary_switch_bank_status_indicator_bank_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_binary_switch_bank_status_indic1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_binary_switch_bank_status_indic1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_binary_switch_bank_status_indic1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_binary_switch_bank_status_indic2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_binary_switch_bank_status_indic2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_binary_switch_bank_status_indic2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_binary_switch_bank_status_indic3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_binary_switch_bank_status_indic3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_binary_switch_bank_status_indic3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_binary_switch_bank_status_indic4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_binary_switch_bank_status_indic4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_binary_switch_bank_status_indic4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_binary_switch_bank_status_indic5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_binary_switch_bank_status_indic5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_binary_switch_bank_status_indic5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_binary_switch_bank_status_indic6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_binary_switch_bank_status_indic6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_binary_switch_bank_status_indic6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_binary_switch_bank_status_indic7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_binary_switch_bank_status_indic7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_binary_switch_bank_status_indic7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_binary_switch_bank_status_indic8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_binary_switch_bank_status_indic8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_binary_switch_bank_status_indic8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_binary_switch_bank_status_indic9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_binary_switch_bank_status_indic9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_binary_switch_bank_status_indic9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_binary_switch_bank_status_indic10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_binary_switch_bank_status_indic10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_binary_switch_bank_status_indic10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_binary_switch_bank_status_indic11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_binary_switch_bank_status_indic11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_binary_switch_bank_status_indic11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_binary_switch_bank_status_indic12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_binary_switch_bank_status_indic12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_binary_switch_bank_status_indic12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_binary_switch_bank_status_indic13_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_binary_switch_bank_status_indic13_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_binary_switch_bank_status_indic13_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_binary_switch_bank_status_indic14_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_binary_switch_bank_status_indic14_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_binary_switch_bank_status_indic14_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_binary_switch_bank_status_indic15_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_binary_switch_bank_status_indic15_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_binary_switch_bank_status_indic15_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_binary_switch_bank_status_indic16_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_binary_switch_bank_status_indic16_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_binary_switch_bank_status_indic16_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_binary_switch_bank_status_indic17_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_binary_switch_bank_status_indic17_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_binary_switch_bank_status_indic17_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_binary_switch_bank_status_indic18_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_binary_switch_bank_status_indic18_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_binary_switch_bank_status_indic18_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_binary_switch_bank_status_indic19_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_binary_switch_bank_status_indic19_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_binary_switch_bank_status_indic19_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_binary_switch_bank_status_indic20_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_binary_switch_bank_status_indic20_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_binary_switch_bank_status_indic20_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_binary_switch_bank_status_indic21_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_binary_switch_bank_status_indic21_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_binary_switch_bank_status_indic21_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_binary_switch_bank_status_indic22_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_binary_switch_bank_status_indic22_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_binary_switch_bank_status_indic22_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_binary_switch_bank_status_indic23_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_binary_switch_bank_status_indic23_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_binary_switch_bank_status_indic23_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_binary_switch_bank_status_indic24_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_binary_switch_bank_status_indic24_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_binary_switch_bank_status_indic24_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_binary_switch_bank_status_indic25_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_binary_switch_bank_status_indic25_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_binary_switch_bank_status_indic25_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_binary_switch_bank_status_indic26_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_binary_switch_bank_status_indic26_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_binary_switch_bank_status_indic26_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_binary_switch_bank_status_indic27_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_binary_switch_bank_status_indic27_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_binary_switch_bank_status_indic27_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_binary_switch_bank_status_indic28_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_binary_switch_bank_status_indic28_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_binary_switch_bank_status_indic28_is_in_range(uint8_t value);

/**
 * Pack message BatteryStatus.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_battery_status_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_battery_status_t *src_p,
    size_t size);

/**
 * Unpack message BatteryStatus.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_battery_status_unpack(
    struct nmea2000_exxo_battery_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BatteryStatus.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_battery_status_init(struct nmea2000_exxo_battery_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_battery_status_battery_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_battery_status_battery_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_battery_status_battery_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_battery_status_battery_potential_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_battery_status_battery_potential_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_battery_status_battery_potential_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_battery_status_battery_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_battery_status_battery_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_battery_status_battery_current_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_battery_status_battery_case_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_battery_status_battery_case_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_battery_status_battery_case_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_battery_status_sid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_battery_status_sid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_battery_status_sid_is_in_range(uint8_t value);

/**
 * Pack message Attitude.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_attitude_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_attitude_t *src_p,
    size_t size);

/**
 * Unpack message Attitude.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_attitude_unpack(
    struct nmea2000_exxo_attitude_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Attitude.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_attitude_init(struct nmea2000_exxo_attitude_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_attitude_sid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_attitude_sid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_attitude_sid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_attitude_yaw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_attitude_yaw_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_attitude_yaw_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_attitude_pitch__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_attitude_pitch__decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_attitude_pitch__is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_attitude_roll_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_attitude_roll_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_attitude_roll_is_in_range(int16_t value);

/**
 * Pack message AlttdDltHghPrecisionRapidUpdate.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_alttd_dlt_hgh_precision_rapid_update_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_alttd_dlt_hgh_precision_rapid_update_t *src_p,
    size_t size);

/**
 * Unpack message AlttdDltHghPrecisionRapidUpdate.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_alttd_dlt_hgh_precision_rapid_update_unpack(
    struct nmea2000_exxo_alttd_dlt_hgh_precision_rapid_update_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AlttdDltHghPrecisionRapidUpdate.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_alttd_dlt_hgh_precision_rapid_update_init(struct nmea2000_exxo_alttd_dlt_hgh_precision_rapid_update_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_alttd_dlt_hgh_precision_rapid_update_sequence_id__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_alttd_dlt_hgh_precision_rapid_update_sequence_id__decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_alttd_dlt_hgh_precision_rapid_update_sequence_id__is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_alttd_dlt_hgh_precision_rapid_update_time_delta_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_alttd_dlt_hgh_precision_rapid_update_time_delta_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_alttd_dlt_hgh_precision_rapid_update_time_delta_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_alttd_dlt_hgh_precision_rapid_update_gnss_quality_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_alttd_dlt_hgh_precision_rapid_update_gnss_quality_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_alttd_dlt_hgh_precision_rapid_update_gnss_quality_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_alttd_dlt_hgh_precision_rapid_update_direction_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_alttd_dlt_hgh_precision_rapid_update_direction_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_alttd_dlt_hgh_precision_rapid_update_direction_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_alttd_dlt_hgh_precision_rapid_update_course_over_ground_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_alttd_dlt_hgh_precision_rapid_update_course_over_ground_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_alttd_dlt_hgh_precision_rapid_update_course_over_ground_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_alttd_dlt_hgh_precision_rapid_update_altitude_delta_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_alttd_dlt_hgh_precision_rapid_update_altitude_delta_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_alttd_dlt_hgh_precision_rapid_update_altitude_delta_is_in_range(int32_t value);

/**
 * Pack message AISUTC_DateInquiry.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_aisutc_date_inquiry_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_aisutc_date_inquiry_t *src_p,
    size_t size);

/**
 * Unpack message AISUTC_DateInquiry.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_aisutc_date_inquiry_unpack(
    struct nmea2000_exxo_aisutc_date_inquiry_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AISUTC_DateInquiry.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_aisutc_date_inquiry_init(struct nmea2000_exxo_aisutc_date_inquiry_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_aisutc_date_inquiry_msg_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aisutc_date_inquiry_msg_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aisutc_date_inquiry_msg_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_aisutc_date_inquiry_repeat_indicator_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aisutc_date_inquiry_repeat_indicator_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aisutc_date_inquiry_repeat_indicator_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_aisutc_date_inquiry_source_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aisutc_date_inquiry_source_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aisutc_date_inquiry_source_id_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_aisutc_date_inquiry_ais_transceiver_information_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aisutc_date_inquiry_ais_transceiver_information_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aisutc_date_inquiry_ais_transceiver_information_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_aisutc_date_inquiry_destination_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aisutc_date_inquiry_destination_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aisutc_date_inquiry_destination_id_is_in_range(uint32_t value);

/**
 * Pack message AISUTCAndDateReport.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_aisutc_and_date_report_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_aisutc_and_date_report_t *src_p,
    size_t size);

/**
 * Unpack message AISUTCAndDateReport.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_aisutc_and_date_report_unpack(
    struct nmea2000_exxo_aisutc_and_date_report_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AISUTCAndDateReport.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_aisutc_and_date_report_init(struct nmea2000_exxo_aisutc_and_date_report_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_aisutc_and_date_report_msg_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aisutc_and_date_report_msg_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aisutc_and_date_report_msg_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_aisutc_and_date_report_repeat_indicator_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aisutc_and_date_report_repeat_indicator_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aisutc_and_date_report_repeat_indicator_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_aisutc_and_date_report_user_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aisutc_and_date_report_user_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aisutc_and_date_report_user_id_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_aisutc_and_date_report_longitude__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aisutc_and_date_report_longitude__decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aisutc_and_date_report_longitude__is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_aisutc_and_date_report_latitude__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aisutc_and_date_report_latitude__decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aisutc_and_date_report_latitude__is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_aisutc_and_date_report_pos_accuracy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aisutc_and_date_report_pos_accuracy_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aisutc_and_date_report_pos_accuracy_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_aisutc_and_date_report_rai_mflag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aisutc_and_date_report_rai_mflag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aisutc_and_date_report_rai_mflag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_aisutc_and_date_report_pos_time_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aisutc_and_date_report_pos_time_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aisutc_and_date_report_pos_time_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_aisutc_and_date_report_communication_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aisutc_and_date_report_communication_state_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aisutc_and_date_report_communication_state_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_aisutc_and_date_report_ais_transceiver_information_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aisutc_and_date_report_ais_transceiver_information_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aisutc_and_date_report_ais_transceiver_information_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_aisutc_and_date_report_pos_date_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aisutc_and_date_report_pos_date_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aisutc_and_date_report_pos_date_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_aisutc_and_date_report_type_of_electronic_posing_device_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aisutc_and_date_report_type_of_electronic_posing_device_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aisutc_and_date_report_type_of_electronic_posing_device_is_in_range(uint8_t value);

/**
 * Pack message AISSafetyRelatedBroadcastMsg.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_ais_safety_related_broadcast_msg_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_ais_safety_related_broadcast_msg_t *src_p,
    size_t size);

/**
 * Unpack message AISSafetyRelatedBroadcastMsg.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_ais_safety_related_broadcast_msg_unpack(
    struct nmea2000_exxo_ais_safety_related_broadcast_msg_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AISSafetyRelatedBroadcastMsg.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_ais_safety_related_broadcast_msg_init(struct nmea2000_exxo_ais_safety_related_broadcast_msg_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_safety_related_broadcast_msg_msg_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_safety_related_broadcast_msg_msg_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_safety_related_broadcast_msg_msg_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_safety_related_broadcast_msg_repeat_indicator_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_safety_related_broadcast_msg_repeat_indicator_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_safety_related_broadcast_msg_repeat_indicator_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ais_safety_related_broadcast_msg_source_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_safety_related_broadcast_msg_source_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_safety_related_broadcast_msg_source_id_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_safety_related_broadcast_msg_ais_transceiver_information_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_safety_related_broadcast_msg_ais_transceiver_information_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_safety_related_broadcast_msg_ais_transceiver_information_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_safety_related_broadcast_msg_safety_related_text_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_safety_related_broadcast_msg_safety_related_text_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_safety_related_broadcast_msg_safety_related_text_is_in_range(uint16_t value);

/**
 * Pack message AISSARAircraftPosReport.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_aissar_aircraft_pos_report_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_aissar_aircraft_pos_report_t *src_p,
    size_t size);

/**
 * Unpack message AISSARAircraftPosReport.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_aissar_aircraft_pos_report_unpack(
    struct nmea2000_exxo_aissar_aircraft_pos_report_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AISSARAircraftPosReport.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_aissar_aircraft_pos_report_init(struct nmea2000_exxo_aissar_aircraft_pos_report_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_aissar_aircraft_pos_report_msg_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aissar_aircraft_pos_report_msg_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aissar_aircraft_pos_report_msg_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_aissar_aircraft_pos_report_repeat_indicator_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aissar_aircraft_pos_report_repeat_indicator_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aissar_aircraft_pos_report_repeat_indicator_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_aissar_aircraft_pos_report_user_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aissar_aircraft_pos_report_user_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aissar_aircraft_pos_report_user_id_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_aissar_aircraft_pos_report_longitude__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aissar_aircraft_pos_report_longitude__decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aissar_aircraft_pos_report_longitude__is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_aissar_aircraft_pos_report_latitude__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aissar_aircraft_pos_report_latitude__decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aissar_aircraft_pos_report_latitude__is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_aissar_aircraft_pos_report_pos_accuracy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aissar_aircraft_pos_report_pos_accuracy_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aissar_aircraft_pos_report_pos_accuracy_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_aissar_aircraft_pos_report_raim_flag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aissar_aircraft_pos_report_raim_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aissar_aircraft_pos_report_raim_flag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_aissar_aircraft_pos_report_time_stamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aissar_aircraft_pos_report_time_stamp_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aissar_aircraft_pos_report_time_stamp_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_aissar_aircraft_pos_report_cog_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aissar_aircraft_pos_report_cog_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aissar_aircraft_pos_report_cog_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_aissar_aircraft_pos_report_sog_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aissar_aircraft_pos_report_sog_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aissar_aircraft_pos_report_sog_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_aissar_aircraft_pos_report_communication_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aissar_aircraft_pos_report_communication_state_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aissar_aircraft_pos_report_communication_state_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_aissar_aircraft_pos_report_ais_transceiver_information_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aissar_aircraft_pos_report_ais_transceiver_information_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aissar_aircraft_pos_report_ais_transceiver_information_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_aissar_aircraft_pos_report_altitude__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aissar_aircraft_pos_report_altitude__decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aissar_aircraft_pos_report_altitude__is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_aissar_aircraft_pos_report_data_terminal_equipment_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aissar_aircraft_pos_report_data_terminal_equipment_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aissar_aircraft_pos_report_data_terminal_equipment_is_in_range(uint8_t value);

/**
 * Pack message AISInterrogation.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_ais_interrogation_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_ais_interrogation_t *src_p,
    size_t size);

/**
 * Unpack message AISInterrogation.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_ais_interrogation_unpack(
    struct nmea2000_exxo_ais_interrogation_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AISInterrogation.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_ais_interrogation_init(struct nmea2000_exxo_ais_interrogation_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_interrogation_msg_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_interrogation_msg_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_interrogation_msg_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_interrogation_repeat_indicator_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_interrogation_repeat_indicator_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_interrogation_repeat_indicator_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ais_interrogation_source_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_interrogation_source_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_interrogation_source_id_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_interrogation_ais_transceiver_information_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_interrogation_ais_transceiver_information_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_interrogation_ais_transceiver_information_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ais_interrogation_destination_id1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_interrogation_destination_id1_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_interrogation_destination_id1_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_interrogation_msg_id11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_interrogation_msg_id11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_interrogation_msg_id11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_interrogation_slot_offset11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_interrogation_slot_offset11_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_interrogation_slot_offset11_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_interrogation_msg_id12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_interrogation_msg_id12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_interrogation_msg_id12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_interrogation_slot_offset12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_interrogation_slot_offset12_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_interrogation_slot_offset12_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ais_interrogation_destination_id2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_interrogation_destination_id2_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_interrogation_destination_id2_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_interrogation_msg_id21_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_interrogation_msg_id21_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_interrogation_msg_id21_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_interrogation_slot_offset21_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_interrogation_slot_offset21_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_interrogation_slot_offset21_is_in_range(uint16_t value);

/**
 * Pack message AISDataLinkManagementMsg.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_ais_data_link_management_msg_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_ais_data_link_management_msg_t *src_p,
    size_t size);

/**
 * Unpack message AISDataLinkManagementMsg.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_ais_data_link_management_msg_unpack(
    struct nmea2000_exxo_ais_data_link_management_msg_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AISDataLinkManagementMsg.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_ais_data_link_management_msg_init(struct nmea2000_exxo_ais_data_link_management_msg_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_data_link_management_msg_msg_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_data_link_management_msg_msg_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_data_link_management_msg_msg_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_data_link_management_msg_repeat_indicator_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_data_link_management_msg_repeat_indicator_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_data_link_management_msg_repeat_indicator_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ais_data_link_management_msg_source_station_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_data_link_management_msg_source_station_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_data_link_management_msg_source_station_id_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_data_link_management_msg_ais_transceiver_information_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_data_link_management_msg_ais_transceiver_information_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_data_link_management_msg_ais_transceiver_information_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_data_link_management_msg_offset_number1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_data_link_management_msg_offset_number1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_data_link_management_msg_offset_number1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_data_link_management_msg_number_of_slots1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_data_link_management_msg_number_of_slots1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_data_link_management_msg_number_of_slots1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_data_link_management_msg_time_out1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_data_link_management_msg_time_out1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_data_link_management_msg_time_out1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_data_link_management_msg_increment1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_data_link_management_msg_increment1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_data_link_management_msg_increment1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_data_link_management_msg_offset_number2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_data_link_management_msg_offset_number2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_data_link_management_msg_offset_number2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_data_link_management_msg_number_of_slots2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_data_link_management_msg_number_of_slots2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_data_link_management_msg_number_of_slots2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_data_link_management_msg_time_out2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_data_link_management_msg_time_out2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_data_link_management_msg_time_out2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_data_link_management_msg_increment2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_data_link_management_msg_increment2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_data_link_management_msg_increment2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_data_link_management_msg_offset_number3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_data_link_management_msg_offset_number3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_data_link_management_msg_offset_number3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_data_link_management_msg_number_of_slots3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_data_link_management_msg_number_of_slots3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_data_link_management_msg_number_of_slots3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_data_link_management_msg_time_out3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_data_link_management_msg_time_out3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_data_link_management_msg_time_out3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_data_link_management_msg_increment3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_data_link_management_msg_increment3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_data_link_management_msg_increment3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_data_link_management_msg_offset_number4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_data_link_management_msg_offset_number4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_data_link_management_msg_offset_number4_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_data_link_management_msg_number_of_slots4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_data_link_management_msg_number_of_slots4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_data_link_management_msg_number_of_slots4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_data_link_management_msg_time_out4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_data_link_management_msg_time_out4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_data_link_management_msg_time_out4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_data_link_management_msg_increment4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_data_link_management_msg_increment4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_data_link_management_msg_increment4_is_in_range(uint16_t value);

/**
 * Pack message AISDGNSSBroadcastBinaryMsg.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_aisdgnss_broadcast_binary_msg_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_aisdgnss_broadcast_binary_msg_t *src_p,
    size_t size);

/**
 * Unpack message AISDGNSSBroadcastBinaryMsg.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_aisdgnss_broadcast_binary_msg_unpack(
    struct nmea2000_exxo_aisdgnss_broadcast_binary_msg_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AISDGNSSBroadcastBinaryMsg.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_aisdgnss_broadcast_binary_msg_init(struct nmea2000_exxo_aisdgnss_broadcast_binary_msg_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_aisdgnss_broadcast_binary_msg_msg_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aisdgnss_broadcast_binary_msg_msg_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aisdgnss_broadcast_binary_msg_msg_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_aisdgnss_broadcast_binary_msg_repeat_indicator_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aisdgnss_broadcast_binary_msg_repeat_indicator_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aisdgnss_broadcast_binary_msg_repeat_indicator_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_aisdgnss_broadcast_binary_msg_source_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aisdgnss_broadcast_binary_msg_source_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aisdgnss_broadcast_binary_msg_source_id_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_aisdgnss_broadcast_binary_msg_ais_transceiver_information_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aisdgnss_broadcast_binary_msg_ais_transceiver_information_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aisdgnss_broadcast_binary_msg_ais_transceiver_information_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_aisdgnss_broadcast_binary_msg_longitude__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aisdgnss_broadcast_binary_msg_longitude__decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aisdgnss_broadcast_binary_msg_longitude__is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_aisdgnss_broadcast_binary_msg_latitude__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aisdgnss_broadcast_binary_msg_latitude__decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aisdgnss_broadcast_binary_msg_latitude__is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_aisdgnss_broadcast_binary_msg_number_of_bits_in_binary_data_field_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_aisdgnss_broadcast_binary_msg_number_of_bits_in_binary_data_field_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_aisdgnss_broadcast_binary_msg_number_of_bits_in_binary_data_field_is_in_range(uint16_t value);

/**
 * Pack message AISClssASttcAndVyageRelatedData.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_ais_clss_a_sttc_and_vyage_related_data_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_ais_clss_a_sttc_and_vyage_related_data_t *src_p,
    size_t size);

/**
 * Unpack message AISClssASttcAndVyageRelatedData.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_ais_clss_a_sttc_and_vyage_related_data_unpack(
    struct nmea2000_exxo_ais_clss_a_sttc_and_vyage_related_data_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AISClssASttcAndVyageRelatedData.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_ais_clss_a_sttc_and_vyage_related_data_init(struct nmea2000_exxo_ais_clss_a_sttc_and_vyage_related_data_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_clss_a_sttc_and_vyage_related_data_msg_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_clss_a_sttc_and_vyage_related_data_msg_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_clss_a_sttc_and_vyage_related_data_msg_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_clss_a_sttc_and_vyage_related_data_repeat_indicator_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_clss_a_sttc_and_vyage_related_data_repeat_indicator_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_clss_a_sttc_and_vyage_related_data_repeat_indicator_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ais_clss_a_sttc_and_vyage_related_data_user_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_clss_a_sttc_and_vyage_related_data_user_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_clss_a_sttc_and_vyage_related_data_user_id_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ais_clss_a_sttc_and_vyage_related_data_imo_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_clss_a_sttc_and_vyage_related_data_imo_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_clss_a_sttc_and_vyage_related_data_imo_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t nmea2000_exxo_ais_clss_a_sttc_and_vyage_related_data_call_sign_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_clss_a_sttc_and_vyage_related_data_call_sign_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_clss_a_sttc_and_vyage_related_data_call_sign_is_in_range(uint64_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t nmea2000_exxo_ais_clss_a_sttc_and_vyage_related_data_name_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_clss_a_sttc_and_vyage_related_data_name_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_clss_a_sttc_and_vyage_related_data_name_is_in_range(uint64_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t nmea2000_exxo_ais_clss_a_sttc_and_vyage_related_data_destination_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_clss_a_sttc_and_vyage_related_data_destination_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_clss_a_sttc_and_vyage_related_data_destination_is_in_range(uint64_t value);

/**
 * Pack message AISClassBPosReport.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_ais_class_b_pos_report_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_ais_class_b_pos_report_t *src_p,
    size_t size);

/**
 * Unpack message AISClassBPosReport.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_ais_class_b_pos_report_unpack(
    struct nmea2000_exxo_ais_class_b_pos_report_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AISClassBPosReport.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_ais_class_b_pos_report_init(struct nmea2000_exxo_ais_class_b_pos_report_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_class_b_pos_report_msg_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_pos_report_msg_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_pos_report_msg_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_class_b_pos_report_repeat_indicator_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_pos_report_repeat_indicator_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_pos_report_repeat_indicator_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ais_class_b_pos_report_user_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_pos_report_user_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_pos_report_user_id_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_ais_class_b_pos_report_longitude__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_pos_report_longitude__decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_pos_report_longitude__is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_ais_class_b_pos_report_latitude__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_pos_report_latitude__decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_pos_report_latitude__is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_class_b_pos_report_pos_accuracy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_pos_report_pos_accuracy_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_pos_report_pos_accuracy_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_class_b_pos_report_rai_mflag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_pos_report_rai_mflag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_pos_report_rai_mflag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_class_b_pos_report_time_stamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_pos_report_time_stamp_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_pos_report_time_stamp_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_class_b_pos_report_cog_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_pos_report_cog_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_pos_report_cog_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_class_b_pos_report_sog_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_pos_report_sog_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_pos_report_sog_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ais_class_b_pos_report_communication_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_pos_report_communication_state_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_pos_report_communication_state_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_class_b_pos_report_ais_transceiver_information_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_pos_report_ais_transceiver_information_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_pos_report_ais_transceiver_information_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_class_b_pos_report_true_heading_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_pos_report_true_heading_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_pos_report_true_heading_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_class_b_pos_report_comminication_state_selector_flag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_pos_report_comminication_state_selector_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_pos_report_comminication_state_selector_flag_is_in_range(uint8_t value);

/**
 * Pack message AISClassBExPosReport.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_ais_class_b_ex_pos_report_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_ais_class_b_ex_pos_report_t *src_p,
    size_t size);

/**
 * Unpack message AISClassBExPosReport.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_ais_class_b_ex_pos_report_unpack(
    struct nmea2000_exxo_ais_class_b_ex_pos_report_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AISClassBExPosReport.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_ais_class_b_ex_pos_report_init(struct nmea2000_exxo_ais_class_b_ex_pos_report_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_class_b_ex_pos_report_msg_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_ex_pos_report_msg_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_ex_pos_report_msg_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_class_b_ex_pos_report_repeat_indicator_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_ex_pos_report_repeat_indicator_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_ex_pos_report_repeat_indicator_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ais_class_b_ex_pos_report_user_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_ex_pos_report_user_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_ex_pos_report_user_id_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_ais_class_b_ex_pos_report_longitude__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_ex_pos_report_longitude__decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_ex_pos_report_longitude__is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_ais_class_b_ex_pos_report_latitude__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_ex_pos_report_latitude__decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_ex_pos_report_latitude__is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_class_b_ex_pos_report_pos_accuracy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_ex_pos_report_pos_accuracy_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_ex_pos_report_pos_accuracy_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_class_b_ex_pos_report_rai_mflag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_ex_pos_report_rai_mflag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_ex_pos_report_rai_mflag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_class_b_ex_pos_report_time_stamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_ex_pos_report_time_stamp_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_ex_pos_report_time_stamp_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_class_b_ex_pos_report_cog_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_ex_pos_report_cog_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_ex_pos_report_cog_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_class_b_ex_pos_report_sog_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_ex_pos_report_sog_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_ex_pos_report_sog_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_class_b_ex_pos_report_ship_cargo_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_ex_pos_report_ship_cargo_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_ex_pos_report_ship_cargo_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_class_b_ex_pos_report_true_heading_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_ex_pos_report_true_heading_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_ex_pos_report_true_heading_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_class_b_ex_pos_report_type_of_electronic_posing_device_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_ex_pos_report_type_of_electronic_posing_device_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_ex_pos_report_type_of_electronic_posing_device_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_class_b_ex_pos_report_ship_length_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_ex_pos_report_ship_length_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_ex_pos_report_ship_length_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_class_b_ex_pos_report_ship_beam_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_ex_pos_report_ship_beam_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_ex_pos_report_ship_beam_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_class_b_ex_pos_report_pos_reference_point_from_starboard_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_ex_pos_report_pos_reference_point_from_starboard_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_ex_pos_report_pos_reference_point_from_starboard_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_class_b_ex_pos_report_pos_reference_point_aft_of_ships_bow_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_ex_pos_report_pos_reference_point_aft_of_ships_bow_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_ex_pos_report_pos_reference_point_aft_of_ships_bow_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t nmea2000_exxo_ais_class_b_ex_pos_report_name_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_ex_pos_report_name_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_ex_pos_report_name_is_in_range(uint64_t value);

/**
 * Pack message CA.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_ca_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_ca_t *src_p,
    size_t size);

/**
 * Unpack message CA.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_ca_unpack(
    struct nmea2000_exxo_ca_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from CA.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_ca_init(struct nmea2000_exxo_ca_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ca_identity_number_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ca_identity_number_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ca_identity_number_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ca_manufacturer_code_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ca_manufacturer_code_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ca_manufacturer_code_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ca_ecu_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ca_ecu_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ca_ecu_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ca_function_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ca_function_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ca_function_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ca_function_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ca_function_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ca_function_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ca_vehicle_system_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ca_vehicle_system_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ca_vehicle_system_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ca_vehicle_system5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ca_vehicle_system5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ca_vehicle_system5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ca_vehicle_system4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ca_vehicle_system4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ca_vehicle_system4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ca_vehicle_system3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ca_vehicle_system3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ca_vehicle_system3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ca_vehicle_system2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ca_vehicle_system2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ca_vehicle_system2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ca_vehicle_system1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ca_vehicle_system1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ca_vehicle_system1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ca_vehicle_system_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ca_vehicle_system_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ca_vehicle_system_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ca_industry_group_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ca_industry_group_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ca_industry_group_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ca_arbitrary_address_capable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ca_arbitrary_address_capable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ca_arbitrary_address_capable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ca_address_assignment_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ca_address_assignment_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ca_address_assignment_is_in_range(uint8_t value);

/**
 * Pack message ACL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_acl_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_acl_t *src_p,
    size_t size);

/**
 * Unpack message ACL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_acl_unpack(
    struct nmea2000_exxo_acl_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ACL.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_acl_init(struct nmea2000_exxo_acl_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_acl_identity_number_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_acl_identity_number_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_acl_identity_number_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_acl_manufacturer_code_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_acl_manufacturer_code_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_acl_manufacturer_code_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_acl_ecu_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_acl_ecu_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_acl_ecu_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_acl_function_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_acl_function_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_acl_function_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_acl_function_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_acl_function_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_acl_function_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_acl_vehicle_system_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_acl_vehicle_system_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_acl_vehicle_system_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_acl_vehicle_system5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_acl_vehicle_system5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_acl_vehicle_system5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_acl_vehicle_system4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_acl_vehicle_system4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_acl_vehicle_system4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_acl_vehicle_system3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_acl_vehicle_system3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_acl_vehicle_system3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_acl_vehicle_system2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_acl_vehicle_system2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_acl_vehicle_system2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_acl_vehicle_system1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_acl_vehicle_system1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_acl_vehicle_system1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_acl_vehicle_system_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_acl_vehicle_system_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_acl_vehicle_system_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_acl_industry_group_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_acl_industry_group_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_acl_industry_group_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_acl_arbitrary_address_capable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_acl_arbitrary_address_capable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_acl_arbitrary_address_capable_is_in_range(uint8_t value);

/**
 * Pack message TPDT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_tpdt_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_tpdt_t *src_p,
    size_t size);

/**
 * Unpack message TPDT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_tpdt_unpack(
    struct nmea2000_exxo_tpdt_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TPDT.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_tpdt_init(struct nmea2000_exxo_tpdt_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_tpdt_sequence_number_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tpdt_sequence_number_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tpdt_sequence_number_is_in_range(uint8_t value);

/**
 * Pack message TPCM.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_tpcm_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_tpcm_t *src_p,
    size_t size);

/**
 * Unpack message TPCM.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_tpcm_unpack(
    struct nmea2000_exxo_tpcm_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TPCM.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_tpcm_init(struct nmea2000_exxo_tpcm_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_tpcm_control_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tpcm_control_byte_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tpcm_control_byte_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_tpcm_total_message_size_eo_ma_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tpcm_total_message_size_eo_ma_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tpcm_total_message_size_eo_ma_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_tpcm_total_message_size_bam_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tpcm_total_message_size_bam_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tpcm_total_message_size_bam_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_tpcm_connection_abort_reason_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tpcm_connection_abort_reason_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tpcm_connection_abort_reason_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_tpcm_number_of_packets_that_can_be_sent_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tpcm_number_of_packets_that_can_be_sent_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tpcm_number_of_packets_that_can_be_sent_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_tpcm_total_message_size_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tpcm_total_message_size_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tpcm_total_message_size_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_tpcm_next_packet_number_to_be_sent_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tpcm_next_packet_number_to_be_sent_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tpcm_next_packet_number_to_be_sent_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_tpcm_total_number_of_packets_eo_ma_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tpcm_total_number_of_packets_eo_ma_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tpcm_total_number_of_packets_eo_ma_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_tpcm_total_number_of_packets_bam_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tpcm_total_number_of_packets_bam_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tpcm_total_number_of_packets_bam_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_tpcm_total_number_of_packets_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tpcm_total_number_of_packets_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tpcm_total_number_of_packets_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_tpcm_maximum_number_of_packets_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tpcm_maximum_number_of_packets_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tpcm_maximum_number_of_packets_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_tpcm_pg_number_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tpcm_pg_number_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tpcm_pg_number_is_in_range(uint32_t value);

/**
 * Pack message RQST.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_rqst_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_rqst_t *src_p,
    size_t size);

/**
 * Unpack message RQST.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_rqst_unpack(
    struct nmea2000_exxo_rqst_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RQST.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_rqst_init(struct nmea2000_exxo_rqst_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_rqst_parameter_group_number_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_rqst_parameter_group_number_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_rqst_parameter_group_number_is_in_range(uint32_t value);

/**
 * Pack message WindData.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_wind_data_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_wind_data_t *src_p,
    size_t size);

/**
 * Unpack message WindData.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_wind_data_unpack(
    struct nmea2000_exxo_wind_data_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from WindData.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_wind_data_init(struct nmea2000_exxo_wind_data_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_wind_data_sequence_id__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_wind_data_sequence_id__decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_wind_data_sequence_id__is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_wind_data_wind_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_wind_data_wind_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_wind_data_wind_speed_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_wind_data_wind_direction_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_wind_data_wind_direction_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_wind_data_wind_direction_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_wind_data_wind_reference_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_wind_data_wind_reference_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_wind_data_wind_reference_is_in_range(uint8_t value);

/**
 * Pack message WaterDepth.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_water_depth_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_water_depth_t *src_p,
    size_t size);

/**
 * Unpack message WaterDepth.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_water_depth_unpack(
    struct nmea2000_exxo_water_depth_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from WaterDepth.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_water_depth_init(struct nmea2000_exxo_water_depth_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_water_depth_sid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_water_depth_sid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_water_depth_sid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_water_depth_water_depth_transducer_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_water_depth_water_depth_transducer_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_water_depth_water_depth_transducer_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_water_depth_offset_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_water_depth_offset_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_water_depth_offset_is_in_range(int16_t value);

/**
 * Pack message VesselSpeedComponents.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_vessel_speed_components_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_vessel_speed_components_t *src_p,
    size_t size);

/**
 * Unpack message VesselSpeedComponents.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_vessel_speed_components_unpack(
    struct nmea2000_exxo_vessel_speed_components_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VesselSpeedComponents.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_vessel_speed_components_init(struct nmea2000_exxo_vessel_speed_components_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_vessel_speed_components_lngitudinal_speed_waterreferenced_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_vessel_speed_components_lngitudinal_speed_waterreferenced_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_vessel_speed_components_lngitudinal_speed_waterreferenced_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_vessel_speed_components_transverse_speed_waterreferenced_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_vessel_speed_components_transverse_speed_waterreferenced_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_vessel_speed_components_transverse_speed_waterreferenced_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_vessel_speed_components_lngtudinal_speed_groundreferenced_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_vessel_speed_components_lngtudinal_speed_groundreferenced_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_vessel_speed_components_lngtudinal_speed_groundreferenced_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_vessel_speed_components_transverse_speed_groundreferenced_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_vessel_speed_components_transverse_speed_groundreferenced_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_vessel_speed_components_transverse_speed_groundreferenced_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_vessel_speed_components_stern_speed_waterreferenced_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_vessel_speed_components_stern_speed_waterreferenced_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_vessel_speed_components_stern_speed_waterreferenced_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_vessel_speed_components_stern_speed_groundreferenced_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_vessel_speed_components_stern_speed_groundreferenced_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_vessel_speed_components_stern_speed_groundreferenced_is_in_range(int16_t value);

/**
 * Pack message VesselHeading.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_vessel_heading_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_vessel_heading_t *src_p,
    size_t size);

/**
 * Unpack message VesselHeading.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_vessel_heading_unpack(
    struct nmea2000_exxo_vessel_heading_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VesselHeading.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_vessel_heading_init(struct nmea2000_exxo_vessel_heading_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_vessel_heading_sid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_vessel_heading_sid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_vessel_heading_sid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_vessel_heading_heading_sensor_reading_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_vessel_heading_heading_sensor_reading_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_vessel_heading_heading_sensor_reading_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_vessel_heading_deviation_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_vessel_heading_deviation_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_vessel_heading_deviation_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_vessel_heading_variation_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_vessel_heading_variation_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_vessel_heading_variation_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_vessel_heading_heading_sensor_reference_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_vessel_heading_heading_sensor_reference_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_vessel_heading_heading_sensor_reference_is_in_range(uint8_t value);

/**
 * Pack message UserDatumSettings.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_user_datum_settings_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_user_datum_settings_t *src_p,
    size_t size);

/**
 * Unpack message UserDatumSettings.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_user_datum_settings_unpack(
    struct nmea2000_exxo_user_datum_settings_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from UserDatumSettings.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_user_datum_settings_init(struct nmea2000_exxo_user_datum_settings_t *msg_p);

/**
 * Pack message TripParametersVessel.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_trip_parameters_vessel_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_trip_parameters_vessel_t *src_p,
    size_t size);

/**
 * Unpack message TripParametersVessel.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_trip_parameters_vessel_unpack(
    struct nmea2000_exxo_trip_parameters_vessel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TripParametersVessel.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_trip_parameters_vessel_init(struct nmea2000_exxo_trip_parameters_vessel_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_trip_parameters_vessel_time_to_empty_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_trip_parameters_vessel_time_to_empty_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_trip_parameters_vessel_time_to_empty_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_trip_parameters_vessel_distance_to_empty_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_trip_parameters_vessel_distance_to_empty_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_trip_parameters_vessel_distance_to_empty_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_trip_parameters_vessel_est_fuel_remaining_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_trip_parameters_vessel_est_fuel_remaining_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_trip_parameters_vessel_est_fuel_remaining_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_trip_parameters_vessel_trip_run_time_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_trip_parameters_vessel_trip_run_time_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_trip_parameters_vessel_trip_run_time_is_in_range(uint32_t value);

/**
 * Pack message TripParametersEng.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_trip_parameters_eng_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_trip_parameters_eng_t *src_p,
    size_t size);

/**
 * Unpack message TripParametersEng.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_trip_parameters_eng_unpack(
    struct nmea2000_exxo_trip_parameters_eng_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TripParametersEng.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_trip_parameters_eng_init(struct nmea2000_exxo_trip_parameters_eng_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_trip_parameters_eng_eng_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_trip_parameters_eng_eng_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_trip_parameters_eng_eng_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_trip_parameters_eng_trip_fuel_used_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_trip_parameters_eng_trip_fuel_used_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_trip_parameters_eng_trip_fuel_used_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_trip_parameters_eng_fuel_rate_average_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_trip_parameters_eng_fuel_rate_average_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_trip_parameters_eng_fuel_rate_average_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_trip_parameters_eng_fuel_rate_economy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_trip_parameters_eng_fuel_rate_economy_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_trip_parameters_eng_fuel_rate_economy_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_trip_parameters_eng_instantaneous_fuel_economy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_trip_parameters_eng_instantaneous_fuel_economy_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_trip_parameters_eng_instantaneous_fuel_economy_is_in_range(int16_t value);

/**
 * Pack message TransParametersDynamic.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_trans_parameters_dynamic_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_trans_parameters_dynamic_t *src_p,
    size_t size);

/**
 * Unpack message TransParametersDynamic.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_trans_parameters_dynamic_unpack(
    struct nmea2000_exxo_trans_parameters_dynamic_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TransParametersDynamic.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_trans_parameters_dynamic_init(struct nmea2000_exxo_trans_parameters_dynamic_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_trans_parameters_dynamic_trans_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_trans_parameters_dynamic_trans_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_trans_parameters_dynamic_trans_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_trans_parameters_dynamic_trans_gear_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_trans_parameters_dynamic_trans_gear_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_trans_parameters_dynamic_trans_gear_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_trans_parameters_dynamic_trans_oil_press__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_trans_parameters_dynamic_trans_oil_press__decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_trans_parameters_dynamic_trans_oil_press__is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_trans_parameters_dynamic_trans_oil_temp__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_trans_parameters_dynamic_trans_oil_temp__decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_trans_parameters_dynamic_trans_oil_temp__is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_trans_parameters_dynamic_trans_discrete_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_trans_parameters_dynamic_trans_discrete_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_trans_parameters_dynamic_trans_discrete_status_is_in_range(uint8_t value);

/**
 * Pack message TrackedTargetData.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_tracked_target_data_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_tracked_target_data_t *src_p,
    size_t size);

/**
 * Unpack message TrackedTargetData.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_tracked_target_data_unpack(
    struct nmea2000_exxo_tracked_target_data_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TrackedTargetData.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_tracked_target_data_init(struct nmea2000_exxo_tracked_target_data_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_tracked_target_data_sequence_id__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tracked_target_data_sequence_id__decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tracked_target_data_sequence_id__is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_tracked_target_data_target_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tracked_target_data_target_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tracked_target_data_target_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_tracked_target_data_track_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tracked_target_data_track_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tracked_target_data_track_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_tracked_target_data_bearing_reference_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tracked_target_data_bearing_reference_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tracked_target_data_bearing_reference_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_tracked_target_data_bearing_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tracked_target_data_bearing_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tracked_target_data_bearing_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_tracked_target_data_distance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tracked_target_data_distance_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tracked_target_data_distance_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_tracked_target_data_course_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tracked_target_data_course_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tracked_target_data_course_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_tracked_target_data_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tracked_target_data_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tracked_target_data_speed_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_tracked_target_data_cpa_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tracked_target_data_cpa_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tracked_target_data_cpa_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_tracked_target_data_tcpa_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tracked_target_data_tcpa_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tracked_target_data_tcpa_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_tracked_target_data_utc_of_fix_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tracked_target_data_utc_of_fix_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tracked_target_data_utc_of_fix_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_tracked_target_data_name_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_tracked_target_data_name_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_tracked_target_data_name_is_in_range(uint16_t value);

/**
 * Pack message RouteAndWPServiceWPListWPNamePos.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_route_and_wp_service_wp_list_wp_name_pos_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_route_and_wp_service_wp_list_wp_name_pos_t *src_p,
    size_t size);

/**
 * Unpack message RouteAndWPServiceWPListWPNamePos.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_route_and_wp_service_wp_list_wp_name_pos_unpack(
    struct nmea2000_exxo_route_and_wp_service_wp_list_wp_name_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RouteAndWPServiceWPListWPNamePos.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_route_and_wp_service_wp_list_wp_name_pos_init(struct nmea2000_exxo_route_and_wp_service_wp_list_wp_name_pos_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_wp_list_wp_name_pos_start_wpid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_wp_list_wp_name_pos_start_wpid_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_wp_list_wp_name_pos_start_wpid_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_wp_list_wp_name_pos_n_items_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_wp_list_wp_name_pos_n_items_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_wp_list_wp_name_pos_n_items_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_wp_list_wp_name_pos_number_of_valid_w_ps_in_wp_list_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_wp_list_wp_name_pos_number_of_valid_w_ps_in_wp_list_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_wp_list_wp_name_pos_number_of_valid_w_ps_in_wp_list_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_wp_list_wp_name_pos_database_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_wp_list_wp_name_pos_database_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_wp_list_wp_name_pos_database_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_wp_list_wp_name_pos_reserved_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_wp_list_wp_name_pos_reserved_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_wp_list_wp_name_pos_reserved_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_wp_list_wp_name_pos_wpid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_wp_list_wp_name_pos_wpid_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_wp_list_wp_name_pos_wpid_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_wp_list_wp_name_pos_wp_name_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_wp_list_wp_name_pos_wp_name_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_wp_list_wp_name_pos_wp_name_is_in_range(uint16_t value);

/**
 * Pack message RouteAndWPServiceDatabaseComment.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_route_and_wp_service_database_comment_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_route_and_wp_service_database_comment_t *src_p,
    size_t size);

/**
 * Unpack message RouteAndWPServiceDatabaseComment.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_route_and_wp_service_database_comment_unpack(
    struct nmea2000_exxo_route_and_wp_service_database_comment_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RouteAndWPServiceDatabaseComment.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_route_and_wp_service_database_comment_init(struct nmea2000_exxo_route_and_wp_service_database_comment_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_database_comment_start_database_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_database_comment_start_database_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_database_comment_start_database_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_database_comment_n_items_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_database_comment_n_items_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_database_comment_n_items_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_database_comment_number_of_databases_with_comments_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_database_comment_number_of_databases_with_comments_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_database_comment_number_of_databases_with_comments_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_database_comment_database_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_database_comment_database_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_database_comment_database_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_route_and_wp_service_database_comment_comment_text_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_database_comment_comment_text_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_database_comment_comment_text_is_in_range(uint32_t value);

/**
 * Pack message Rudder.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_rudder_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_rudder_t *src_p,
    size_t size);

/**
 * Unpack message Rudder.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_rudder_unpack(
    struct nmea2000_exxo_rudder_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Rudder.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_rudder_init(struct nmea2000_exxo_rudder_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_rudder_rudder_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_rudder_rudder_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_rudder_rudder_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_rudder_directionder_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_rudder_directionder_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_rudder_directionder_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_rudder_angleder_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_rudder_angleder_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_rudder_angleder_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_rudder_pos_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_rudder_pos_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_rudder_pos_is_in_range(int16_t value);

/**
 * Pack message RtAndWPSrvcXTELmtNvgationMethod.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_t *src_p,
    size_t size);

/**
 * Unpack message RtAndWPSrvcXTELmtNvgationMethod.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_unpack(
    struct nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RtAndWPSrvcXTELmtNvgationMethod.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_init(struct nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_start_rps_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_start_rps_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_start_rps_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_n_items_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_n_items_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_n_items_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_nmbr_of_wypnts_wth_a_spcfc_xte_lmt_nv_mth_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_nmbr_of_wypnts_wth_a_spcfc_xte_lmt_nv_mth_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_nmbr_of_wypnts_wth_a_spcfc_xte_lmt_nv_mth_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_database_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_database_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_database_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_route_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_route_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_route_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_rps_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_rps_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_rps_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_xte_limit_in_leg_after_wp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_xte_limit_in_leg_after_wp_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_xte_limit_in_leg_after_wp_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_nav_method_in_leg_after_wp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_nav_method_in_leg_after_wp_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_rt_and_wp_srvc_xte_lmt_nvgation_method_nav_method_in_leg_after_wp_is_in_range(uint8_t value);

/**
 * Pack message RtAndWPSrvcRte_WPListAttributes.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_rt_and_wp_srvc_rte_wp_list_attributes_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_rt_and_wp_srvc_rte_wp_list_attributes_t *src_p,
    size_t size);

/**
 * Unpack message RtAndWPSrvcRte_WPListAttributes.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_rt_and_wp_srvc_rte_wp_list_attributes_unpack(
    struct nmea2000_exxo_rt_and_wp_srvc_rte_wp_list_attributes_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RtAndWPSrvcRte_WPListAttributes.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_rt_and_wp_srvc_rte_wp_list_attributes_init(struct nmea2000_exxo_rt_and_wp_srvc_rte_wp_list_attributes_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_rt_and_wp_srvc_rte_wp_list_attributes_database_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_rt_and_wp_srvc_rte_wp_list_attributes_database_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_rt_and_wp_srvc_rte_wp_list_attributes_database_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_rt_and_wp_srvc_rte_wp_list_attributes_route_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_rt_and_wp_srvc_rte_wp_list_attributes_route_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_rt_and_wp_srvc_rte_wp_list_attributes_route_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_rt_and_wp_srvc_rte_wp_list_attributes_route_wp_list_name_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_rt_and_wp_srvc_rte_wp_list_attributes_route_wp_list_name_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_rt_and_wp_srvc_rte_wp_list_attributes_route_wp_list_name_is_in_range(uint16_t value);

/**
 * Pack message RouteAndWPServiceWPComment.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_route_and_wp_service_wp_comment_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_route_and_wp_service_wp_comment_t *src_p,
    size_t size);

/**
 * Unpack message RouteAndWPServiceWPComment.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_route_and_wp_service_wp_comment_unpack(
    struct nmea2000_exxo_route_and_wp_service_wp_comment_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RouteAndWPServiceWPComment.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_route_and_wp_service_wp_comment_init(struct nmea2000_exxo_route_and_wp_service_wp_comment_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_wp_comment_start_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_wp_comment_start_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_wp_comment_start_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_wp_comment_n_items_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_wp_comment_n_items_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_wp_comment_n_items_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_wp_comment_number_of_w_ps_with_comments_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_wp_comment_number_of_w_ps_with_comments_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_wp_comment_number_of_w_ps_with_comments_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_wp_comment_database_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_wp_comment_database_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_wp_comment_database_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_wp_comment_route_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_wp_comment_route_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_wp_comment_route_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_route_and_wp_service_wp_comment_wpid_rps_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_wp_comment_wpid_rps_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_wp_comment_wpid_rps_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_route_and_wp_service_wp_comment_comment_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_route_and_wp_service_wp_comment_comment_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_route_and_wp_service_wp_comment_comment_is_in_range(uint32_t value);

/**
 * Pack message GNSSRAIMOutput.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_gnssraim_output_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_gnssraim_output_t *src_p,
    size_t size);

/**
 * Unpack message GNSSRAIMOutput.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_gnssraim_output_unpack(
    struct nmea2000_exxo_gnssraim_output_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from GNSSRAIMOutput.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_gnssraim_output_init(struct nmea2000_exxo_gnssraim_output_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnssraim_output_sequence_id__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnssraim_output_sequence_id__decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnssraim_output_sequence_id__is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnssraim_output_integrity_flag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnssraim_output_integrity_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnssraim_output_integrity_flag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_gnssraim_output_latitude_expected_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnssraim_output_latitude_expected_error_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnssraim_output_latitude_expected_error_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_gnssraim_output_longitude_expected_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnssraim_output_longitude_expected_error_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnssraim_output_longitude_expected_error_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_gnssraim_output_altitude_expected_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnssraim_output_altitude_expected_error_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnssraim_output_altitude_expected_error_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnssraim_output_svid_of_most_likely_failed_sat_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnssraim_output_svid_of_most_likely_failed_sat_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnssraim_output_svid_of_most_likely_failed_sat_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t nmea2000_exxo_gnssraim_output_probability_of_missed_detection_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnssraim_output_probability_of_missed_detection_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnssraim_output_probability_of_missed_detection_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_gnssraim_output_estimate_of_pseudorange_bias_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnssraim_output_estimate_of_pseudorange_bias_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnssraim_output_estimate_of_pseudorange_bias_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_gnssraim_output_std_deviation_of_bias_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnssraim_output_std_deviation_of_bias_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnssraim_output_std_deviation_of_bias_is_in_range(int16_t value);

/**
 * Pack message GNSSPseudorangeNoiseStatistics.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_gnss_pseudorange_noise_statistics_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_gnss_pseudorange_noise_statistics_t *src_p,
    size_t size);

/**
 * Unpack message GNSSPseudorangeNoiseStatistics.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_gnss_pseudorange_noise_statistics_unpack(
    struct nmea2000_exxo_gnss_pseudorange_noise_statistics_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from GNSSPseudorangeNoiseStatistics.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_gnss_pseudorange_noise_statistics_init(struct nmea2000_exxo_gnss_pseudorange_noise_statistics_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_pseudorange_noise_statistics_sid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pseudorange_noise_statistics_sid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pseudorange_noise_statistics_sid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gnss_pseudorange_noise_statistics_rms_of_pos_uncertainty_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pseudorange_noise_statistics_rms_of_pos_uncertainty_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pseudorange_noise_statistics_rms_of_pos_uncertainty_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gnss_pseudorange_noise_statistics_std_of_major_axis_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pseudorange_noise_statistics_std_of_major_axis_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pseudorange_noise_statistics_std_of_major_axis_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gnss_pseudorange_noise_statistics_std_of_minor_axis_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pseudorange_noise_statistics_std_of_minor_axis_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pseudorange_noise_statistics_std_of_minor_axis_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gnss_pseudorange_noise_statistics_orientation_of_major_axis_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pseudorange_noise_statistics_orientation_of_major_axis_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pseudorange_noise_statistics_orientation_of_major_axis_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gnss_pseudorange_noise_statistics_std_of_lat_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pseudorange_noise_statistics_std_of_lat_error_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pseudorange_noise_statistics_std_of_lat_error_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gnss_pseudorange_noise_statistics_std_of_lon_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pseudorange_noise_statistics_std_of_lon_error_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pseudorange_noise_statistics_std_of_lon_error_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gnss_pseudorange_noise_statistics_std_of_alt_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pseudorange_noise_statistics_std_of_alt_error_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pseudorange_noise_statistics_std_of_alt_error_is_in_range(uint16_t value);

/**
 * Pack message GNSSPseudorangeErrorStatistics.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_gnss_pseudorange_error_statistics_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_gnss_pseudorange_error_statistics_t *src_p,
    size_t size);

/**
 * Unpack message GNSSPseudorangeErrorStatistics.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_gnss_pseudorange_error_statistics_unpack(
    struct nmea2000_exxo_gnss_pseudorange_error_statistics_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from GNSSPseudorangeErrorStatistics.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_gnss_pseudorange_error_statistics_init(struct nmea2000_exxo_gnss_pseudorange_error_statistics_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_pseudorange_error_statistics_sequence_id__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pseudorange_error_statistics_sequence_id__decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pseudorange_error_statistics_sequence_id__is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gnss_pseudorange_error_statistics_rms_std_dev_of_range_inputs_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pseudorange_error_statistics_rms_std_dev_of_range_inputs_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pseudorange_error_statistics_rms_std_dev_of_range_inputs_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gnss_pseudorange_error_statistics_std_dev_major_error_ellipse_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pseudorange_error_statistics_std_dev_major_error_ellipse_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pseudorange_error_statistics_std_dev_major_error_ellipse_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gnss_pseudorange_error_statistics_std_dev_minor_error_ellipse_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pseudorange_error_statistics_std_dev_minor_error_ellipse_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pseudorange_error_statistics_std_dev_minor_error_ellipse_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gnss_pseudorange_error_statistics_orientation_of_error_ellipse_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pseudorange_error_statistics_orientation_of_error_ellipse_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pseudorange_error_statistics_orientation_of_error_ellipse_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gnss_pseudorange_error_statistics_std_dev_latitude_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pseudorange_error_statistics_std_dev_latitude_error_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pseudorange_error_statistics_std_dev_latitude_error_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gnss_pseudorange_error_statistics_std_dev_longitude_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pseudorange_error_statistics_std_dev_longitude_error_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pseudorange_error_statistics_std_dev_longitude_error_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gnss_pseudorange_error_statistics_std_dev_altitude_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pseudorange_error_statistics_std_dev_altitude_error_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pseudorange_error_statistics_std_dev_altitude_error_is_in_range(uint16_t value);

/**
 * Pack message GNSSPosData.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_gnss_pos_data_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_gnss_pos_data_t *src_p,
    size_t size);

/**
 * Unpack message GNSSPosData.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_gnss_pos_data_unpack(
    struct nmea2000_exxo_gnss_pos_data_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from GNSSPosData.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_gnss_pos_data_init(struct nmea2000_exxo_gnss_pos_data_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_pos_data_sid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pos_data_sid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pos_data_sid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gnss_pos_data_pos_date_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pos_data_pos_date_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pos_data_pos_date_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_gnss_pos_data_pos_time_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pos_data_pos_time_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pos_data_pos_time_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_gnss_pos_data_latitude_low_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pos_data_latitude_low_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pos_data_latitude_low_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_gnss_pos_data_latitude_high_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pos_data_latitude_high_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pos_data_latitude_high_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_gnss_pos_data_longitude_low_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pos_data_longitude_low_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pos_data_longitude_low_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_gnss_pos_data_longitude_high_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pos_data_longitude_high_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pos_data_longitude_high_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_gnss_pos_data_altitude_low_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pos_data_altitude_low_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pos_data_altitude_low_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_gnss_pos_data_altitude_high_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pos_data_altitude_high_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pos_data_altitude_high_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_pos_data_type_of_system__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pos_data_type_of_system__decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pos_data_type_of_system__is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_pos_data_method_gnss_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pos_data_method_gnss_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pos_data_method_gnss_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_pos_data_integrity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pos_data_integrity_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pos_data_integrity_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_pos_data_number_of_s_vs__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pos_data_number_of_s_vs__decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pos_data_number_of_s_vs__is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_gnss_pos_data_hdop__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pos_data_hdop__decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pos_data_hdop__is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_gnss_pos_data_pdop__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pos_data_pdop__decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pos_data_pdop__is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_gnss_pos_data_geoidal_separation__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pos_data_geoidal_separation__decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pos_data_geoidal_separation__is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_pos_data_number_of_reference_stations__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pos_data_number_of_reference_stations__decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pos_data_number_of_reference_stations__is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_pos_data_reference_station_type1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pos_data_reference_station_type1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pos_data_reference_station_type1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gnss_pos_data_reference_station_id1__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pos_data_reference_station_id1__decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pos_data_reference_station_id1__is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gnss_pos_data_age_of_dgnss_corrections1__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pos_data_age_of_dgnss_corrections1__decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pos_data_age_of_dgnss_corrections1__is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_pos_data_reference_station_type_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pos_data_reference_station_type_n_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pos_data_reference_station_type_n_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gnss_pos_data_reference_station_idn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pos_data_reference_station_idn_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pos_data_reference_station_idn_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gnss_pos_data_age_of_dgnss_reference_station_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_pos_data_age_of_dgnss_reference_station_n_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_pos_data_age_of_dgnss_reference_station_n_is_in_range(uint16_t value);

/**
 * Pack message GNSSDffCrrctonReceiverInterface.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_gnss_dff_crrcton_receiver_interface_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_gnss_dff_crrcton_receiver_interface_t *src_p,
    size_t size);

/**
 * Unpack message GNSSDffCrrctonReceiverInterface.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_gnss_dff_crrcton_receiver_interface_unpack(
    struct nmea2000_exxo_gnss_dff_crrcton_receiver_interface_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from GNSSDffCrrctonReceiverInterface.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_gnss_dff_crrcton_receiver_interface_init(struct nmea2000_exxo_gnss_dff_crrcton_receiver_interface_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_dff_crrcton_receiver_interface_channel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_dff_crrcton_receiver_interface_channel_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_dff_crrcton_receiver_interface_channel_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_gnss_dff_crrcton_receiver_interface_frequency_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_dff_crrcton_receiver_interface_frequency_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_dff_crrcton_receiver_interface_frequency_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_dff_crrcton_receiver_interface_serial_interface_bit_rate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_dff_crrcton_receiver_interface_serial_interface_bit_rate_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_dff_crrcton_receiver_interface_serial_interface_bit_rate_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_dff_crrcton_receiver_interface_serial_interface_detection_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_dff_crrcton_receiver_interface_serial_interface_detection_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_dff_crrcton_receiver_interface_serial_interface_detection_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_dff_crrcton_receiver_interface_diff_source_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_dff_crrcton_receiver_interface_diff_source_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_dff_crrcton_receiver_interface_diff_source_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_dff_crrcton_receiver_interface_diff_operation_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_dff_crrcton_receiver_interface_diff_operation_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_dff_crrcton_receiver_interface_diff_operation_mode_is_in_range(uint8_t value);

/**
 * Pack message GNSSDffCorrectionReceiverSignal.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_gnss_dff_correction_receiver_signal_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_gnss_dff_correction_receiver_signal_t *src_p,
    size_t size);

/**
 * Unpack message GNSSDffCorrectionReceiverSignal.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_gnss_dff_correction_receiver_signal_unpack(
    struct nmea2000_exxo_gnss_dff_correction_receiver_signal_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from GNSSDffCorrectionReceiverSignal.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_gnss_dff_correction_receiver_signal_init(struct nmea2000_exxo_gnss_dff_correction_receiver_signal_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_dff_correction_receiver_signal_sid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_dff_correction_receiver_signal_sid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_dff_correction_receiver_signal_sid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_dff_correction_receiver_signal_channel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_dff_correction_receiver_signal_channel_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_dff_correction_receiver_signal_channel_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_gnss_dff_correction_receiver_signal_signal_strength_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_dff_correction_receiver_signal_signal_strength_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_dff_correction_receiver_signal_signal_strength_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_gnss_dff_correction_receiver_signal_signal_snr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_dff_correction_receiver_signal_signal_snr_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_dff_correction_receiver_signal_signal_snr_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_gnss_dff_correction_receiver_signal_frequency_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_dff_correction_receiver_signal_frequency_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_dff_correction_receiver_signal_frequency_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_dff_correction_receiver_signal_station_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_dff_correction_receiver_signal_station_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_dff_correction_receiver_signal_station_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gnss_dff_correction_receiver_signal_station_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_dff_correction_receiver_signal_station_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_dff_correction_receiver_signal_station_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_dff_correction_receiver_signal_diff_signal_bit_rate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_dff_correction_receiver_signal_diff_signal_bit_rate_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_dff_correction_receiver_signal_diff_signal_bit_rate_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_dff_correction_receiver_signal_diff_signal_detection_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_dff_correction_receiver_signal_diff_signal_detection_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_dff_correction_receiver_signal_diff_signal_detection_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_dff_correction_receiver_signal_used_as_correction_source_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_dff_correction_receiver_signal_used_as_correction_source_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_dff_correction_receiver_signal_used_as_correction_source_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_dff_correction_receiver_signal_diff_source_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_dff_correction_receiver_signal_diff_source_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_dff_correction_receiver_signal_diff_source_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gnss_dff_correction_receiver_signal_time_since_last_sat_diff_sync_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_dff_correction_receiver_signal_time_since_last_sat_diff_sync_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_dff_correction_receiver_signal_time_since_last_sat_diff_sync_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gnss_dff_correction_receiver_signal_satellite_service_id_no_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_dff_correction_receiver_signal_satellite_service_id_no_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_dff_correction_receiver_signal_satellite_service_id_no_is_in_range(uint16_t value);

/**
 * Pack message GNSSDOPs.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_gnssdo_ps_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_gnssdo_ps_t *src_p,
    size_t size);

/**
 * Unpack message GNSSDOPs.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_gnssdo_ps_unpack(
    struct nmea2000_exxo_gnssdo_ps_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from GNSSDOPs.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_gnssdo_ps_init(struct nmea2000_exxo_gnssdo_ps_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnssdo_ps_sid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnssdo_ps_sid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnssdo_ps_sid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnssdo_ps_set_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnssdo_ps_set_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnssdo_ps_set_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnssdo_ps_op_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnssdo_ps_op_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnssdo_ps_op_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_gnssdo_ps_hdop__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnssdo_ps_hdop__decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnssdo_ps_hdop__is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_gnssdo_ps_vdop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnssdo_ps_vdop_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnssdo_ps_vdop_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_gnssdo_ps_tdop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnssdo_ps_tdop_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnssdo_ps_tdop_is_in_range(int16_t value);

/**
 * Pack message GNSSCtrlStatus.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_gnss_ctrl_status_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_gnss_ctrl_status_t *src_p,
    size_t size);

/**
 * Unpack message GNSSCtrlStatus.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_gnss_ctrl_status_unpack(
    struct nmea2000_exxo_gnss_ctrl_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from GNSSCtrlStatus.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_gnss_ctrl_status_init(struct nmea2000_exxo_gnss_ctrl_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_gnss_ctrl_status_sv_elevation_mask_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_ctrl_status_sv_elevation_mask_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_ctrl_status_sv_elevation_mask_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_gnss_ctrl_status_pdop_mask_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_ctrl_status_pdop_mask_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_ctrl_status_pdop_mask_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_gnss_ctrl_status_pdop_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_ctrl_status_pdop_switch_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_ctrl_status_pdop_switch_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_gnss_ctrl_status_snr_mask_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_ctrl_status_snr_mask_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_ctrl_status_snr_mask_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_ctrl_status_gnss_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_ctrl_status_gnss_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_ctrl_status_gnss_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_ctrl_status_dgnss_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_ctrl_status_dgnss_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_ctrl_status_dgnss_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_ctrl_status_pos_velocity_filter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_ctrl_status_pos_velocity_filter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_ctrl_status_pos_velocity_filter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_gnss_ctrl_status_max_correction_age_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_ctrl_status_max_correction_age_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_ctrl_status_max_correction_age_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_gnss_ctrl_status_antenna_altitude_for2_d_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_ctrl_status_antenna_altitude_for2_d_mode_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_ctrl_status_antenna_altitude_for2_d_mode_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_gnss_ctrl_status_use_antenna_altitude_for2_d_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_gnss_ctrl_status_use_antenna_altitude_for2_d_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_gnss_ctrl_status_use_antenna_altitude_for2_d_mode_is_in_range(uint8_t value);

/**
 * Pack message GLONASSAlmanacData.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_glonass_almanac_data_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_glonass_almanac_data_t *src_p,
    size_t size);

/**
 * Unpack message GLONASSAlmanacData.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_glonass_almanac_data_unpack(
    struct nmea2000_exxo_glonass_almanac_data_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from GLONASSAlmanacData.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_glonass_almanac_data_init(struct nmea2000_exxo_glonass_almanac_data_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_glonass_almanac_data_prn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_glonass_almanac_data_prn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_glonass_almanac_data_prn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_glonass_almanac_data_na_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_glonass_almanac_data_na_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_glonass_almanac_data_na_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_glonass_almanac_data_cn_a_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_glonass_almanac_data_cn_a_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_glonass_almanac_data_cn_a_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_glonass_almanac_data_hn_a_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_glonass_almanac_data_hn_a_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_glonass_almanac_data_hn_a_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_glonass_almanac_data_n_a_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_glonass_almanac_data_n_a_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_glonass_almanac_data_n_a_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_glonass_almanac_data_dot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_glonass_almanac_data_dot_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_glonass_almanac_data_dot_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_glonass_almanac_data_n_a2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_glonass_almanac_data_n_a2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_glonass_almanac_data_n_a2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_glonass_almanac_data_tn_a_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_glonass_almanac_data_tn_a_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_glonass_almanac_data_tn_a_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_glonass_almanac_data_tn_a_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_glonass_almanac_data_tn_a_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_glonass_almanac_data_tn_a_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_glonass_almanac_data_n_a3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_glonass_almanac_data_n_a3_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_glonass_almanac_data_n_a3_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_glonass_almanac_data_in_a_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_glonass_almanac_data_in_a_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_glonass_almanac_data_in_a_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_glonass_almanac_data_tc_a_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_glonass_almanac_data_tc_a_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_glonass_almanac_data_tc_a_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_glonass_almanac_data_tn_a2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_glonass_almanac_data_tn_a2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_glonass_almanac_data_tn_a2_is_in_range(uint16_t value);

/**
 * Pack message FluidLevel.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_fluid_level_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_fluid_level_t *src_p,
    size_t size);

/**
 * Unpack message FluidLevel.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_fluid_level_unpack(
    struct nmea2000_exxo_fluid_level_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from FluidLevel.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_fluid_level_init(struct nmea2000_exxo_fluid_level_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_fluid_level_fluid_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_fluid_level_fluid_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_fluid_level_fluid_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_fluid_level_fluid_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_fluid_level_fluid_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_fluid_level_fluid_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_fluid_level_fluid_level_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_fluid_level_fluid_level_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_fluid_level_fluid_level_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_fluid_level_tank_capacity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_fluid_level_tank_capacity_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_fluid_level_tank_capacity_is_in_range(uint32_t value);

/**
 * Pack message EnvironmentalParameters.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_environmental_parameters_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_environmental_parameters_t *src_p,
    size_t size);

/**
 * Unpack message EnvironmentalParameters.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_environmental_parameters_unpack(
    struct nmea2000_exxo_environmental_parameters_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from EnvironmentalParameters.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_environmental_parameters_init(struct nmea2000_exxo_environmental_parameters_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_environmental_parameters_sequence_id__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_environmental_parameters_sequence_id__decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_environmental_parameters_sequence_id__is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_environmental_parameters_water_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_environmental_parameters_water_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_environmental_parameters_water_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_environmental_parameters_outside_ambient_air_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_environmental_parameters_outside_ambient_air_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_environmental_parameters_outside_ambient_air_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_environmental_parameters_atmospheric_press_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_environmental_parameters_atmospheric_press_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_environmental_parameters_atmospheric_press_is_in_range(uint16_t value);

/**
 * Pack message EngParametersStatic.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_eng_parameters_static_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_eng_parameters_static_t *src_p,
    size_t size);

/**
 * Unpack message EngParametersStatic.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_eng_parameters_static_unpack(
    struct nmea2000_exxo_eng_parameters_static_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from EngParametersStatic.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_eng_parameters_static_init(struct nmea2000_exxo_eng_parameters_static_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_eng_parameters_static_eng_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_eng_parameters_static_eng_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_eng_parameters_static_eng_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_eng_parameters_static_rated_eng_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_eng_parameters_static_rated_eng_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_eng_parameters_static_rated_eng_speed_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_eng_parameters_static_vin_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_eng_parameters_static_vin_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_eng_parameters_static_vin_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_eng_parameters_static_software_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_eng_parameters_static_software_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_eng_parameters_static_software_id_is_in_range(uint16_t value);

/**
 * Pack message EngParametersRapidUpdate.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_eng_parameters_rapid_update_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_eng_parameters_rapid_update_t *src_p,
    size_t size);

/**
 * Unpack message EngParametersRapidUpdate.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_eng_parameters_rapid_update_unpack(
    struct nmea2000_exxo_eng_parameters_rapid_update_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from EngParametersRapidUpdate.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_eng_parameters_rapid_update_init(struct nmea2000_exxo_eng_parameters_rapid_update_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_eng_parameters_rapid_update_eng_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_eng_parameters_rapid_update_eng_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_eng_parameters_rapid_update_eng_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_eng_parameters_rapid_update_eng_speed__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_eng_parameters_rapid_update_eng_speed__decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_eng_parameters_rapid_update_eng_speed__is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_eng_parameters_rapid_update_eng_boost_press_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_eng_parameters_rapid_update_eng_boost_press_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_eng_parameters_rapid_update_eng_boost_press_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t nmea2000_exxo_eng_parameters_rapid_update_eng_tilt_trim_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_eng_parameters_rapid_update_eng_tilt_trim_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_eng_parameters_rapid_update_eng_tilt_trim_is_in_range(int8_t value);

/**
 * Pack message EngParametersDynamic.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_eng_parameters_dynamic_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_eng_parameters_dynamic_t *src_p,
    size_t size);

/**
 * Unpack message EngParametersDynamic.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_eng_parameters_dynamic_unpack(
    struct nmea2000_exxo_eng_parameters_dynamic_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from EngParametersDynamic.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_eng_parameters_dynamic_init(struct nmea2000_exxo_eng_parameters_dynamic_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_eng_parameters_dynamic_eng_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_eng_parameters_dynamic_eng_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_eng_parameters_dynamic_eng_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_eng_parameters_dynamic_eng_oil_press__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_eng_parameters_dynamic_eng_oil_press__decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_eng_parameters_dynamic_eng_oil_press__is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_eng_parameters_dynamic_eng_oil_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_eng_parameters_dynamic_eng_oil_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_eng_parameters_dynamic_eng_oil_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_eng_parameters_dynamic_eng_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_eng_parameters_dynamic_eng_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_eng_parameters_dynamic_eng_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_eng_parameters_dynamic_alt_potential_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_eng_parameters_dynamic_alt_potential_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_eng_parameters_dynamic_alt_potential_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_eng_parameters_dynamic_fuel_rate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_eng_parameters_dynamic_fuel_rate_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_eng_parameters_dynamic_fuel_rate_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_eng_parameters_dynamic_total_eng_hours_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_eng_parameters_dynamic_total_eng_hours_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_eng_parameters_dynamic_total_eng_hours_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_eng_parameters_dynamic_eng_coolant_press__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_eng_parameters_dynamic_eng_coolant_press__decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_eng_parameters_dynamic_eng_coolant_press__is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_eng_parameters_dynamic_fuel_press_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_eng_parameters_dynamic_fuel_press_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_eng_parameters_dynamic_fuel_press_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_eng_parameters_dynamic_eng_discrete_status1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_eng_parameters_dynamic_eng_discrete_status1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_eng_parameters_dynamic_eng_discrete_status1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_eng_parameters_dynamic_eng_discrete_status2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_eng_parameters_dynamic_eng_discrete_status2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_eng_parameters_dynamic_eng_discrete_status2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t nmea2000_exxo_eng_parameters_dynamic_percent_eng_load_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_eng_parameters_dynamic_percent_eng_load_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_eng_parameters_dynamic_percent_eng_load_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t nmea2000_exxo_eng_parameters_dynamic_percent_eng_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_eng_parameters_dynamic_percent_eng_torque_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_eng_parameters_dynamic_percent_eng_torque_is_in_range(int8_t value);

/**
 * Pack message DistanceLog.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_distance_log_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_distance_log_t *src_p,
    size_t size);

/**
 * Unpack message DistanceLog.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_distance_log_unpack(
    struct nmea2000_exxo_distance_log_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DistanceLog.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_distance_log_init(struct nmea2000_exxo_distance_log_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_distance_log_measurement_date_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_distance_log_measurement_date_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_distance_log_measurement_date_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_distance_log_measurement_time_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_distance_log_measurement_time_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_distance_log_measurement_time_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_distance_log_total_cumulative_distance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_distance_log_total_cumulative_distance_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_distance_log_total_cumulative_distance_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_distance_log_distance_since_last_reset_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_distance_log_distance_since_last_reset_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_distance_log_distance_since_last_reset_is_in_range(uint32_t value);

/**
 * Pack message AISClassAPosReport.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_ais_class_a_pos_report_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_ais_class_a_pos_report_t *src_p,
    size_t size);

/**
 * Unpack message AISClassAPosReport.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_ais_class_a_pos_report_unpack(
    struct nmea2000_exxo_ais_class_a_pos_report_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AISClassAPosReport.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_ais_class_a_pos_report_init(struct nmea2000_exxo_ais_class_a_pos_report_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_class_a_pos_report_msg_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_a_pos_report_msg_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_a_pos_report_msg_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_class_a_pos_report_repeat_indicator_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_a_pos_report_repeat_indicator_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_a_pos_report_repeat_indicator_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ais_class_a_pos_report_user_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_a_pos_report_user_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_a_pos_report_user_id_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_ais_class_a_pos_report_longitude__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_a_pos_report_longitude__decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_a_pos_report_longitude__is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_ais_class_a_pos_report_latitude__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_a_pos_report_latitude__decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_a_pos_report_latitude__is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_class_a_pos_report_pos_accuracy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_a_pos_report_pos_accuracy_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_a_pos_report_pos_accuracy_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_class_a_pos_report_rai_mflag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_a_pos_report_rai_mflag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_a_pos_report_rai_mflag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_class_a_pos_report_time_stamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_a_pos_report_time_stamp_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_a_pos_report_time_stamp_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_class_a_pos_report_cog_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_a_pos_report_cog_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_a_pos_report_cog_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_class_a_pos_report_sog_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_a_pos_report_sog_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_a_pos_report_sog_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ais_class_a_pos_report_communication_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_a_pos_report_communication_state_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_a_pos_report_communication_state_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_class_a_pos_report_ais_transceiver_information_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_a_pos_report_ais_transceiver_information_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_a_pos_report_ais_transceiver_information_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_class_a_pos_report_true_heading_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_a_pos_report_true_heading_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_a_pos_report_true_heading_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_ais_class_a_pos_report_rate_of_turn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_a_pos_report_rate_of_turn_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_a_pos_report_rate_of_turn_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_class_a_pos_report_navigational_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_a_pos_report_navigational_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_a_pos_report_navigational_status_is_in_range(uint8_t value);

/**
 * Pack message AISBinaryBroadcastMsg.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_ais_binary_broadcast_msg_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_ais_binary_broadcast_msg_t *src_p,
    size_t size);

/**
 * Unpack message AISBinaryBroadcastMsg.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_ais_binary_broadcast_msg_unpack(
    struct nmea2000_exxo_ais_binary_broadcast_msg_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AISBinaryBroadcastMsg.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_ais_binary_broadcast_msg_init(struct nmea2000_exxo_ais_binary_broadcast_msg_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_binary_broadcast_msg_msg_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_binary_broadcast_msg_msg_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_binary_broadcast_msg_msg_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_binary_broadcast_msg_repeat_indicator_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_binary_broadcast_msg_repeat_indicator_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_binary_broadcast_msg_repeat_indicator_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ais_binary_broadcast_msg_source_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_binary_broadcast_msg_source_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_binary_broadcast_msg_source_id_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_binary_broadcast_msg_ais_transceiver_information_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_binary_broadcast_msg_ais_transceiver_information_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_binary_broadcast_msg_ais_transceiver_information_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_binary_broadcast_msg_number_of_bits_in_binary_data_field_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_binary_broadcast_msg_number_of_bits_in_binary_data_field_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_binary_broadcast_msg_number_of_bits_in_binary_data_field_is_in_range(uint16_t value);

/**
 * Pack message AISAssignmentModeCmd.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_ais_assignment_mode_cmd_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_ais_assignment_mode_cmd_t *src_p,
    size_t size);

/**
 * Unpack message AISAssignmentModeCmd.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_ais_assignment_mode_cmd_unpack(
    struct nmea2000_exxo_ais_assignment_mode_cmd_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AISAssignmentModeCmd.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_ais_assignment_mode_cmd_init(struct nmea2000_exxo_ais_assignment_mode_cmd_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_assignment_mode_cmd_msg_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_assignment_mode_cmd_msg_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_assignment_mode_cmd_msg_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_assignment_mode_cmd_repeat_indicator_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_assignment_mode_cmd_repeat_indicator_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_assignment_mode_cmd_repeat_indicator_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ais_assignment_mode_cmd_source_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_assignment_mode_cmd_source_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_assignment_mode_cmd_source_id_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_assignment_mode_cmd_ais_transceiver_information_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_assignment_mode_cmd_ais_transceiver_information_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_assignment_mode_cmd_ais_transceiver_information_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ais_assignment_mode_cmd_destination_ida_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_assignment_mode_cmd_destination_ida_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_assignment_mode_cmd_destination_ida_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_assignment_mode_cmd_offset_a_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_assignment_mode_cmd_offset_a_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_assignment_mode_cmd_offset_a_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_assignment_mode_cmd_increment_a_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_assignment_mode_cmd_increment_a_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_assignment_mode_cmd_increment_a_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ais_assignment_mode_cmd_destination_idb_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_assignment_mode_cmd_destination_idb_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_assignment_mode_cmd_destination_idb_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_assignment_mode_cmd_offset_b_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_assignment_mode_cmd_offset_b_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_assignment_mode_cmd_offset_b_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_assignment_mode_cmd_increment_b_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_assignment_mode_cmd_increment_b_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_assignment_mode_cmd_increment_b_is_in_range(uint16_t value);

/**
 * Pack message ACKM.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_ackm_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_ackm_t *src_p,
    size_t size);

/**
 * Unpack message ACKM.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_ackm_unpack(
    struct nmea2000_exxo_ackm_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ACKM.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_ackm_init(struct nmea2000_exxo_ackm_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ackm_control_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ackm_control_byte_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ackm_control_byte_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ackm_group_function_value_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ackm_group_function_value_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ackm_group_function_value_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ackm_address_busy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ackm_address_busy_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ackm_address_busy_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ackm_address_access_denied_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ackm_address_access_denied_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ackm_address_access_denied_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ackm_address_negative_acknowledgement_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ackm_address_negative_acknowledgement_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ackm_address_negative_acknowledgement_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ackm_address_acknowledged_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ackm_address_acknowledged_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ackm_address_acknowledged_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ackm_parameter_group_number_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ackm_parameter_group_number_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ackm_parameter_group_number_is_in_range(uint32_t value);

/**
 * Pack message DirectionData.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_direction_data_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_direction_data_t *src_p,
    size_t size);

/**
 * Unpack message DirectionData.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_direction_data_unpack(
    struct nmea2000_exxo_direction_data_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DirectionData.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_direction_data_init(struct nmea2000_exxo_direction_data_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_direction_data_data_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_direction_data_data_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_direction_data_data_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_direction_data_set_cog_heading_ref_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_direction_data_set_cog_heading_ref_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_direction_data_set_cog_heading_ref_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_direction_data_sid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_direction_data_sid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_direction_data_sid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_direction_data_course_over_ground_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_direction_data_course_over_ground_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_direction_data_course_over_ground_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_direction_data_speed_over_ground_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_direction_data_speed_over_ground_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_direction_data_speed_over_ground_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_direction_data_heading_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_direction_data_heading_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_direction_data_heading_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_direction_data_speed_through_water_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_direction_data_speed_through_water_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_direction_data_speed_through_water_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_direction_data_set_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_direction_data_set_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_direction_data_set_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_direction_data_drift_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_direction_data_drift_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_direction_data_drift_is_in_range(uint16_t value);

/**
 * Pack message Datum.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_datum_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_datum_t *src_p,
    size_t size);

/**
 * Unpack message Datum.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_datum_unpack(
    struct nmea2000_exxo_datum_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Datum.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_datum_init(struct nmea2000_exxo_datum_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_datum_local_datum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_datum_local_datum_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_datum_local_datum_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_datum_reference_datum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_datum_reference_datum_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_datum_reference_datum_is_in_range(uint32_t value);

/**
 * Pack message DSCCallInformation.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_dsc_call_information_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_dsc_call_information_t *src_p,
    size_t size);

/**
 * Unpack message DSCCallInformation.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_dsc_call_information_unpack(
    struct nmea2000_exxo_dsc_call_information_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DSCCallInformation.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_dsc_call_information_init(struct nmea2000_exxo_dsc_call_information_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_dsc_call_information_dsc_format_symbol_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_dsc_call_information_dsc_format_symbol_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_dsc_call_information_dsc_format_symbol_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_dsc_call_information_dsc_category_symbol_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_dsc_call_information_dsc_category_symbol_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_dsc_call_information_dsc_category_symbol_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t nmea2000_exxo_dsc_call_information_dsc_msg_address_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_dsc_call_information_dsc_msg_address_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_dsc_call_information_dsc_msg_address_is_in_range(uint64_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t nmea2000_exxo_dsc_call_information_proposed_rx_frequency_channel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_dsc_call_information_proposed_rx_frequency_channel_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_dsc_call_information_proposed_rx_frequency_channel_is_in_range(uint64_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t nmea2000_exxo_dsc_call_information_proposed_tx_frequency_channel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_dsc_call_information_proposed_tx_frequency_channel_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_dsc_call_information_proposed_tx_frequency_channel_is_in_range(uint64_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_dsc_call_information_telephone_number_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_dsc_call_information_telephone_number_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_dsc_call_information_telephone_number_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t nmea2000_exxo_dsc_call_information_mmsi_of_ship_in_distress_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_dsc_call_information_mmsi_of_ship_in_distress_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_dsc_call_information_mmsi_of_ship_in_distress_is_in_range(uint64_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t nmea2000_exxo_dsc_call_information_calling_rx_frequency_channel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_dsc_call_information_calling_rx_frequency_channel_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_dsc_call_information_calling_rx_frequency_channel_is_in_range(uint64_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t nmea2000_exxo_dsc_call_information_calling_tx_frequency_channel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_dsc_call_information_calling_tx_frequency_channel_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_dsc_call_information_calling_tx_frequency_channel_is_in_range(uint64_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_dsc_call_information_dsc_expansion_field_data_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_dsc_call_information_dsc_expansion_field_data_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_dsc_call_information_dsc_expansion_field_data_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_dsc_call_information_var_nbr_of_flds_fld22_rep_exp_fld_data_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_dsc_call_information_var_nbr_of_flds_fld22_rep_exp_fld_data_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_dsc_call_information_var_nbr_of_flds_fld22_rep_exp_fld_data_is_in_range(uint16_t value);

/**
 * Pack message DGNSSCorrections.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_dgnss_corrections_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_dgnss_corrections_t *src_p,
    size_t size);

/**
 * Unpack message DGNSSCorrections.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_dgnss_corrections_unpack(
    struct nmea2000_exxo_dgnss_corrections_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DGNSSCorrections.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_dgnss_corrections_init(struct nmea2000_exxo_dgnss_corrections_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_dgnss_corrections_sequence_id__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_dgnss_corrections_sequence_id__decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_dgnss_corrections_sequence_id__is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_dgnss_corrections_reference_station_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_dgnss_corrections_reference_station_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_dgnss_corrections_reference_station_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_dgnss_corrections_reference_station_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_dgnss_corrections_reference_station_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_dgnss_corrections_reference_station_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_dgnss_corrections_time_of_corrections_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_dgnss_corrections_time_of_corrections_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_dgnss_corrections_time_of_corrections_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_dgnss_corrections_station_health_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_dgnss_corrections_station_health_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_dgnss_corrections_station_health_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_dgnss_corrections_satellite_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_dgnss_corrections_satellite_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_dgnss_corrections_satellite_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_dgnss_corrections_prc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_dgnss_corrections_prc_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_dgnss_corrections_prc_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_dgnss_corrections_rrc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_dgnss_corrections_rrc_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_dgnss_corrections_rrc_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_dgnss_corrections_udre_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_dgnss_corrections_udre_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_dgnss_corrections_udre_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_dgnss_corrections_iod_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_dgnss_corrections_iod_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_dgnss_corrections_iod_is_in_range(uint8_t value);

/**
 * Pack message CurrentStationData.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_current_station_data_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_current_station_data_t *src_p,
    size_t size);

/**
 * Unpack message CurrentStationData.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_current_station_data_unpack(
    struct nmea2000_exxo_current_station_data_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from CurrentStationData.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_current_station_data_init(struct nmea2000_exxo_current_station_data_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_current_station_data_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_current_station_data_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_current_station_data_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_current_station_data_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_current_station_data_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_current_station_data_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_current_station_data_measurement_date_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_current_station_data_measurement_date_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_current_station_data_measurement_date_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_current_station_data_measurement_time_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_current_station_data_measurement_time_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_current_station_data_measurement_time_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_current_station_data_station_location_latitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_current_station_data_station_location_latitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_current_station_data_station_location_latitude_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_current_station_data_station_location_longitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_current_station_data_station_location_longitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_current_station_data_station_location_longitude_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_current_station_data_measurement_depth_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_current_station_data_measurement_depth_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_current_station_data_measurement_depth_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_current_station_data_current_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_current_station_data_current_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_current_station_data_current_speed_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_current_station_data_current_flow_direction_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_current_station_data_current_flow_direction_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_current_station_data_current_flow_direction_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_current_station_data_water_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_current_station_data_water_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_current_station_data_water_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_current_station_data_station_id_string_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_current_station_data_station_id_string_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_current_station_data_station_id_string_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_current_station_data_station_name_string_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_current_station_data_station_name_string_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_current_station_data_station_name_string_is_in_range(uint16_t value);

/**
 * Pack message CrossTrackError.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_cross_track_error_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_cross_track_error_t *src_p,
    size_t size);

/**
 * Unpack message CrossTrackError.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_cross_track_error_unpack(
    struct nmea2000_exxo_cross_track_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from CrossTrackError.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_cross_track_error_init(struct nmea2000_exxo_cross_track_error_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_cross_track_error_sid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_cross_track_error_sid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_cross_track_error_sid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_cross_track_error_xte_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_cross_track_error_xte_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_cross_track_error_xte_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_cross_track_error_navigation_terminated_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_cross_track_error_navigation_terminated_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_cross_track_error_navigation_terminated_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_cross_track_error_xte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_cross_track_error_xte_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_cross_track_error_xte_is_in_range(int32_t value);

/**
 * Pack message COGSOGRapidUpdate.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_cogsog_rapid_update_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_cogsog_rapid_update_t *src_p,
    size_t size);

/**
 * Unpack message COGSOGRapidUpdate.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_cogsog_rapid_update_unpack(
    struct nmea2000_exxo_cogsog_rapid_update_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from COGSOGRapidUpdate.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_cogsog_rapid_update_init(struct nmea2000_exxo_cogsog_rapid_update_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_cogsog_rapid_update_sid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_cogsog_rapid_update_sid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_cogsog_rapid_update_sid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_cogsog_rapid_update_cog_reference_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_cogsog_rapid_update_cog_reference_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_cogsog_rapid_update_cog_reference_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_cogsog_rapid_update_course_over_ground_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_cogsog_rapid_update_course_over_ground_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_cogsog_rapid_update_course_over_ground_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_cogsog_rapid_update_speed_over_ground_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_cogsog_rapid_update_speed_over_ground_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_cogsog_rapid_update_speed_over_ground_is_in_range(uint16_t value);

/**
 * Pack message AISAddressedSafetyRelatedMsg.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_ais_addressed_safety_related_msg_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_ais_addressed_safety_related_msg_t *src_p,
    size_t size);

/**
 * Unpack message AISAddressedSafetyRelatedMsg.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_ais_addressed_safety_related_msg_unpack(
    struct nmea2000_exxo_ais_addressed_safety_related_msg_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AISAddressedSafetyRelatedMsg.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_ais_addressed_safety_related_msg_init(struct nmea2000_exxo_ais_addressed_safety_related_msg_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_addressed_safety_related_msg_msg_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_addressed_safety_related_msg_msg_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_addressed_safety_related_msg_msg_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_addressed_safety_related_msg_repeat_indicator_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_addressed_safety_related_msg_repeat_indicator_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_addressed_safety_related_msg_repeat_indicator_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ais_addressed_safety_related_msg_source_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_addressed_safety_related_msg_source_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_addressed_safety_related_msg_source_id_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_addressed_safety_related_msg_ais_transceiver_information_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_addressed_safety_related_msg_ais_transceiver_information_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_addressed_safety_related_msg_ais_transceiver_information_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_addressed_safety_related_msg_sequence_number__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_addressed_safety_related_msg_sequence_number__decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_addressed_safety_related_msg_sequence_number__is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ais_addressed_safety_related_msg_destination_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_addressed_safety_related_msg_destination_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_addressed_safety_related_msg_destination_id_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_addressed_safety_related_msg_retransmit_flag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_addressed_safety_related_msg_retransmit_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_addressed_safety_related_msg_retransmit_flag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_addressed_safety_related_msg_safety_related_text_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_addressed_safety_related_msg_safety_related_text_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_addressed_safety_related_msg_safety_related_text_is_in_range(uint16_t value);

/**
 * Pack message AISAddressedBinaryMsg.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_ais_addressed_binary_msg_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_ais_addressed_binary_msg_t *src_p,
    size_t size);

/**
 * Unpack message AISAddressedBinaryMsg.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_ais_addressed_binary_msg_unpack(
    struct nmea2000_exxo_ais_addressed_binary_msg_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AISAddressedBinaryMsg.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_ais_addressed_binary_msg_init(struct nmea2000_exxo_ais_addressed_binary_msg_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_addressed_binary_msg_msg_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_addressed_binary_msg_msg_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_addressed_binary_msg_msg_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_addressed_binary_msg_repeat_indicator_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_addressed_binary_msg_repeat_indicator_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_addressed_binary_msg_repeat_indicator_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ais_addressed_binary_msg_source_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_addressed_binary_msg_source_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_addressed_binary_msg_source_id_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_addressed_binary_msg_ais_transceiver_information_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_addressed_binary_msg_ais_transceiver_information_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_addressed_binary_msg_ais_transceiver_information_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_addressed_binary_msg_sequence_number__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_addressed_binary_msg_sequence_number__decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_addressed_binary_msg_sequence_number__is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ais_addressed_binary_msg_destination_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_addressed_binary_msg_destination_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_addressed_binary_msg_destination_id_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_addressed_binary_msg_retransmit_flag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_addressed_binary_msg_retransmit_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_addressed_binary_msg_retransmit_flag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_addressed_binary_msg_number_of_bits_in_binary_data_field_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_addressed_binary_msg_number_of_bits_in_binary_data_field_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_addressed_binary_msg_number_of_bits_in_binary_data_field_is_in_range(uint16_t value);

/**
 * Pack message AISAcknowledge.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_ais_acknowledge_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_ais_acknowledge_t *src_p,
    size_t size);

/**
 * Unpack message AISAcknowledge.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_ais_acknowledge_unpack(
    struct nmea2000_exxo_ais_acknowledge_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AISAcknowledge.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_ais_acknowledge_init(struct nmea2000_exxo_ais_acknowledge_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_acknowledge_msg_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_acknowledge_msg_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_acknowledge_msg_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_acknowledge_repeat_indicator_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_acknowledge_repeat_indicator_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_acknowledge_repeat_indicator_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ais_acknowledge_source_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_acknowledge_source_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_acknowledge_source_id_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_acknowledge_ais_transceiver_information_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_acknowledge_ais_transceiver_information_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_acknowledge_ais_transceiver_information_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ais_acknowledge_destination_id1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_acknowledge_destination_id1_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_acknowledge_destination_id1_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_acknowledge_sequence_number_for_id1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_acknowledge_sequence_number_for_id1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_acknowledge_sequence_number_for_id1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_acknowledge_sequence_number_for_i_dn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_acknowledge_sequence_number_for_i_dn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_acknowledge_sequence_number_for_i_dn_is_in_range(uint8_t value);

/**
 * Pack message AC_Input_Status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_ac_input_status_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_ac_input_status_t *src_p,
    size_t size);

/**
 * Unpack message AC_Input_Status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_ac_input_status_unpack(
    struct nmea2000_exxo_ac_input_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AC_Input_Status.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_ac_input_status_init(struct nmea2000_exxo_ac_input_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ac_input_status_ac_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ac_input_status_ac_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ac_input_status_ac_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ac_input_status_number_of_lines_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ac_input_status_number_of_lines_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ac_input_status_number_of_lines_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ac_input_status_line_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ac_input_status_line_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ac_input_status_line_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ac_input_status_acceptability_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ac_input_status_acceptability_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ac_input_status_acceptability_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_ac_input_status_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ac_input_status_voltage_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ac_input_status_voltage_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ac_input_status_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ac_input_status_current_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ac_input_status_current_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ac_input_status_frequency_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ac_input_status_frequency_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ac_input_status_frequency_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ac_input_status_breaker_size_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ac_input_status_breaker_size_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ac_input_status_breaker_size_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ac_input_status_real_power_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ac_input_status_real_power_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ac_input_status_real_power_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ac_input_status_reactive_power_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ac_input_status_reactive_power_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ac_input_status_reactive_power_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t nmea2000_exxo_ac_input_status_power_factor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ac_input_status_power_factor_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ac_input_status_power_factor_is_in_range(int8_t value);

/**
 * Pack message AC_Output_Status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_ac_output_status_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_ac_output_status_t *src_p,
    size_t size);

/**
 * Unpack message AC_Output_Status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_ac_output_status_unpack(
    struct nmea2000_exxo_ac_output_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AC_Output_Status.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_ac_output_status_init(struct nmea2000_exxo_ac_output_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ac_output_status_ac_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ac_output_status_ac_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ac_output_status_ac_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ac_output_status_number_of_lines_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ac_output_status_number_of_lines_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ac_output_status_number_of_lines_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ac_output_status_line_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ac_output_status_line_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ac_output_status_line_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ac_output_status_waveform_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ac_output_status_waveform_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ac_output_status_waveform_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_ac_output_status_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ac_output_status_voltage_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ac_output_status_voltage_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ac_output_status_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ac_output_status_current_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ac_output_status_current_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ac_output_status_frequency_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ac_output_status_frequency_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ac_output_status_frequency_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ac_output_status_breaker_size_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ac_output_status_breaker_size_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ac_output_status_breaker_size_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ac_output_status_real_power_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ac_output_status_real_power_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ac_output_status_real_power_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ac_output_status_reactive_power_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ac_output_status_reactive_power_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ac_output_status_reactive_power_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t nmea2000_exxo_ac_output_status_power_factor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ac_output_status_power_factor_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ac_output_status_power_factor_is_in_range(int8_t value);

/**
 * Pack message DC_Detailed_Status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_dc_detailed_status_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_dc_detailed_status_t *src_p,
    size_t size);

/**
 * Unpack message DC_Detailed_Status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_dc_detailed_status_unpack(
    struct nmea2000_exxo_dc_detailed_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DC_Detailed_Status.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_dc_detailed_status_init(struct nmea2000_exxo_dc_detailed_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_dc_detailed_status_sid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_dc_detailed_status_sid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_dc_detailed_status_sid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_dc_detailed_status_dc_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_dc_detailed_status_dc_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_dc_detailed_status_dc_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_dc_detailed_status_dc_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_dc_detailed_status_dc_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_dc_detailed_status_dc_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_dc_detailed_status_state_of_charge_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_dc_detailed_status_state_of_charge_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_dc_detailed_status_state_of_charge_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_dc_detailed_status_state_of_health_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_dc_detailed_status_state_of_health_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_dc_detailed_status_state_of_health_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_dc_detailed_status_time_remaining_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_dc_detailed_status_time_remaining_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_dc_detailed_status_time_remaining_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_dc_detailed_status_ripple_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_dc_detailed_status_ripple_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_dc_detailed_status_ripple_voltage_is_in_range(uint16_t value);

/**
 * Pack message Charger_Status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_charger_status_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_charger_status_t *src_p,
    size_t size);

/**
 * Unpack message Charger_Status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_charger_status_unpack(
    struct nmea2000_exxo_charger_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Charger_Status.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_charger_status_init(struct nmea2000_exxo_charger_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_charger_status_charger_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_charger_status_charger_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_charger_status_charger_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_charger_status_battery_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_charger_status_battery_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_charger_status_battery_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_charger_status_operating_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_charger_status_operating_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_charger_status_operating_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_charger_status_charge_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_charger_status_charge_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_charger_status_charge_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_charger_status_charger_enable_disable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_charger_status_charger_enable_disable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_charger_status_charger_enable_disable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_charger_status_equalization_pending_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_charger_status_equalization_pending_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_charger_status_equalization_pending_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_charger_status_equalization_time_remaining_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_charger_status_equalization_time_remaining_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_charger_status_equalization_time_remaining_is_in_range(uint16_t value);

/**
 * Pack message Inverter_Status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_inverter_status_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_inverter_status_t *src_p,
    size_t size);

/**
 * Unpack message Inverter_Status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_inverter_status_unpack(
    struct nmea2000_exxo_inverter_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Inverter_Status.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_inverter_status_init(struct nmea2000_exxo_inverter_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_inverter_status_inverter_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_inverter_status_inverter_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_inverter_status_inverter_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_inverter_status_ac_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_inverter_status_ac_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_inverter_status_ac_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_inverter_status_dc_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_inverter_status_dc_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_inverter_status_dc_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_inverter_status_operating_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_inverter_status_operating_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_inverter_status_operating_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_inverter_status_inverter_enable_disable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_inverter_status_inverter_enable_disable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_inverter_status_inverter_enable_disable_is_in_range(uint8_t value);

/**
 * Pack message Charger_Configuration_Status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_charger_configuration_status_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_charger_configuration_status_t *src_p,
    size_t size);

/**
 * Unpack message Charger_Configuration_Status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_charger_configuration_status_unpack(
    struct nmea2000_exxo_charger_configuration_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Charger_Configuration_Status.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_charger_configuration_status_init(struct nmea2000_exxo_charger_configuration_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_charger_configuration_status_charger_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_charger_configuration_status_charger_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_charger_configuration_status_charger_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_charger_configuration_status_battery_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_charger_configuration_status_battery_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_charger_configuration_status_battery_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_charger_configuration_status_charger_enable_disable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_charger_configuration_status_charger_enable_disable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_charger_configuration_status_charger_enable_disable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_charger_configuration_status_charge_current_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_charger_configuration_status_charge_current_limit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_charger_configuration_status_charge_current_limit_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_charger_configuration_status_charging_algorithm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_charger_configuration_status_charging_algorithm_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_charger_configuration_status_charging_algorithm_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_charger_configuration_status_charger_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_charger_configuration_status_charger_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_charger_configuration_status_charger_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_charger_configuration_status_estimated_battery_temp_when_no_sensor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_charger_configuration_status_estimated_battery_temp_when_no_sensor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_charger_configuration_status_estimated_battery_temp_when_no_sensor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_charger_configuration_status_equalize_one_time_enable_disable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_charger_configuration_status_equalize_one_time_enable_disable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_charger_configuration_status_equalize_one_time_enable_disable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_charger_configuration_status_over_charge_enable_disable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_charger_configuration_status_over_charge_enable_disable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_charger_configuration_status_over_charge_enable_disable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_charger_configuration_status_equalize_time_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_charger_configuration_status_equalize_time_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_charger_configuration_status_equalize_time_is_in_range(uint16_t value);

/**
 * Pack message Inverter_Configuration_Status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_inverter_configuration_status_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_inverter_configuration_status_t *src_p,
    size_t size);

/**
 * Unpack message Inverter_Configuration_Status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_inverter_configuration_status_unpack(
    struct nmea2000_exxo_inverter_configuration_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Inverter_Configuration_Status.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_inverter_configuration_status_init(struct nmea2000_exxo_inverter_configuration_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_inverter_configuration_status_inverter_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_inverter_configuration_status_inverter_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_inverter_configuration_status_inverter_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_inverter_configuration_status_ac_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_inverter_configuration_status_ac_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_inverter_configuration_status_ac_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_inverter_configuration_status_dc_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_inverter_configuration_status_dc_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_inverter_configuration_status_dc_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_inverter_configuration_status_inverter_enable_disable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_inverter_configuration_status_inverter_enable_disable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_inverter_configuration_status_inverter_enable_disable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_inverter_configuration_status_inverter_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_inverter_configuration_status_inverter_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_inverter_configuration_status_inverter_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_inverter_configuration_status_load_sense_enable_disable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_inverter_configuration_status_load_sense_enable_disable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_inverter_configuration_status_load_sense_enable_disable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_inverter_configuration_status_load_sense_power_threshold_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_inverter_configuration_status_load_sense_power_threshold_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_inverter_configuration_status_load_sense_power_threshold_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_inverter_configuration_status_load_sense_interval_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_inverter_configuration_status_load_sense_interval_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_inverter_configuration_status_load_sense_interval_is_in_range(uint16_t value);

/**
 * Pack message AGS_Configuration_Status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_ags_configuration_status_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_ags_configuration_status_t *src_p,
    size_t size);

/**
 * Unpack message AGS_Configuration_Status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_ags_configuration_status_unpack(
    struct nmea2000_exxo_ags_configuration_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AGS_Configuration_Status.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_ags_configuration_status_init(struct nmea2000_exxo_ags_configuration_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ags_configuration_status_ags_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ags_configuration_status_ags_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ags_configuration_status_ags_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ags_configuration_status_generator_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ags_configuration_status_generator_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ags_configuration_status_generator_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ags_configuration_status_ags_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ags_configuration_status_ags_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ags_configuration_status_ags_mode_is_in_range(uint8_t value);

/**
 * Pack message Battery_Configuration_Status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_battery_configuration_status_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_battery_configuration_status_t *src_p,
    size_t size);

/**
 * Unpack message Battery_Configuration_Status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_battery_configuration_status_unpack(
    struct nmea2000_exxo_battery_configuration_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Battery_Configuration_Status.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_battery_configuration_status_init(struct nmea2000_exxo_battery_configuration_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_battery_configuration_status_battery_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_battery_configuration_status_battery_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_battery_configuration_status_battery_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_battery_configuration_status_battery_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_battery_configuration_status_battery_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_battery_configuration_status_battery_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_battery_configuration_status_support_equalization_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_battery_configuration_status_support_equalization_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_battery_configuration_status_support_equalization_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_battery_configuration_status_nominal_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_battery_configuration_status_nominal_voltage_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_battery_configuration_status_nominal_voltage_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_battery_configuration_status_battery_chemistry_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_battery_configuration_status_battery_chemistry_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_battery_configuration_status_battery_chemistry_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_battery_configuration_status_battery_capacity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_battery_configuration_status_battery_capacity_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_battery_configuration_status_battery_capacity_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t nmea2000_exxo_battery_configuration_status_battery_temperature_coefficient_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_battery_configuration_status_battery_temperature_coefficient_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_battery_configuration_status_battery_temperature_coefficient_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_battery_configuration_status_peukert_exponent_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_battery_configuration_status_peukert_exponent_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_battery_configuration_status_peukert_exponent_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t nmea2000_exxo_battery_configuration_status_charge_efficiency_factor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_battery_configuration_status_charge_efficiency_factor_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_battery_configuration_status_charge_efficiency_factor_is_in_range(int8_t value);

/**
 * Pack message AGS_Status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_ags_status_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_ags_status_t *src_p,
    size_t size);

/**
 * Unpack message AGS_Status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_ags_status_unpack(
    struct nmea2000_exxo_ags_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AGS_Status.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_ags_status_init(struct nmea2000_exxo_ags_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ags_status_ags_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ags_status_ags_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ags_status_ags_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ags_status_generator_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ags_status_generator_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ags_status_generator_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ags_status_ags_operating_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ags_status_ags_operating_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ags_status_ags_operating_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ags_status_generator_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ags_status_generator_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ags_status_generator_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ags_status_generator_on_reason_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ags_status_generator_on_reason_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ags_status_generator_on_reason_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ags_status_generator_off_reason_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ags_status_generator_off_reason_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ags_status_generator_off_reason_is_in_range(uint8_t value);

/**
 * Pack message AIS_Channel_Management.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_ais_channel_management_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_ais_channel_management_t *src_p,
    size_t size);

/**
 * Unpack message AIS_Channel_Management.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_ais_channel_management_unpack(
    struct nmea2000_exxo_ais_channel_management_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AIS_Channel_Management.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_ais_channel_management_init(struct nmea2000_exxo_ais_channel_management_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_channel_management_message_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_channel_management_message_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_channel_management_message_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_channel_management_repeat_indicator_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_channel_management_repeat_indicator_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_channel_management_repeat_indicator_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ais_channel_management_station_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_channel_management_station_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_channel_management_station_id_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_channel_management_ais_transceiver_information_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_channel_management_ais_transceiver_information_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_channel_management_ais_transceiver_information_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_channel_management_channel_a_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_channel_management_channel_a_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_channel_management_channel_a_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_channel_management_channel_b_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_channel_management_channel_b_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_channel_management_channel_b_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_channel_management_power_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_channel_management_power_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_channel_management_power_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_channel_management_tx_rx_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_channel_management_tx_rx_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_channel_management_tx_rx_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_ais_channel_management_north_east_longitude_corner_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_channel_management_north_east_longitude_corner_1_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_channel_management_north_east_longitude_corner_1_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_ais_channel_management_north_east_latitude_corner_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_channel_management_north_east_latitude_corner_1_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_channel_management_north_east_latitude_corner_1_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_ais_channel_management_south_west_longitude_corner_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_channel_management_south_west_longitude_corner_2_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_channel_management_south_west_longitude_corner_2_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_ais_channel_management_south_west_latitude_corner_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_channel_management_south_west_latitude_corner_2_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_channel_management_south_west_latitude_corner_2_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_channel_management_addressed_or_broadcast_message_indicator_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_channel_management_addressed_or_broadcast_message_indicator_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_channel_management_addressed_or_broadcast_message_indicator_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_channel_management_channel_a_bandwidth_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_channel_management_channel_a_bandwidth_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_channel_management_channel_a_bandwidth_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_channel_management_channel_b_bandwidth_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_channel_management_channel_b_bandwidth_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_channel_management_channel_b_bandwidth_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_channel_management_transitional_zone_site_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_channel_management_transitional_zone_site_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_channel_management_transitional_zone_site_is_in_range(uint8_t value);

/**
 * Pack message AIS_Class_B_Group_Assignment.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_ais_class_b_group_assignment_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_ais_class_b_group_assignment_t *src_p,
    size_t size);

/**
 * Unpack message AIS_Class_B_Group_Assignment.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_ais_class_b_group_assignment_unpack(
    struct nmea2000_exxo_ais_class_b_group_assignment_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AIS_Class_B_Group_Assignment.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_ais_class_b_group_assignment_init(struct nmea2000_exxo_ais_class_b_group_assignment_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_class_b_group_assignment_message_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_group_assignment_message_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_group_assignment_message_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_class_b_group_assignment_repeat_indicator_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_group_assignment_repeat_indicator_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_group_assignment_repeat_indicator_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ais_class_b_group_assignment_source_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_group_assignment_source_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_group_assignment_source_id_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_class_b_group_assignment_tx_rx_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_group_assignment_tx_rx_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_group_assignment_tx_rx_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_ais_class_b_group_assignment_north_east_longitude_corner_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_group_assignment_north_east_longitude_corner_1_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_group_assignment_north_east_longitude_corner_1_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_ais_class_b_group_assignment_north_east_latitude_corner_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_group_assignment_north_east_latitude_corner_1_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_group_assignment_north_east_latitude_corner_1_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_ais_class_b_group_assignment_south_west_longitude_corner_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_group_assignment_south_west_longitude_corner_2_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_group_assignment_south_west_longitude_corner_2_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_ais_class_b_group_assignment_south_west_latitude_corner_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_group_assignment_south_west_latitude_corner_2_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_group_assignment_south_west_latitude_corner_2_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_class_b_group_assignment_station_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_group_assignment_station_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_group_assignment_station_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_class_b_group_assignment_ship_and_cargo_filter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_group_assignment_ship_and_cargo_filter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_group_assignment_ship_and_cargo_filter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_class_b_group_assignment_reporting_interval_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_group_assignment_reporting_interval_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_group_assignment_reporting_interval_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_class_b_group_assignment_quiet_time_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_group_assignment_quiet_time_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_group_assignment_quiet_time_is_in_range(uint8_t value);

/**
 * Pack message AIS_Class_B_CS_Static_Data_Report_Part_A.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_ais_class_b_cs_static_data_report_part_a_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_ais_class_b_cs_static_data_report_part_a_t *src_p,
    size_t size);

/**
 * Unpack message AIS_Class_B_CS_Static_Data_Report_Part_A.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_ais_class_b_cs_static_data_report_part_a_unpack(
    struct nmea2000_exxo_ais_class_b_cs_static_data_report_part_a_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AIS_Class_B_CS_Static_Data_Report_Part_A.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_ais_class_b_cs_static_data_report_part_a_init(struct nmea2000_exxo_ais_class_b_cs_static_data_report_part_a_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_class_b_cs_static_data_report_part_a_message_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_cs_static_data_report_part_a_message_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_cs_static_data_report_part_a_message_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_class_b_cs_static_data_report_part_a_repeat_indicator_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_cs_static_data_report_part_a_repeat_indicator_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_cs_static_data_report_part_a_repeat_indicator_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ais_class_b_cs_static_data_report_part_a_user_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_cs_static_data_report_part_a_user_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_cs_static_data_report_part_a_user_id_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t nmea2000_exxo_ais_class_b_cs_static_data_report_part_a_name_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_cs_static_data_report_part_a_name_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_cs_static_data_report_part_a_name_is_in_range(uint64_t value);

/**
 * Pack message AIS_Class_B_CS_Static_Data_Report_Part_B.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_t *src_p,
    size_t size);

/**
 * Unpack message AIS_Class_B_CS_Static_Data_Report_Part_B.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_unpack(
    struct nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AIS_Class_B_CS_Static_Data_Report_Part_B.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_init(struct nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_message_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_message_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_message_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_repeat_indicator_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_repeat_indicator_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_repeat_indicator_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_user_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_user_id_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_user_id_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_type_of_ship_and_cargo_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_type_of_ship_and_cargo_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_type_of_ship_and_cargo_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_vendor_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_vendor_id_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_vendor_id_is_in_range(uint64_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_call_sign_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_call_sign_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_call_sign_is_in_range(uint64_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_ship_length_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_ship_length_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_ship_length_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_ship_beam_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_ship_beam_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_ship_beam_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_reference_point_position_from_starboard_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_reference_point_position_from_starboard_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_reference_point_position_from_starboard_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_reference_point_position_aft_of_bow_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_reference_point_position_aft_of_bow_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_reference_point_position_aft_of_bow_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_mother_ship_mmsi_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_mother_ship_mmsi_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_ais_class_b_cs_static_data_report_part_b_mother_ship_mmsi_is_in_range(uint32_t value);

/**
 * Pack message Temperature.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_temperature_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_temperature_t *src_p,
    size_t size);

/**
 * Unpack message Temperature.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_temperature_unpack(
    struct nmea2000_exxo_temperature_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Temperature.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_temperature_init(struct nmea2000_exxo_temperature_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_temperature_sid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_temperature_sid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_temperature_sid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_temperature_temperature_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_temperature_temperature_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_temperature_temperature_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_temperature_temperature_source_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_temperature_temperature_source_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_temperature_temperature_source_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_temperature_actual_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_temperature_actual_temperature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_temperature_actual_temperature_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_temperature_set_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_temperature_set_temperature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_temperature_set_temperature_is_in_range(uint16_t value);

/**
 * Pack message Humidity.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_humidity_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_humidity_t *src_p,
    size_t size);

/**
 * Unpack message Humidity.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_humidity_unpack(
    struct nmea2000_exxo_humidity_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Humidity.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_humidity_init(struct nmea2000_exxo_humidity_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_humidity_sid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_humidity_sid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_humidity_sid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_humidity_humidity_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_humidity_humidity_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_humidity_humidity_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_humidity_humidity_source_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_humidity_humidity_source_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_humidity_humidity_source_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_humidity_actual_humidity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_humidity_actual_humidity_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_humidity_actual_humidity_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_humidity_set_humidity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_humidity_set_humidity_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_humidity_set_humidity_is_in_range(uint16_t value);

/**
 * Pack message Actual_Pressure.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_actual_pressure_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_actual_pressure_t *src_p,
    size_t size);

/**
 * Unpack message Actual_Pressure.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_actual_pressure_unpack(
    struct nmea2000_exxo_actual_pressure_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Actual_Pressure.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_actual_pressure_init(struct nmea2000_exxo_actual_pressure_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_actual_pressure_sid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_actual_pressure_sid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_actual_pressure_sid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_actual_pressure_pressure_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_actual_pressure_pressure_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_actual_pressure_pressure_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_actual_pressure_pressure_source_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_actual_pressure_pressure_source_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_actual_pressure_pressure_source_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_actual_pressure_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_actual_pressure_pressure_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_actual_pressure_pressure_is_in_range(int32_t value);

/**
 * Pack message Set_Pressure.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_set_pressure_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_set_pressure_t *src_p,
    size_t size);

/**
 * Unpack message Set_Pressure.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_set_pressure_unpack(
    struct nmea2000_exxo_set_pressure_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Set_Pressure.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_set_pressure_init(struct nmea2000_exxo_set_pressure_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_set_pressure_sid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_set_pressure_sid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_set_pressure_sid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_set_pressure_pressure_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_set_pressure_pressure_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_set_pressure_pressure_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_set_pressure_pressure_source_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_set_pressure_pressure_source_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_set_pressure_pressure_source_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t nmea2000_exxo_set_pressure_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_set_pressure_pressure_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_set_pressure_pressure_is_in_range(int32_t value);

/**
 * Pack message EnvironmentalParameters2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_environmental_parameters2_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_environmental_parameters2_t *src_p,
    size_t size);

/**
 * Unpack message EnvironmentalParameters2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_environmental_parameters2_unpack(
    struct nmea2000_exxo_environmental_parameters2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from EnvironmentalParameters2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_environmental_parameters2_init(struct nmea2000_exxo_environmental_parameters2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_environmental_parameters2_sequence_id__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_environmental_parameters2_sequence_id__decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_environmental_parameters2_sequence_id__is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_environmental_parameters2_temp_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_environmental_parameters2_temp_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_environmental_parameters2_temp_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_environmental_parameters2_humidity_instance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_environmental_parameters2_humidity_instance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_environmental_parameters2_humidity_instance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_environmental_parameters2_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_environmental_parameters2_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_environmental_parameters2_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t nmea2000_exxo_environmental_parameters2_humidity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_environmental_parameters2_humidity_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_environmental_parameters2_humidity_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_environmental_parameters2_atmospheric_press_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_environmental_parameters2_atmospheric_press_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_environmental_parameters2_atmospheric_press_is_in_range(uint16_t value);

/**
 * Pack message ProductInformation.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_product_information_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_product_information_t *src_p,
    size_t size);

/**
 * Unpack message ProductInformation.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_product_information_unpack(
    struct nmea2000_exxo_product_information_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ProductInformation.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_product_information_init(struct nmea2000_exxo_product_information_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_product_information_nmea2000_database_version_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_product_information_nmea2000_database_version_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_product_information_nmea2000_database_version_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t nmea2000_exxo_product_information_nmea_manufacturers_product_code_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_product_information_nmea_manufacturers_product_code_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_product_information_nmea_manufacturers_product_code_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t nmea2000_exxo_product_information_manufacturers_model_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_product_information_manufacturers_model_id_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_product_information_manufacturers_model_id_is_in_range(uint64_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t nmea2000_exxo_product_information_manufacturers_software_version_code_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_product_information_manufacturers_software_version_code_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_product_information_manufacturers_software_version_code_is_in_range(uint64_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t nmea2000_exxo_product_information_manufacturers_model_version_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_product_information_manufacturers_model_version_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_product_information_manufacturers_model_version_is_in_range(uint64_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t nmea2000_exxo_product_information_manufacturers_model_serial_code_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_product_information_manufacturers_model_serial_code_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_product_information_manufacturers_model_serial_code_is_in_range(uint64_t value);

/**
 * Pack message ConfigInformation.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_config_information_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_config_information_t *src_p,
    size_t size);

/**
 * Unpack message ConfigInformation.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_config_information_unpack(
    struct nmea2000_exxo_config_information_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ConfigInformation.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_config_information_init(struct nmea2000_exxo_config_information_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t nmea2000_exxo_config_information_installation_description_field1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_config_information_installation_description_field1_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_config_information_installation_description_field1_is_in_range(uint64_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t nmea2000_exxo_config_information_installation_description_field2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_config_information_installation_description_field2_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_config_information_installation_description_field2_is_in_range(uint64_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t nmea2000_exxo_config_information_manufacturer_information_field3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_config_information_manufacturer_information_field3_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_config_information_manufacturer_information_field3_is_in_range(uint64_t value);

/**
 * Pack message PGNLstTransmitPGNsGroupFunction.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_pack(
    uint8_t *dst_p,
    const struct nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_t *src_p,
    size_t size);

/**
 * Unpack message PGNLstTransmitPGNsGroupFunction.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_unpack(
    struct nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PGNLstTransmitPGNsGroupFunction.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_init(struct nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_grp_fnctn_trnsmt_and_receive_pgn_list_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_grp_fnctn_trnsmt_and_receive_pgn_list_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_grp_fnctn_trnsmt_and_receive_pgn_list_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_first_pgn_supported2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_first_pgn_supported2_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_first_pgn_supported2_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_first_pgn_supported_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_first_pgn_supported_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_first_pgn_supported_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_vrbl_nmbr_of_flds_fld_nmber2_repeated2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_vrbl_nmbr_of_flds_fld_nmber2_repeated2_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_vrbl_nmbr_of_flds_fld_nmber2_repeated2_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_vrbl_nmbr_of_flds_fld_nmber2_repeated_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_vrbl_nmbr_of_flds_fld_nmber2_repeated_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_vrbl_nmbr_of_flds_fld_nmber2_repeated_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_pgn_supported3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_pgn_supported3_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_pgn_supported3_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_pgn_supported3_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_pgn_supported3_2_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_pgn_supported3_2_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_pgn_supported4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_pgn_supported4_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_pgn_supported4_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_pgn_supported4_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_pgn_supported4_2_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_pgn_supported4_2_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_pgn_supported5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_pgn_supported5_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_pgn_supported5_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_pgn_supported5_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_pgn_supported5_2_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool nmea2000_exxo_pgn_lst_transmit_pg_ns_group_function_pgn_supported5_2_is_in_range(uint32_t value);


#ifdef __cplusplus
}
#endif

#endif
